      SUBROUTINE GCPAC(KFILDO,KFIL,LSTORE,ND9,LITEMS,CORE,ND10,
     1                 LASTLD,LASTDD,WORK,ND5,NBLOCK,IER)
C
C        APRIL    1994   GLAHN   TDL   MOS-2000
C        DECEMBER 1999   GLAHN   IMPROVED DIAGNOSTIC AT 145
C        MARCH    2000   GLAHN   CHANGED TO KEEP LASTL, LASTD, NSTORE
C                                IN COMMON
C        MARCH    2000   DALLAVALLE   MODIFIED FORMAT STATEMENTS TO
C                                CONFORM TO FORTRAN 90 STANDARDS
C                                ON THE IBM SP
C        MAY      2000   GLAHN   CHANGED PRINT FROM 3 TO 5 AT 144
C        APRIL    2007   GLAHN   INCREASED I5 TO I7 IN TWO PLACES IN
C                                FORMAT 145
C 
C        PURPOSE 
C            TO ELIMINATE THE ENTRYS IN LSTORE( ,L) (L=1,LITEMS) THAT
C            AREN'T BEING USED, AND TO COMPRESS ACCORDINGLY THE SPACE
C            USED IN CORE( ).  ANY ITEMS STORED ON DISK ARE NOT MOVED
C            TO CORE( ) EVEN IF SPACE IS AVAILABLE.  ITEMS ON DISK 
C            ARE MOVED UP TO COMPRESS SPACE.  FREE ENTRYS ARE
C            DETERMINED BY LSTORE(1, )=0.  DATA, EITHER IN CORE( )
C            OR ON DISK ARE NOT MOVED IF THE MOVEMENT WOULD BE BACK
C            TO THE SAME LOCATIONS.
C 
C        DATA SET USE 
C           KFILDO - UNIT NUMBER FOR OUTPUT (PRINT) FILE.  (OUTPUT)
C             KFIL - UNIT NUMBER FOR DISK ACCESS.  (INPUT-OUTPUT)
C
C        VARIABLES 
C              KFILDO = UNIT NUMBER FOR OUTPUT (PRINT) FILE.  (INPUT)
C                KFIL = UNIT NUMBER FOR DISK ACCESS.  (INPUT)
C         LSTORE(L,J) = THE ARRAY TO HOLD INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR( , ,L) AND
C                              IN NGRIDC( ,L) DEFINING THE CHARACTERISTICS
C                              OF THIS GRID.
C                       L=11 --THE NUMBER OF THE PREDICTOR IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NPRED) FOR WHICH THIS
C                              VARIABLE IS NEEDED, WHEN IT IS NEEDED ONLY
C                              ONCE FROM LSTORE( , ).  WHEN IT IS NEEDED
C                              MORE THAN ONCE, THE VALUE IS SET = 7777.
C                       L=12 --USED INITIALLY IN ESTABLISHING MOSTORE( , ).
C                              LATER USED AS A WAY OF DETERMINING WHETHER
C                              TO KEEP THIS VARIABLE.
C                 ND9 = THE FIRST DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (ROWS) IN LSTORE( , ) THAT 
C                       HAVE BEEN USED IN THIS RUN.  THIS IS MODIFIED
C                       IF COMPACTION CAN BE DONE.  (INPUT-OUTPUT)
C             CORE(J) = THE LINEAR ARRAY WHERE THE DATA ARE STORED
C                       (J=1,ND10).  (INPUT-OUTPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C              LASTLD = THE LAST LOCATION IN CORE( ) USED.  (OUTPUT)
C              LASTDD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK.
C                       (OUTPUT)
C             WORK(J) = WORK ARRAY FOR COMPRESSING DISK (J=1,ND5).
C                       ND5 MUST BE AS LARGE AS THE LARGEST RECORD ON DISK.
C                       (INTERNAL)
C                 ND5 = DIMENSION OF WORK( ).  (INPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE RANDOM DISK FILE.
C                       (INPUT)
C                 IER = STATUS RETURN.
C                        0 = GOOD RETURN.
C                       51 = THE DIMENSION ND5 IS NOT LARGE ENOUGH TO HOLD
C                            THE RECORD TO READ.
C                       900- = IOSTAT RETURNS FROM SYSTEM ON READING/WRITING
C                            DISK.
C                 LOC = NEXT LOCATION TO STORE DATA IN CORE( ).
C                LOCD = NEXT PHYSICAL RECORD TO STORE DATA ON DISK.
C              JITEMS = COUNT OF THE NUMBER OF ITEMS MOVED.
C               NOREC = THE NUMBER OF PHYSICAL RECORDS IN THE LOGICAL
C                       RECORD, WHEN THE DISK IS ACCESSED.
C              NSTORE = INTENAL COUNT, SAVED IN COMMON BLOCK SVLAST OF
C                       THE NUMBER OF TIMES GSTORE IS ENTERED.  IT IS
C                       RETURNED TO THE USER THROUGH THE CALL AS NSTORD.
C                       (COMMON)
C               LASTL = THE LAST LOCATION IN CORE( ) USED.  IT IS KEPT IN
C                       COMMON AND IS CHANGED ONLY IN GSTORE AND GCPAC.
C                       (COMMON)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK.  IT IS
C                       KEPT IN COMMON AND IS CHANGED ONLY IN GSTORE AND
C                       GCPAC.  (COMMON)
C              ISTART = STARTS AS ONE, AND IS INCREMENTED BY ONE EACH
C                       TIME GCPAC IS CALLED UNTIL THE THIRD TIME.  FOR
C                       THE FIRST 3 TIMES, COMPRESSON INFORMATION IS
C                       PRINTED.  (THIS COULD EASILY BE CHANGED TO PRINT
C                       MORE OR LESS TIMES.)
C                         
C        NON SYSTEM SUBROUTINES CALLED 
C           RDDISK, WRDISK
C
      DIMENSION LSTORE(12,ND9)
      DIMENSION WORK(ND5)
      DIMENSION CORE(ND10)
C
      DATA ISTART/1/
C
      COMMON/SVLAST/LASTL,LASTD,NSTORE
C
C***      CALL TIMPR(KFILDO,KFILDO,'START GCPAC         ')
      IER=0
      LOC=1
      LOCD=1
      JITEMS=0
C
C***D     WRITE(KFILDO,100)((LSTORE(I,J),I=1,12),J=1,LITEMS)
C***D100  FORMAT(/' LSTORE STARTING GCPAC'/('  '3I10,I11,3I8,I12,3I8,I12))
C
      DO 140 J=1,LITEMS
C***      WRITE(KFILDO,110)J,LITEMS,JITEMS,LSTORE(1,J),LOC,LOCD
C*** 110  FORMAT(' GCPAC--J,LITEMS,JITEMS,LSTORE(1,J),LOC,LOCD'3I6,I11,2I6)
      IF(LSTORE(1,J).EQ.0)GO TO 140
C
C        MOVE THIS ID.
C
      JITEMS=JITEMS+1
C
      DO 120 K=1,12
      LSTORE(K,JITEMS)=LSTORE(K,J)
 120  CONTINUE
C
      IF(LSTORE(5,J).LT.0)GO TO 130
C      
C        THE DATA ARE IN CORE.  MOVE THEM WHEN NECESSARY.
C
      IF(LOC.EQ.LSTORE(5,J))GO TO 127
C        NO NEED TO STORE BACK IN THE SAME PLACE.
C***D     WRITE(KFILDO,123)
C***D123  FORMAT(' MOVING DATA IN CORE( ) IN GCPAC')
C
      DO 125 K=0,LSTORE(6,J)-1
      CORE(K+LOC)=CORE(K+LSTORE(5,J))
 125  CONTINUE
C
      LSTORE(5,JITEMS)=LOC
 127  LOC=LOC+LSTORE(6,J)
      GO TO 140
C
C        THE DATA ARE ON DISK.  MOVE THEM WHEN NECESSARY,
C        OTHERWISE THE DISK MAY BECOME VERY FULL.
C 
 130  NOREC=(LSTORE(6,J)+NBLOCK-1)/NBLOCK
C        NOREC IS THE NUMBER OF PHYSICAL RECORDS IN THE LOGICAL 
C        RECORD.
C***D     WRITE(KFILDO,1301)(LSTORE(M,J),M=1,12),LOCD
C***D1301 FORMAT(' IN GCPAC--LSTORE( ,J), LOCD ='3I11,4I5,I12,3I5,I11,I6)
      IF(-LSTORE(5,J).EQ.LOCD)GO TO 138
C
C        NO NEED TO READ/WRITE TO THE SAME PLACE.
C***D     WRITE(KFILDO,1302)
C***D1302 FORMAT(' MOVING DATA ON DISK IN GCPAC')
      IF(ND5.GE.LSTORE(6,J))GO TO 132
C
C        THE DIMENSION ND5 OF WORK( ) IS NOT LARGE ENOUGH TO HOLD
C        THE STORED LOGICAL RECORD.
      IER=51
      WRITE(KFILDO,131)ND5,LSTORE(6,J),IER
 131  FORMAT(/,' ****ND5 =',I6,' NOT LARGE ENOUGH TO HOLD LOGICAL',
     1         ' RECORD OF SIZE =',I6,/,
     2         '     WHILE COMPRESSING DISK IN GCPAC.',
     3         '  DISK NOT FULLY COMPRESSED.  IER =',I4)
C        THIS RECORD IS NOT MOVED.  ADJUST LOCD TO REFLECT END OF
C        THIS RECORD.
      LOCD=-LSTORE(5,JITEMS)+NOREC
      GO TO 139
C
 132  CALL RDDISK(KFILDO,KFIL,-LSTORE(5,J),WORK,LSTORE(6,J),
     1           NBLOCK,NOREC,IER)
      IF(IER.NE.0)GO TO 160
C        THIS IS A FATAL ERROR.  DIAGNOSTIC PRINTED IN RDDISK.
C
      CALL WRDISK(KFILDO,KFIL,LOCD,WORK,LSTORE(6,J),NBLOCK,
     1            NOREC,IER)
      IF(IER.NE.0)GO TO 160
C        THIS IS A FATAL ERROR.  DIAGNOSTIC PRINTED IN WRDISK.
C
      LSTORE(5,JITEMS)=-LOCD
 138  LOCD=LOCD+NOREC
 139  CONTINUE
C***D     WRITE(KFILDO,1391)NBLOCK,NOREC,LOC,LOCD
C***D1391 FORMAT(' NBLOCK, NOREC, LOC, LOCD ='4I6)
 140  CONTINUE
C
      LASTLX=LOC-1
      LASTDX=LOCD-1
      IF(JITEMS.EQ.ND9)GO TO 144
C
C        ZERO THE UNFILLED SLOTS, IF ANY.
C
      DO 142 J=JITEMS+1,ND9
      LSTORE(1,J)=0
      LSTORE(5,J)=0
 142  CONTINUE
C
C        PRINT COMPRESSION INFORMATION FOR ONLY THE FIRST THREE DAYS.
C
 144  IF(ISTART.LE.5)THEN
         WRITE(KFILDO,145)LITEMS,JITEMS,ND9,ISTART,LASTL,LASTLX,ND10,
     1                    LASTD,LASTDX,NBLOCK
 145     FORMAT(/,' COMPRESSION OF LSTORE( , ) FROM',I5,' TO',I7,
     1            ' ITEMS;',I7,' SLOTS AVAILABLE, AT END OF DAY',
     2            ' ',I2,'.',/,
     3            ' COMPRESSION OF CORE( ) FROM ',I8,' TO',I7,
     4            ' WORDS;',I7,' WORDS AVAILABLE.',/,
     5            ' COMPRESSION OF DISK FROM',6X,I6,' TO',I7,
     6            ' PHYSICAL RECORDS (PHYSICAL RECORD =',I6,' WORDS).')
         ISTART=ISTART+1
      ENDIF
C
C        STORE LITEMS, LASTLD, AND LASTDD FOR RETURN IN CALL.
C        STORE LASTL AND LASTD FOR SAVING IN COMMON
C
      LITEMS=JITEMS
      LASTL =LASTLX
      LASTLD=LASTLX
      LASTD =LASTDX  
      LASTDD=LASTDX  
C
D     WRITE(KFILDO,200)((LSTORE(I,J),I=1,12),J=1,LITEMS)
D200  FORMAT(/' LSTORE ENDING GCPAC'/('  '3I10,I11,3I8,I12,3I8,I12))
C***      CALL TIMPR(KFILDO,KFILDO,'END GCPAC           ')
 160  RETURN
      END 
