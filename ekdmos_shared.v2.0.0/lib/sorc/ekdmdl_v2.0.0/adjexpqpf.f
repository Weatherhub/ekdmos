      SUBROUTINE ADJEXPQPF(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1                  ID,IDPARS,JD,ITAU,
     2                  NDATE,MDATE,CCALL,ISDATA,XDATA,ND1,NSTA,
     3                  ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4                  LSTORE,ND9,LITEMS,CORE,ND10,
     5                  NBLOCK,NFETCH,
     6                  IS0,IS1,IS2,IS4,ND7,
     7                  L3264B,L3264W,IER)
C 
C        FEBRUARY 2007   MALONEY/YAN  MDL   MOS-2000
C
C        PURPOSE
C            TO ADJUST EXPECTED VALUE OF A VARIABLE, E.G., PRECIP AMOUNT,
C            BASED ON THE MATCHING CATEGORICAL FORECAST.  
C
C            NOTE:  THIS CODE IS A SPINOFF OF THE ROUTINE ADJEXP, WHICH 
C            ACTUALLY DOES ADJUSTMENTS TO THE EXPECTED VALUE.  THIS CODE
C            ENFORCES CONSISTENCY ONLY FOR CATEGORY 1 (NO RAIN) EVENTS.
C
C            THE FOLLOWING IDPARS(1) AND IDPARS(2) ARE ACCOMMODATED:
C
C                203 270 - 6-H QPF EXPECTED VALUE ADJUSTED FOR THE
C                          CATEGORICAL FORECAST
C                203 370 - 12-H QPF EXPECTED VALUE ADJUSTED FOR THE
C                          CATEGORICAL FORECAST
C
C        DATA SET USE 
C            KFILDO - DEFAULT UNIT NUMBER FOR OUTPUT (PRINT) FILE.
C                     (OUTPUT) 
C            KFIL10 - UNIT NUMBER OF MDL MOS-2000 FILE SYSTEM ACCESS.
C                     (INPUT-OUTPUT) 
C              IP12 - INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                     STATIONS ON THE INPUT FILES WILL BE PRINTED TO
C                     THE FILE WHOSE UNIT NUMBER IS IP12.  (OUTPUT)
C         KFILRA(J) - THE UNIT NUMBERS FOR WHICH RANDOM ACCESS FILES
C                     ARE AVAILABLE (J=1,NUMRA).  (INPUT)
C 
C        VARIABLES 
C              KFILDO = DEFAULT UNIT NUMBER FOR OUTPUT (PRINT) FILE.
C                       (INPUT) 
C              KFIL10 = UNIT NUMBER OF MDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C                IP12 = INDICATES WHETHER (>0) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE EXTERNAL RANDOM ACCESS FILES
C                       WILL BE LISTED TO UNIT IP12.  (INPUT)
C           KFILRA(J) = THE UNIT NUMBERS FOR WHICH RANDOM ACCESS FILES
C                       ARE AVAILABLE (J=1,NUMRA).  (INPUT)
C           RACESS(J) = THE FILE NAMES ASSOCIATED WITH KFILRA(J)
C                       (J=1,NUMRA). (CHARACTER*60)  (INPUT)
C               NUMRA = THE NUMBER OF VALUES IN KFILRA( ) AND RACESS( ).
C                       (INPUT)
C               ID(J) = THE PREDICTOR IDS (J=1,4).  (INPUT)
C           IDPARS(J) = THE PARSED, INDIVIDUAL COMPONENTS OF THE 
C                       PREDICTOR ID CORRESPONDING TO ID( ) (J=1,15)
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 
C                            1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK IN 
C                            TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C               JD(J) = THE BASIC INTEGER PREDICTOR IDS (J=1,4).
C                       THIS IS THE SAME AS ID(J), EXCEPT THAT THE
C                       PORTIONS PERTAINING TO PROCESSING ARE OMITTED:
C                       B = IDPARS(3),
C                       T = IDPARS(8),
C                       I = IDPARS(13),
C                       S = IDPARS(14),
C                       G = IDPARS(15), AND
C                       THRESH.
C                       JD( ) IS USED TO IDENTIFY THE BASIC MODEL FIELDS
C                       AS READ FROM THE ARCHIVE.  (INPUT)
C                ITAU = THE NUMBER OF HOURS AHEAD TO FIND A VARIABLE.
C                       THIS HAS ALREADY BEEN CONSIDERED IN MDATE, BUT
C                       IS NEEDED FOR CALL TO RETVEC.  (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH PREDICTOR IS NEEDED.
C                       (INPUT)
C               MDATE = NDATE UPDATED WITH ITAU( ).  (INPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST, EXCEPT POSSIBLY 
C                       CCALLD( ).  (CHARACTER*8)  (INPUT)
C           ISDATA(K) = WORK ARRAY (K=1,ND1).  (INTERNAL)
C            XDATA(K) = COMPUTED VARIABLE IS RETURNED IN XDATA( )
C                       (K=1,NSTA).  (OUTPUT)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT 
C                       WITH.  DIMENSION OF ISDATA( ) AND FIRST
C                       DIMENSION OF XDATA( ) .  (INPUT)
C                NSTA = NUMBER OF STATIONS OR LOCATIONS BEING DEALT
C                       WITH.  (INPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN 
C                       INTEGER VARIABLE (L=1,L3264W) (K=1,ND5).
C                       THIS ARRAY IS USED TO READ THE STATION 
C                       DIRECTORY FROM A MOS-2000 EXTERNAL FILE.
C                       EQUIVALENCED TO CCALLD( ).  (CHARACTER*8) 
C                       (INTERNAL)
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5). 
C                       EQUIVALENCED TO ICALLD( , ).  (INTERNAL)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = WORK ARRAY (J=1,ND5).  (NOT ACTUALLY USED.)
C                       (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).
C                       (INPUT)
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN MDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR( , ,L) AND
C                              IN NGRIDC( ,L) DEFINING THE 
C                              CHARACTERISTICS OF THIS GRID.
C                       L=11 --THE NUMBER OF THE PREDICTOR IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NPRED) FOR WHICH 
C                              THIS VARIABLE IS NEEDED, WHEN IT IS 
C                              NEEDED ONLY ONCE FROM LSTORE( , ). 
C                              WHEN IT IS NEEDED MORE THAN ONCE, THE 
C                              VALUE IS SET = 7777.
C                       L=12 --USED INITIALLY IN ESTABLISHING 
C                              MSTORE( , ).  LATER USED AS A WAY OF
C                              DETERMINING WHETHER TO KEEP THIS 
C                              VARIABLE.
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , )
C                       THAT HAVE BEEN USED IN THIS RUN.  (INPUT)
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA 
C                       IDENTIFIED IN LSTORE( , ) (J=1,ND10).  WHEN 
C                       CORE( ) IS FULL DATA ARE STORED ON DISK.
C                       (INPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.
C                       GFETCH KEEPS TRACK OF THIS AND RETURNS THE
C                       VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3). 
C                       (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+). 
C                       (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12). 
C                       (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4). 
C                       (INTERNAL) 
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4().
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  
C                       CALCULATED BY PARAMETER, BASED ON L3464B.
C                       (INPUT)
C                 IER = STATUS RETURN.
C                         0 = GOOD RETURN.
C                       102 = ID NOT ACCOMMODATED.
C                       SEE GFETCH FOR OTHER VALUES.  (OUTPUT)
C               LD(J) = HOLDS THE 4 ID WORDS OF THE DATA RETRIEVED INTO
C                       XDATA( ) (J=1,4).  (INTERNAL)
C           LDPARS(J) = PARSED VALUES CORRESPONDING TO LD( ) (J=1,15)
C                       (INTERNAL)
C         ITABLE(I,J) = VALUES OF CCCFFF ACCOMMODATED. (INTERNAL)
C                       I=1--OUTPUT VARIABLE.
C                       I=2--RAW EXPECTED VALUE.
C                       I=3--CATEGORICAL GUIDANCE VALUE.
C                       I=4--"BACKUP" CATEGORICAL GUIDANCE, IF AVAILABLE.
C                       I=5--NUMBER OF CATEGORIES FOR EACH ELEMENT.
C                       (J=1,NDIM)   (INTERNAL)
C         BOUNDS(I,J) = THE INTERVALS BETWEEN CATEGORICAL VALUES.  USED IN THE
C                       ADJUSTMENT PROCESS TO DETERMINE THE CATEGORICAL VALUE 
C                       ASSOCIATED WITH THE INPUT "RAW" EXPECTED VALUE.  
C                       (I=1,8; J=1,NDIM)   (INTERNAL)
C         CATAVG(I,J) = THE MEAN VALUES ASSOCIATED WITH EACH CATEGORY.  USED
C                       IN THE ADJUSTMENT PROCESS TO DETERMINE THE APPROPRIATE
C                       "ADJUSTMENT FACTOR" TO NUDGE THE EXPECTED VALUE.
C                       (I=1,8; J=1,NDIM)   (INTERNAL)
C            EDATA(K) = WORK ARRAY WHICH STORES THE RAW EXPECTED VALUES FROM
C                       RETVEC. (K=1,ND1) (AUTOMATIC)
C            CDATA(K) = WORK ARRAY WHICH STORES THE CATEGORICAL VALUES FROM
C                       RETVEC. (K=1,ND1) (AUTOMATIC)
C                NDIM = NUMBER OF POSSIBLE ID'S FOR PROCESS IN ITABLE().  
C                       SET BY PARAMETER.  (INTERNAL)
C               IECAT = CATEGORY OF THE RAW EXPECTED VALUE.  (INTERNAL)
C 
C        NONSYSTEM SUBROUTINES CALLED 
C            RETVEC, PRSID1
C
      INTEGER, PARAMETER :: NDIM=3
C
      CHARACTER*8 CCALL(ND1,6)
      CHARACTER*8 CCALLD(ND5)
      CHARACTER*60 RACESS(5)
C
C
      DIMENSION XDATA(ND1),ISDATA(ND1),EDATA(ND1),CDATA(ND1)
C        EDATA( ) AND CDATA( ) ARE AUTOMATIC ARRAYS
      DIMENSION ID(4),IDPARS(15),JD(4)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9)
      DIMENSION CORE(ND10),ICALLD(L3264W,ND5)
      DIMENSION LD(4),LDPARS(15),KFILRA(5)
C
      DIMENSION ITABLE(5,NDIM)
C
      REAL BOUNDS(8,NDIM),CATAVG(8,NDIM)
C     
C        FOR REFERENCE:
C        JJ = 1   OPAQUE SKY COVER
C        JJ = 2   6-H PRECIP. EXPECTED VALUE
C        JJ = 3   12-H PRECIP. EXPECTED VALUE  
C                                              
C        CCCFFFS                               
C        FOR:     ADJ.   "RAW"  PRI.   BACKUP # OF
C                 EXPVAL EXPVAL CATEG. CATEG. CATS
C
      DATA ITABLE/208395,208385,208381,999999,5,
     +            203270,203260,203221,999999,6,
     +            203370,203360,203331,203321,7/
C
C        BOUNDS CONTAINS THE BREAKPOINTS FOR THE VARIOUS
C        CATEGORICAL GUIDANCE.  A CATEGORICAL VALUE OF 1 SHOULD
C        FALL BETWEEN BOUNDS(1,JJ) AND (2,JJ); A CATEGORICAL VALUE
C        OF 2 SHOULD FALL BETWEEN BOUNDS(2,JJ) AND (3,JJ), ETC.
C
      DATA BOUNDS/0.000,0.050,0.250,0.500,0.870,1.000,9999.,9999.,
     +            0.000,0.010,0.100,0.250,0.500,1.000,9999.,9999.,
     +            0.000,0.010,0.100,0.250,0.500,1.000,2.000,9999./
C
C        CATAVG CONTAINS THE MEAN VALUE OF EACH CATEGORY POSSIBLE
C        IN THE CATEGORICAL GUIDANCE.  THEY SHOULD MATCH THE 
C        ENTRIES IN THE ROUTINE EXPVAL FOR CONSISTENCY.
C        9999S ARE USED TO FILL OUT THE ARRAY.  THESE VALUES SHOULD
C        NEVER ACTUALLY BE READ BY THE CODE.
C
      DATA CATAVG/0.025,0.150,0.375,0.685,0.935,9999.,9999.,9999.,
     +            0.000,0.050,0.175,0.375,0.750,1.250,9999.,9999.,
     +            0.000,0.050,0.175,0.375,0.750,1.500,2.100,9999./
C
      IER=0
C      
C        TO CHECK IF VARIABLE ID IS ACCOMMODATED
C
      DO 100 JJ=1,NDIM
        IF(ITABLE(1,JJ).EQ.(IDPARS(1)*1000+IDPARS(2))) GO TO 108
 100  CONTINUE
C     
      WRITE(KFILDO,107)(JD(L),L=1,4)
 107  FORMAT(/,' ****ADJEXP FOR VARIABLE',
     1        2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     2        ' NOT ACCOMMODATED.')
      IER=102
      GO TO 300
C
C        RETRIEVE RAW EXPECTED VALUE FORECASTS
C
 108  LD(1)=ITABLE(2,JJ)*1000+IDPARS(3)*100+IDPARS(4)
      LD(2)=ID(2)
      LD(3)=ID(3)
      LD(4)=ID(4)
C
      CALL PRSID1(KFILDO,LD,LDPARS)
      CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1            LD,LDPARS,JD,ITAU,
     2            NDATE,MDATE,CCALL,ISDATA,EDATA,ND1,NSTA,
     3            ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4            LSTORE,ND9,LITEMS,CORE,ND10,
     5            NBLOCK,NFETCH,
     6            IS0,IS1,IS2,IS4,ND7,
     7            L3264B,L3264W,IER)
C
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT CONST DOES NOT USE IT EITHER.
C
      IF(IER.NE.0) THEN
 120     WRITE(KFILDO,121)(LD(L),L=1,4)
 121     FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN ',
     1            'ADJEXP',2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3)
         GOTO 300
      ENDIF
C
C        RETRIEVE CATEGORICAL FORECASTS
C
      LD(1)=ITABLE(3,JJ)*1000+IDPARS(3)*100+IDPARS(4)
      LD(2)=ID(2)
      LD(3)=ID(3)
      LD(4)=ID(4)
C
      CALL PRSID1(KFILDO,LD,LDPARS)
      CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1            LD,LDPARS,JD,ITAU,
     2            NDATE,MDATE,CCALL,ISDATA,CDATA,ND1,NSTA,
     3            ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4            LSTORE,ND9,LITEMS,CORE,ND10,
     5            NBLOCK,NFETCH,
     6            IS0,IS1,IS2,IS4,ND7,
     7            L3264B,L3264W,IER)
C
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT CONST DOES NOT USE IT EITHER.
C
      IF(IER.NE.0)THEN
C
C           THE PRIMARY CATEGORICAL ID FAILED.  IF A BACKUP ID
C           IS PRESENT IN ITABLE(4,JJ), TRY FETCHING WITH IT.
C
         IF(ITABLE(4,JJ).EQ.999999) GOTO 160
C
         LD(1)=ITABLE(4,JJ)*1000+IDPARS(3)*100+IDPARS(4)
         CALL PRSID1(KFILDO,LD,LDPARS)
         CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD,ITAU,
     2               NDATE,MDATE,CCALL,ISDATA,CDATA,ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,IER)
C
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT CONST DOES NOT USE IT EITHER.
C
 160     IF(IER.NE.0) THEN  
            WRITE(KFILDO,161)(LD(L),L=1,4)
 161        FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN ',
     1               'ADJEXP',2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3)
            GOTO 300
         ENDIF
      ENDIF
C
C        COMPARE EXPECTED VALUE (EDATA) WITH CATEGORICAL FORECAST (CDATA)
C        AND PERFORM ADJUSTMENT TO THE EXPECTED VALUE ACCORDINGLY
C
      DO 200 M=1,NSTA
C
C           CHECK FOR MISSINGS
C
         IF((NINT(EDATA(M)).EQ.9999).OR.(NINT(CDATA(M)).EQ.9999).OR.
     1      (CATAVG(NINT(CDATA(M)),JJ).EQ.9999)) THEN
            XDATA(M)=9999.
            GO TO 200
         ENDIF
         IF((NINT(EDATA(M)).EQ.9997).OR.(NINT(CDATA(M)).EQ.9997)) THEN
            XDATA(M)=9997.
            GO TO 200
         ENDIF
C
C           DETERMINE WHICH CATEGORY OUR EXPECTED VALUE FALLS IN
C           FIRST CHECK FOR CLOUDS
C
         IF((IDPARS(1)*1000+IDPARS(2)).EQ.208395) THEN
            IF(NINT(1000.*EDATA(M)).GT.NINT(1000.*BOUNDS(1,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LE.NINT(1000.*BOUNDS(2,JJ))) THEN
               IECAT=1
            ELSEIF(NINT(1000.*EDATA(M)).GT.NINT(1000.*BOUNDS(2,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LE.NINT(1000.*BOUNDS(3,JJ))) THEN
               IECAT=2
            ELSEIF(NINT(1000.*EDATA(M)).GT.NINT(1000.*BOUNDS(3,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LE.NINT(1000.*BOUNDS(4,JJ))) THEN
               IECAT=3
            ELSEIF(NINT(1000.*EDATA(M)).GT.NINT(1000.*BOUNDS(4,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LE.NINT(1000.*BOUNDS(5,JJ))) THEN
               IECAT=4
            ELSE
               IECAT=5
            ENDIF
C
C           SECOND CHECK FOR QPF
C
         ELSEIF((IDPARS(1)*1000+IDPARS(2)).EQ.203270.OR.
     1          (IDPARS(1)*1000+IDPARS(2)).EQ.203370) THEN
            IF(NINT(1000.*EDATA(M)).GE.NINT(1000.*BOUNDS(1,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LT.NINT(1000.*BOUNDS(2,JJ))) THEN
               IECAT=1
            ELSEIF(NINT(1000.*EDATA(M)).GE.NINT(1000.*BOUNDS(2,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LT.NINT(1000.*BOUNDS(3,JJ))) THEN
               IECAT=2
            ELSEIF(NINT(1000.*EDATA(M)).GE.NINT(1000.*BOUNDS(3,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LT.NINT(1000.*BOUNDS(4,JJ))) THEN
               IECAT=3
            ELSEIF(NINT(1000.*EDATA(M)).GE.NINT(1000.*BOUNDS(4,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LT.NINT(1000.*BOUNDS(5,JJ))) THEN
               IECAT=4
            ELSEIF(NINT(1000.*EDATA(M)).GE.NINT(1000.*BOUNDS(5,JJ)).AND.
     1         NINT(1000.*EDATA(M)).LT.NINT(1000.*BOUNDS(6,JJ))) THEN
               IECAT=5
            ELSE
C
C                 SPECIAL CHECKS FOR UPPER-END QPF CATEGORIES
C
               IF((IDPARS(1)*1000+IDPARS(2)).EQ.203270) THEN
                  IECAT=6
               ELSE
                  IF(NINT(1000.*EDATA(M)).GE.NINT(1000.*BOUNDS(6,JJ))
     1            .AND.NINT(1000.*EDATA(M)).LT.NINT(1000.*BOUNDS(7,JJ)))
     2            THEN
                     IECAT=6
                  ELSE
                     IECAT=7
                  ENDIF
               ENDIF
            ENDIF
C
         ENDIF
C
C           CHECK ONE:  CATEGORICAL FORECAST OF (5) AND EXPECTED VALUE
C                       FALLS IN CATEGORY 5 ( 0.87 <  EV <= 1.00 )
C           CHECK TWO:  CATEGORICAL FORECAST OF (1) AND EXPECTED VALUE
C                       FALLS IN CATEGORY 1 ( 0.00 <= EV <= 0.05 )
C
C           THESE TWO CHECKS ARE FOR CLOUDS ONLY (208395)!
C
         IF((IDPARS(1)*1000+IDPARS(2).EQ.208395).AND.
     1                     (NINT(CDATA(M)).EQ.5).AND.IECAT.EQ.5)THEN
            XDATA(M)=BOUNDS(5,JJ)+(BOUNDS(6,JJ)-BOUNDS(5,JJ))*
     1             ((EDATA(M)-BOUNDS(5,JJ))/(CATAVG(5,JJ)-BOUNDS(5,JJ)))
         ELSEIF((IDPARS(1)*1000+IDPARS(2).EQ.208395).AND.
     1                         (NINT(CDATA(M)).EQ.1).AND.IECAT.EQ.1)THEN
            XDATA(M)=BOUNDS(2,JJ)-(BOUNDS(2,JJ)-BOUNDS(1,JJ))*
     1             ((BOUNDS(2,JJ)-EDATA(M))/(BOUNDS(2,JJ)-CATAVG(1,JJ)))
C
C           CHECK THREE:  CATEGORICAL FORECAST OF (1) FOR QPF.  SET
C                         ADJUSTED EXPECTED VALUE TO 0.0            
C
         ELSEIF(((IDPARS(1)*1000+IDPARS(2).EQ.203270).OR. 
     1           (IDPARS(1)*1000+IDPARS(2).EQ.203370)).AND.
     2           (NINT(CDATA(M)).EQ.1)) THEN
            XDATA(M)=0.0
C
C           END OF THE LINE.   CATEGORICAL FORECAST AND EXPECTED VALUE ARE
C           IN AGREEMENT (OTHER THAN SPECIAL CASES 1 & 2 ABOVE).  
C           SET XDATA TO EDATA.
C
         ELSE
            XDATA(M)=EDATA(M)
         ENDIF
C
 200  CONTINUE
C
      GO TO 350   
C     
C        THIS PREDICTOR CANNOT BE COMPUTED.  SET THE ARRAY TO MISSING.
C        THE MAX FUNCTION GUARDS AGAINST NCAT LT 0 AND ALWAYS SETS
C        ONE COLUMN TO MISSING.  THIS IS RELATIVELY UNIMPORTANT
C        BECAUSE THE CALLING ROUTINES WILL DO THE SAME THING.
C
 300  DO 310 J=1,ND1
         XDATA(J)=9999.
 310  CONTINUE
C
 350  RETURN
      END
