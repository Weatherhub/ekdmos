      SUBROUTINE RDVECT(KFILDO,KFIL10,KFILIN,NAMIN,JFOPEN,MDATE,NUMIN,
     1                  MSDATE,MAXTAU,IN,IPRINT,PXMISS,
     2                  ID,IDPARS,JD,LD,NWHERE,NVRBL,N,ISTAB,
     3                  NDATE,CCALL,SDATA,XDATA,INDEXC,ND1,NSTA,
     4                  CCALLD,IPACK,IWORK,DATA,ND5,
     5                  LSTORE,MSTORE,ND9,LITEMS,MITEMS,CORE,ND10,
     6                  LASTL,LASTD,NBLOCK,NSTORE,
     7                  IS0,IS1,IS2,IS4,ND7,
     8                  IP12,IP14,IP23,L3264B,L3264W,ISTOP,IER)
C
C        JANUARY   1997   GLAHN   TDL   MOS-2000
C        JANUARY   1997   GLAHN   MSTA ELIMINATED FROM CALL
C        FEBRUARY  1997   GLAHN   COMMENT FOR INDEXC( ) AUGMENTED
C        FEBRUARY  1997   GLAHN   RESTRUCTURED TO STORE DATA UNPACKED,
C                                 NBYTES(L3264W) ADDED, NFETCH REMOVED
C        MARCH     1997   GLAHN   RESTRUCTURED FOR LOOKAHEAD FEATURE;
C                                 ADDED IP23 CAPABILITY
C        JULY      1997   GLAHN   INCREASED DIMENSIONS OF CCALL( ) TO
C                                 ACCOMMODATE SUBSTITUTE STATIONS
C        AUGUST    1997   GLAHN   CHANGED WHERE M IS SET = 9999
C        AUGUST    1997   GLAHN   CHANGED MSTORE(7, ) TO MSTORE(8, )
C        AUGUST    1997   GLAHN   ISTOP NOT INCREMENTED WHEN IER = 137
C        AUGUST    1997   GLAHN   MSTORE(8,M) SET = 9999 WHEN VRBL M USED
C                                 SECOND DIMENSION OF INDEXC( , ) ADDED
C        SEPTEMBER 1997   GLAHN   CHANGES FOR TRAILER USE CHANGE
C        NOVEMBER  1997   GLAHN   MODIFIED COMMENTS AND DIAGNOSTICS
C        DECEMBER  1997   GLAHN   ADDED ISTAB TO CALL AND INTERNALLY
C        JANUARY   1998   GLAHN   PXMISS ADDED TO CALL AND USED
C        MARCH     1998   GLAHN   DIAGNOSTIC AUGMENTED AT 1156
C        APRIL     1998   GLAHN   DIAGNOSTIC SHORTENED TO FIT ON LINE
C        MAY       1998   GLAHN   DIAGNOSTIC MODIFIED AT 1156
C        MAY       1998   GLAHN   LD(6) INCREASED TO LD(7)
C        JUNE      1998   GLAHN   SLIGHT CHANGE TO DIAGNOSTICS
C        JUNE      1998   GLAHN   ADDED MDATE( ) 
C        SEPTEMBER 1998   GLAHN   MODIFIED /D PRINT AT 1165; INSERTED
C                                 IF TEST ON M.LE.ND9 BELOW 136                    
C        SEPTEMBER 1998   GLAHN   ADDED TEST TO NOT SAVE CONSTANTS
C        OCTOBER   1998   GLAHN   INDEXC( ) = 99999999 FOR MISSING
C        DECEMBER  1998   GLAHN   CHANGED POSITION OF IER = 146 OUT 
C                                 OF RDDIR AFTER 1140
C        APRIL     2000   DALLAVALLE   MODIFIED FORMAT STATEMENTS TO
C                                 CONFORM TO FORTRAN 90 STANDARDS
C                                 ON THE IBM SP
C        SEPTEMBER 2000   GLAHN   CORRECTED COMMENT FOR DATA( )
C        JULY      2002   GLAHN   MODIFIED DIAGNOSTIC AT 1180
C        OCTOBER   2003   GLAHN   COMMAS IN /D FORMAT STATEMENTS;
C                                 SPELL CHECK
C        NOVEMBER  2003   GLAHN   CHANGED /D DIAGNOSTICS
C        NOVEMBER  2003   GLAHN   ADDED IWITCH( )
C        JANUARY   2004   GLAHN   CHANGED CALL TO UPDAT TO KEEP LDATE
C                                 FROM BEING BEFORE NDATE
C        MARCH     2004   GALHN   CHANGED CHECK ON 8XX TO 9XX BELOW 138
C                                 TO NOT SAVE STRATIFICATION VARIABLES 
C        APRIL     2004   SMB     MODIFIED IOS CHECKING AFTER ALLOCATION
C                                 OF ARRAY IWITCH( ).  ORIGINALLY, IOS=1
C                                 AND IOS=2 WERE EXPLICITLY CHECKED; 
C                                 ON IBM, IOS=3 IS ALSO POSSIBLE, BUT WAS
C                                 NOT CHECKED, WHICH COULD HAVE UNDESIRABLE
C                                 RESULTS.  CHECK CHANGED TO IOS.NE.0.
C        JUNE      2005   RLC     INCORPORATED MCE 5/2000 OPERATIONS FIX
C                                 "REMOVED FILENAME FROM OPEN STMNT FOR 
C                                 OPERATIONS"
C        JULY      2012   ENGLE   ADDED CONVERTX; ADDED CALL TO CKFILEND
C                                 BEFORE OPENING A TDLPACK VECTOR FILE;
C                                 MODIFIED OPEN STATEMENT TO INLCUDE
C                                 CONVERT= SPECIFIER.
C
C        PURPOSE
C           TO OBTAIN FOR VRBL62, VRBL72, AND SIMILAR ROUTINES 
C           VARIABLES IDENTIFIED IN MSTORE( , ), STORE THEM IN
C           THE MOS-2000 INTERNAL STORAGE SYSTEM AS NEEDED,
C           AND PASS THEM BACK AS NEEDED.  WHEN THE DATE IN A 
C           RECORD IS 9999, ANOTHER DIRECTORY RECORD WILL FOLLOW;
C           THIS IS ACCOMMODATED.  ONLY ONE VARIABLE IS RETURNED
C           PER CALL.
C   
C        DATA SET USE
C            KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10 - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                     (INPUT-OUTPUT) 
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C           KFILIN(J) = UNIT NUMBERS FOR INPUT DATA, ALL IN TDL GRIB FORMAT.
C                       INPUT CAN INCLUDE INTERPOLATED MODEL DATA, PREDICTAND
C                       (OBSERVATIONS) DATA, VARIOUS CONSTANTS, OR MOS FORECASTS
C                       (FOR 2ND GENERATION MOS, POSSIBLY FOR LOCAL IMPLEMENTATION
C                       (J=1,NUMIN).  (INPUT)
C            NAMIN(J) = NAME OF THE INPUT FILES BEING PROCESSED (J=1,NUMIN).
C                       (CHARACTER*60)  (INPUT)
C           JFOPEN(J) = FOR EACH FILE IN KFILIN(J), JFOPEN(J) IS 1 WHEN
C                       THE FILE IS OPEN, IS 0 WHEN IT HAS ALREADY BEEN
C                       USED AND IS 2 WHEN THE FILE HAS NOT BEEN OPENED 
C                       (J=1,NUMIN).  (INPUT/OUTPUT)
C            MDATE(J) = THE LAST DATE READ BY RDSTRX FOR DAY 1 FOR EACH
C                       FILE (J=1,ND6).  THIS IS USED TO KEEP A 
C                       DIAGNOSTIC FROM PRINTING IN RDVECT.  (INPUT)
C               NUMIN = THE NUMBER OF VALUES IN KFILIN( ), NAMIN( ), AND
C                       INDEXC( , ).  ALSO TREATED AS THEIR DIMENSIONS.
C                       (INPUT)
C              MSDATE = KEEPS TRACK OF WHETHER ANY DATA ARE AVAILABLE
C                       FOR A PARTICULAR DATE ON AN INPUT FILE . 
C                       INITIALIZED TO ZERO.  SET TO 1 WHEN
C                       A DATE/TIME HAS BEEN FOUND ON THAT FILE.  USED 
C                       FOR DIAGNOSTIC PRINT WHEN IP14 NE 0.  (INPUT/OUTPUT)
C              MAXTAU = THE MAXIMUM TAU OF ANY PREDICTAND IN FILE IN.
C                       (INPUT)
C                  IN = THE INDEX OF KFILIN( ), NAMIN( ), AND JFOPEN( ).
C                       (INPUT)
C              IPRINT = USED TO KEEP A DIAGNOSTIC FROM BEING PRINTED
C                       (IPRINT SET TO 0) FOR EACH MISSING VARIABLE
C                       WHEN THE ENTIRE DAY IS MISSING.  (INPUT/OUTPUT)
C              PXMISS = THE VALUE OF A SECONDARY MISSING VALUE TO INSERT
C                       WHEN THE SECONDARY MISSING VALUE IS 9997.
C                       THIS ALLOWS MAINTAINING A 9997, TREATING IT AS 
C                       ZERO, AS 9999, OR AS SOME OTHER VALUE.  (INPUT)
C             ID(J,N) = THE INTEGER PREDICTOR ID'S (J=1,4) (N=1,NVRBL).
C                       (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE PREDICTOR
C                       ID CORRESPONDING TO ID( ) (J=1,15) (N=1,NVRBL).
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C             JD(J,N) = THE BASIC INTEGER PREDICTOR ID (J=1,4) (N=1,NVRBL).
C                       THIS IS THE SAME AS ID(J,N), EXCEPT THAT THE PORTIONS
C                       PERTAINING TO PROCESSING THAT CAN BE DONE IN
C                       RDVECT ARE OMITTED:
C                       B = IDPARS(3, ),
C                       G = IDPARS(15, ), AND
C                       THRESH( ).
C                       JD( , ) IS USED TO IDENTIFY THE BASIC MODEL FIELDS
C                       AS READ FROM THE ARCHIVE.  (INPUT)
C               LD(J) = HOLDS INFORMATION ABOUT THE DATA IN SDATA( )
C                       (J=1,7).
C                       J=1--JD(1,N)
C                       J=2--ID(2,N)
C                       J=3--ID(3,N) 
C                       J=4--IDPARS(3,N)
C                       J=5--IDPARS(13,N)
C                       J=6--IDPARS(14,N)
C                       J=7--MDATE, THE DATE OF THE DATA
C                       (OUTPUT)
C           NWHERE(N) = INDICATES WHERE THE VARIABLE IS TO COME FROM (N=1,ND4)
C                       0 = UNDETERMINED
C                       1 = FROM INPUT FILE
C                       2 = BINARY FROM BASIC VARIABLE
C                       3 = FROM OPTX.
C                       (INPUT)
C               NVRBL = THE NUMBER OF VARIABLES NEEDED AND IDENTIFIED IN 
C                       ID( , ), ETC.  ALSO TREATED AS THE DIMENSION OF THE
C                       VARIABLES ID( , ), ETC.  (INPUT)
C                   N = THE VARIABLE RETURNED IN THE LIST ID( ,N), ETC.
C                       (OUTPUT)
C               ISTAB = 1 WHEN VARIABLE RETURNED IS BINARY;
C                       0 OTHERWISE.  (OUTPUT)
C               NDATE = THE DATE/TIME FOR WHICH PREDICTORS ARE TO BE
C                       FURNISHED ON THIS CALL TO RDVECT.  (INPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST.  (CHARACTER*8)
C                       (INPUT)
C            SDATA(K) = DATA SAVED FOR REUSE (K=1,NSTA).  (OUTPUT)
C            XDATA(K) = THE DATA FOR THE NSTA STATIONS BEING PROCESSED
C                       (K=1,NSTA).  (OUTPUT)
C         INDEXC(K,J) = LOCATIONS OF THE NSTA STATIONS (K=1,NSTA)
C                       FOR EACH OF THE INPUT FILES (J=1,NUMIN)
C                       IN THE LIST CCALL(K, ) IN REFERENCE TO THE 
C                       STATION CALL LETTERS RECORD ON THE INPUT
C                       DATA SET BEING DEALT WITH.  THIS IS UPDATED
C                       IF ANOTHER CALL LETTERS RECORD IS ENCOUNTERED.
C                       THE VALUES IN INDEXC( , ) ARE USED UNTIL THIS
C                       NEW CALL LETTERS RECORD IS FOUND, THEN THE 
C                       NEW VALUES IN INDEXC( , ) PUT THERE BY RDDIR
C                       ARE USED.  IF THE STATION CAN'T BE FOUND IN 
C                       THE DIRECTORY, INDEXC( ) IS SET TO 99999999.
C                       NOTE THAT THIS MUST BE LARGER THAN THE MAXIMUM
C                       NUMBER OF STATIONS BEING DEALT WITH (GRIDPOINTS
C                       IN THE CASE OF GRIDPOINT DEVELOPMENT). 
C                       (INPUT/OUTPUT)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT WITH.
C                       (INPUT)
C                NSTA = THE NUMBER OF STATIONS IN CCALL( , ).  (INPUT)
C           CCALLD(K) = 8-CHARACTER STATION CALL LETTERS (K=1,ND5).
C                       (INTERNAL)
C            IPACK(J) = HOLDS THE TDL GRIB RECORD (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  FURNISHED TO UNPACK, BUT
C                       NOT ACTUALLY USED BECAUSE ONLY THE ID'S ARE
C                       UNPACKED.  (INTERNAL)
C             DATA(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).
C                       (INPUT)
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE DATA 
C                       STORED (L=1,11) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --THE VALUE OF IN IS STORED.
C                       L=11 --THE NUMBER OF THE FIRST PREDICTOR IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NVRBL) FOR WHICH THIS
C                              VARIABLE IS NEEDED, WHEN IT DOES NOT NEED
C                              TO BE STORED AFTER DAY 1.  WHEN THE VARIABLE
C                              MUST BE STORED (TO BE ACCESSED THROUGH OPTION)
C                              FOR ALL DAYS, ID(11,N) IS 7777 + THE NUMBER
C                              OF THE FIRST PREDICTOR IN THE SORTED LIST
C                              FOR WHICH THIS VARIABLE IS NEEDED.
C                       L=12 --USED INITIALLY IN ESTABLISHING MSTORE( , ).
C                              LATER USED AS A WAY OF DETERMINING WHETHER
C                              TO KEEP THIS VARIABLE.
C         MSTORE(L,J) = THE ARRAY HOLDING THE VARIABLES NEEDED AS INPUT, AFTER
C                       DAY 1, AND ASSOCIATED INFORMATION (L=1,8) (J=1,MITEMS).
C                       (INPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --THE VALUE TAKEN FROM LSTORE(11, ) WHICH
C                              INDICATES WHETHER OR NOT TO STORE THE
C                              VARIABLE AND THE FIRST PREDICTOR TO USE IT FOR.
C                       L=6  --THE NUMBER OF HOURS AHEAD THE VARIABLE
C                              NEEDS TO BE SAVED.  THIS IS BASED ON THE
C                              INPUT FILE AND HOW FAR AHEAD IT NEEDS TO
C                              BE READ FOR THE LOOKAHEAD FEATURE.  FOR
C                              INSTANCE, IF A PREDICTOR IS ON THE SAME FILE
C                              AS A PREDICTAND THAT HAS A TAU OF 60 HOURS,
C                              THEN THERE WOULD BE AN ENTRY IN MSTORE( , )
C                              FOR EACH PROJECTION AHEAD IT NEEDS TO BE 
C                              SAVED AS THE FILE IS READ.  HOWEVER, IF
C                              THE PREDICTAND IS ON A SEPARATE FILE,
C                              THERE WOULD BE ONLY ONE ENTRY FOR THE 
C                              PREDICTOR, AND MSTORE(6, ) WOULD BE 0.
C                              MSTORE( , ) IS NOT CHANGED AFTER EXIT, EXCEPT
C                              FOR MSTORE(8, ).
C                       L=7  --TAKEN FROM LSTORE(10, ).  THE NUMBER IN THE
C                              LIST OF UNIT NUMBERS FROM WHICH THE DATA CAME.
C                              STORED AS "IN" IN RDVECT.
C                       L=8  --CALCULATED FROM THE MAXIMUM TAU MAXTAU(IN),
C                              WHERE "IN" IS THE INPUT FILE NUMBER IN 
C                              MSTORE(7, ), AND THE VALUE IN MSTORE(6, )
C                              FOR EACH NEW CYCLE.  THIS KEEPS CALLS TO 
C                              UPDAT TO A MINIMUM.
C                              CORRESPONDING TO MSTORE(6, )
C                       NOTE THAT MSTORE IN U201 AND PRED22 IS NOT EXACTLY
C                       THAT IN U600 AND RDVECT.  U201 DOES NOT USE RDVECT.
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ) AND MSTORE( , ).
C                       (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , ) THAT 
C                       HAVE BEEN USED IN THIS RUN.
C              MITEMS = THE NUMBER OF ITEMS (COLUMNS) IN MSTORE( , ).
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA IDENTIFIED IN
C                       LSTORE( , ) (J=1,ND10).  WHEN CORE( ) IS FULL
C                       DATA ARE STORED ON DISK.  (INPUT-OUTPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C               LASTL = THE LAST LOCATION IN CORE( ) USED.  THIS MAY BE
C                       MODIFIED, ALONG WITH ITEMS, IF COMPACTION IS
C                       DONE BY GCPAC.  INITIALIZED TO ZERO ON FIRST 
C                       ENTRY TO GSTORE.  (INPUT-OUTPUT)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK.  INITIALIZED
C                       TO ZERO ON FIRST ENTRY TO GSTORE.  (INPUT-OUTPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C              NSTORE = RUNNING COUNT OF NUMBER OF TIMES DATA ARE STORED BY 
C                       GSTORE.  INITIALIZED TO ZERO THE FIRST TIME GSTORE
C                       IS CALLED.  GSTORE KEEPS TRACK OF THIS AND RETURNS
C                       THE VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).  (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).  (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C                IP12 = INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE INPUT FILES WILL BE PROVIDED ON 
C                       THE FILE WHOSE UNIT NUMBER IS IP12.  (INPUT)
C                IP14 = INDICATES WHETHER (>0) OR NOT (=0) A DIAGNOSTIC
C                       WILL BE PROVIDED ON UNIT IP14 WHEN THERE ARE
C                       NO DATA FOR A DESIRED DATE/TIME ON A PARTICULAR
C                       INPUT FILE.  (WITH THE SWITCHING OF DATA SETS,
C                       THIS IS NOT OF MUCH USE, AND MAY BE MISLEADING.)
C                       (INPUT)
C                IP23 = INDICATES WHETHER (>0) OR NOT (=0) STATEMENTS
C                       ABOUT EOF AND FILE OPENINGS AND CLOSINGS WILL
C                       BE OUTPUT FOR PRINTING ON UNIT IP23.  (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING USED
C                       (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  
C                       CALCULATED BY PARAMETER, BASED ON L3464B.
C               ISTOP = INCREMENTED BY ONE EACH TIME AN ERROR IS ENCOUNTERED.
C                       (INPUT-OUTPUT)
C                 IER = STATUS RETURN.
C                         0 = GOOD RETURN.
C                       <10 = (FROM UNPKBG)
C                        31 = TROUBLE OPENING FILE OR SWITCHING FILES.
C                        38 = DIMENSION OF IPACK( ) TOO SMALL.
C                       120 = ONE OR MORE STATIONS NOT FOUND IN DIRECTORY
C                             (FROM FINDST IN RDDIR)
C                       137 = NO MORE DATA AVAILABLE.  NOT USUALLY AN 
C                             ERROR.
C                       138 = 500 READING ERRORS HAVE OCCURRED.
C                       140 = ERROR READING DIRECTORY (FROM RDDIR)
C                       145 = TOO MANY STATIONS IN DIRECTORY RECORD
C                             (FROM RDDIR)
C                       146 = END OF FILE.
C                       SEE ROUTINE GSTORE, GFETCH, AND GRCOMB FOR FOR
C                       OTHER VALUES.  (INTERNAL-OUTPUT)
C              NWORDS = NUMBER OF WORDS IN IPACK( ).   (INTERNAL)
C               MISSP = WHEN PRIMARY MISSING VALUE INDICATORS ARE IN THE
C                       DATA RETURNED FROM UNPACK, THEY WILL HAVE THE 
C                       VALUE FLOAT(MISSP).  OTHERWISE, MISSP = 0.
C                       (INTERNAL)
C               MISSS = WHEN SECONDARY MISSING VALUE INDICATORS ARE IN THE
C                       DATA RETURNED FROM UNPACK, THEY WILL HAVE THE 
C                       VALUE FLOAT(MISSS).  OTHERWISE, MISSS = 0.
C                       RDVECT TREATS THIS MISSING VALUE AS ZERO.
C                       (INTERNAL)
C                MSTA = THE NUMBER OF WORDS OF DATA RETURNED = IS4(3).
C                       (INTERNAL)
C               LDATE = THE FARTHEST DATE NEEDED FOR THE DATE/TIME BEING
C                       PROCESSED.  (INTERNAL)
C                   M = THE NUMBER OF THE ITEM IN MSTORE.  (INTERNAL)
C              LSTOPC = AN INTERNAL COUNTER TO KEEP AN INFINITE READING
C                       LOOP FROM OCCURRING.  (INTERNAL)
C               LSTOP = THE VALUE TO COMPARE LSTOPC WITH TO STOP THE
C                       READING.  CURRENTLY SET AT 500; THIS ASSUMES
C                       500 READING ERRORS SHOULD NOT OCCUR IN A SINGLE
C                       RUN.  NOTE THAT THIS COUNT IS SEPARATE FROM
C                       ISTOP IN CASE ISTOP HAS TO BE LARGE WHEN DEALING
C                       WITH HOURLY DATA AND MISSING STATIONS.  (INTERNAL)
C           IWITCH(J) = SWITCH TO INDICATE A SWITCH OF FILES HAS BEEN
C                       MADE ON LAST ENTRY TO KEEP DIAGNOSTIC AT 1156
C                       FROM PRINTING (J=1,NUMIN).  (ALLOCATABLE)
C                       (INTERNAL)
C            CONVERTX = CHARACTER HOLDING THE KEYWORD USED TO OPEN
C                       RANDOM ACCESS FILE WITH THE CORRECT ENDIAN.
C                       (CHARACTER*20).
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES USED 
C            GSTORE, UNPACK, UNPKBG, RDDIR, CKFILEND
C
      CHARACTER*8 CCALL(ND1,6)
      CHARACTER*8 CCALLD(ND5)
      CHARACTER*60 NAMIN(NUMIN)
CINTEL
      CHARACTER*20 CONVERTX
CINTEL
C
      DIMENSION SDATA(ND1),XDATA(ND1)
      DIMENSION INDEXC(ND1,NUMIN)
      DIMENSION ID(4,NVRBL),IDPARS(15,NVRBL),JD(4,NVRBL),
     1          NWHERE(NVRBL)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9),MSTORE(8,ND9)
      DIMENSION CORE(ND10)
      DIMENSION KFILIN(NUMIN),JFOPEN(NUMIN),MDATE(NUMIN)
      DIMENSION LD(7),NBYTES(2)
C
      ALLOCATABLE IWITCH(:)
C        IWITCH( ) IS AN ALLOCATABLE ARRAY.
      SAVE IWITCH
C
CINTEL
      CONVERTX='BIG_ENDIAN'
CINTEL
      DATA LSTOP/500/,
     1     LSTOPC/0/
      DATA IFIRST/0/
C
      IER=0
D     CALL TIMPR(KFILDO,KFILDO,'ENTERNING RDVECT    ')
C
      IF(IFIRST.EQ.0)THEN
C
C           ALLOCATE ARRAY IWITCH.
C  
         ALLOCATE (IWITCH(NUMIN),STAT=IOS)
C
         IF(IOS.NE.0)THEN
            WRITE(KFILDO,105) IOS
 105        FORMAT(/,' ****ALLOCATION OF ARRAY FAILED IN RDVECT AT 105.'
     1              ,'  IOS = ',I4)
            STOP 105
         ENDIF
C
C           INITIALIZE IWITCH( ).
C
         DO 107 J=1,NUMIN
            IWITCH(J)=1
 107     CONTINUE
C
         IFIRST=1
      ENDIF
C
C***      WRITE(KFILDO,100)IP23,L3264B,IN,KFILIN(IN),MAXTAU,NDATE
C*** 100  FORMAT(/' IN RDVECT, IP23,L3264B,IN,KFILIN(IN),MAXTAU,NDATE',6I11)
C
      CALL UPDAT(NDATE,MAX(MAXTAU,0),LDATE)
C        LDATE IS THE FARTHEST DATE NEEDED FOR THE DATE/TIME BEING
C        PROCESSED.  MAXTAU CAN BE -1 AND FILE NOT CLOSED IN U602.
C
C***      IF(IFIRST.EQ.1)WRITE(KFILDO,108)IN,KFILIN(IN),IWITCH(IN),
C***     1               NDATE,LDATE
C*** 108  FORMAT(' IN RDVECT--IN,KFILIN(IN),IWITCH(IN),NDATE,LDATE',
C***     1               3I4,2I12)
C
 110  M=9999
C        M IS USED AS A KEY IN TO EXIT OR NOT NEAR STATEMENT 136.
C        SINCE IT IS USED IN A LOOP IN SEARCHING, IT NEEDS TO BE
C        DEFINED BEFORE EACH READ.
      READ(KFILIN(IN),IOSTAT=IOS,ERR=111,END=1104)
     1              (NBYTES(J),J=1,L3264W),
     2              (IPACK(J),J=1,MIN(ND5,NBYTES(L3264W)*8/L3264B))
C        IPACK( ) CONTAINS THE PACKED RECORD.
C        THE RECORD CONSISTS OF AN INITIAL 64 BITS CONTAINING THE NUMBER
C        OF BYTES FOLLOWING.  FOR A 32-BIT MACHINE, THIS IS TWO WORDS.
      IF(L3264B.EQ.32)THEN
C           FOR A 32-BIT MACHINE, IPACK(5) HOLDS THE DATE/TIME OF THE
C           RECORD.
         IDATE=IPACK(5)
C
      ELSE
C           FOR A 64-BIT MACHINE, THE LEFT HALF OF IPACK(3) HOLDS
C           THE DATE/TIME OF THE RECORD.
         LOC=3
         IPOS=1
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IDATE,32,L3264B,IER,*117)
      ENDIF
C
      NWORDS=NBYTES(L3264W)*8/L3264B
C
C***D     WRITE(KFILDO,1100)NDATE,NWORDS
C***D1100 FORMAT(' RDVECT--NDATE,NWORDS',2I11)
C
      IF(NWORDS.GT.ND5)THEN
         WRITE(KFILDO,1101)ND5,NWORDS,KFILIN(IN),NDATE,NAMIN(IN)
 1101    FORMAT(/,' ****ERROR IN RDVECT AT 1101.',
     1            '  ND5 MUST BE INCREASED FROM',I8,' TO GE',I8,/,
     2            '     READING ON UNIT',I3,' PROCESSING DATE',I11,
     3            ' ON FILE = ',A60)
         ISTOP=ISTOP+1
         IER=38
         GO TO 130
C
      ENDIF
C
      GO TO 113
C
 1104 IF(IP23.NE.0)WRITE(IP23,1105)KFILIN(IN),NDATE,NAMIN(IN)
 1105 FORMAT(/,' END OF  FILE ON UNIT NO.',I3,
     1         ' PROCESSING DATE',I11,'    FILE = ',A60)
      GO TO 1133
C
 111  WRITE(KFILDO,112)KFILIN(IN),NDATE,IOS,NAMIN(IN)
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1          WRITE(IP23,112)KFILIN(IN),NDATE,IOS,NAMIN(IN)
 112  FORMAT(/,' ****ERROR READING PACKED RECORD ON UNIT NO.',I3,
     1         ' PROCESSING DATE',I11,
     2         ' IN RDVECT AT 112.  IOSTAT =',I5,/,
     3         '     ON FILE = ',A60)
      ISTOP=ISTOP+1
      LSTOPC=LSTOPC+1
      IF(LSTOPC.LT.LSTOP)GO TO 110
C        THIS CHECK IS TO STOP AN INFINITE LOOP THAT MIGHT OCCUR.
      WRITE(KFILDO,1120)LSTOP,NDATE
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)WRITE(IP23,1120)LSTOP,NDATE
 1120 FORMAT('     A TOTAL OF',I5,' READING ERRORS HAVE OCCURRED.',
     1       '  RETURN FROM RDVECT AT 1120 WHILE PROCESSING DATE',
     2       I11)
      IER=138
      GO TO 130
C
 113  IF(IDATE.NE.9999)GO TO 115
C***      CALL TIMPR(KFILDO,KFILDO,'ENTER RDDIR RDVECT  ')
C
C        A DUMMY RECORD HAS BEEN FOUND SIGNIFYING A DIRECTORY
C        RECORD OR AN EOF FOLLOWS.  ATTEMPT TO READ THE DIRECTORY
C        AND REINITIALIZE THE STATION LOCATIONS IN INDEXC( , ).
C        
      CALL RDDIR(KFILDO,KFILIN(IN),IP12,NAMIN(IN),NDATE,
     1           CCALL,INDEXC(1,IN),ND1,NSTA,CCALLD,ND5,MSTA,
     2           L3264B,L3264W,IER)
C
C***      CALL TIMPR(KFILDO,KFILDO,'LEAVE RDDIR RDVECT ')
      IF(IER.EQ.0)THEN
C           DIRECTORY READ OK; READ DATA.
         GO TO 110
C
      ELSEIF(IER.EQ.120)THEN
         ISTOP=ISTOP+1
C           IER = 120 JUST MEANS ONE OR MORE STATIONS COULD
C           NOT BE FOUND IN THE DIRECTORY; READ DATA.
         GO TO 110
C
      ELSEIF(IER.EQ.146)THEN
C           IS NOT COUNTED AS AN ERROR.
         IF(IP23.NE.0)WRITE(IP23,1131)KFILIN(IN),NDATE,NAMIN(IN)
 1131    FORMAT(/,' END OF  FILE ON UNIT NO.',I3,
     1            ' PROCESSING DATE',I11,'    FILE = ',A60)
         GO TO 1133
C
      ELSE
         ISTOP=ISTOP+1
         GO TO 1133
C           IER = 146 MEANS AN EOF ON UNIT IN.
C           ERRORS IER = 140 AND 145 ARE FATAL AND
C           ARE TREATED THE SAME AS AN END OF FILE.
      ENDIF
C
      GO TO 130
C
 1133 CLOSE(UNIT=KFILIN(IN),IOSTAT=IOS,ERR=1136)
      IF(IP23.NE.0)WRITE(IP23,1134)KFILIN(IN),NDATE,NAMIN(IN)
 1134 FORMAT(' CLOSING FILE ON UNIT NO.',I3,
     1       ' PROCESSING DATE',I11,'    FILE = ',A60)
      JFOPEN(IN)=0
      GO TO 1138
C
 1136 WRITE(KFILDO,1137)KFILIN(IN),NDATE,IOS,NAMIN(IN)
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1             WRITE(IP23,1137)KFILIN(IN),NDATE,IOS,NAMIN(IN)
 1137 FORMAT(/,' ****ERROR CLOSING FILE NO.',I3,
     1         ' PROCESSING DATE',I11,
     2         ' IN RDVECT AT 1137, IOSTAT =',I5,/,
     3         '     ON FILE = ',A60)
      ISTOP=ISTOP+1
      JFOPEN(IN)=0
C
 1138 IF(IN.EQ.NUMIN)THEN
         WRITE(KFILDO,1139)KFILIN(IN),NDATE,NAMIN(IN)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1               WRITE(IP23,1139)KFILIN(IN),NDATE,NAMIN(IN)
 1139    FORMAT(' END OF  DATA ON UNIT NO.',I3,
     1          ' PROCESSING DATE',I11,'    FILE = ',A60)
C            THIS IS THE LAST DATA SET.  NOT NECESSARILY AN ERROR.
C            RETURN.
         IER=137
         GO TO 130
C
      ENDIF
C
      IF(KFILIN(IN).NE.KFILIN(IN+1))THEN
         WRITE(KFILDO,1139)KFILIN(IN),NDATE,NAMIN(IN)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1          WRITE(IP23,1139)KFILIN(IN),NDATE,NAMIN(IN)
C           NEXT DATA SET DOES NOT HAVE THE SAME UNIT NUMBER.
C           RETURN TO LET "IN" BE INCREMENTED.
         IER=137
         GO TO 130
C
      ENDIF
C
      IF(JFOPEN(IN+1).EQ.2)THEN
C           JFOPEN(IN+1) SHOULD BE 2 WHEN
C           KFILIN(IN) = KFILIN(IN+1)
         JFOPEN(IN+1)=1
CINTEL
         CALL CKFILEND(KFILDO,KFILIN(IN+1),NAMIN(IN+1),ISYSEND,
     1                 IFILEND,CONVERTX,IER)
         OPEN(UNIT=KFILIN(IN+1),
     1        FORM='UNFORMATTED',STATUS='OLD',
     2        CONVERT=CONVERTX,IOSTAT=IOS,ERR=1143)
C         OPEN(UNIT=KFILIN(IN+1),
C     1        FORM='UNFORMATTED',STATUS='OLD',
C     2        IOSTAT=IOS,ERR=1143)
CINTEL
         IF(IP23.NE.0)WRITE(IP23,1140)KFILIN(IN+1),NDATE,NAMIN(IN+1)
 1140    FORMAT(' OPENING FILE ON UNIT NO.',I3,
     1          ' PROCESSING DATE',I11,'    FILE = ',A60)
C
C           READ DIRECTORY RECORD ON THE NEW FILE.
C
         CALL RDDIR(KFILDO,KFILIN(IN+1),IP12,NAMIN(IN+1),NDATE,
     1              CCALL,INDEXC(1,IN+1),ND1,NSTA,CCALLD,ND5,MSTA,
     2              L3264B,L3264W,IER)
C
C           SINCE THE FILE WAS SWITCHED, MUST RETURN FOR IN
C           TO BE INCREMENTED.  IER = 146 WILL SIGNAL AN EOF
C           AND NO DATA.
C
         IF(IER.NE.0)THEN
            ISTOP=ISTOP+1
C
            IF(IER.EQ.146)THEN
               JFOPEN(IN+1)=0
               IF(IP23.NE.0)WRITE(IP23,1141)KFILIN(IN+1),
     1                      NDATE,NAMIN(IN+1)
 1141          FORMAT(/,' END OF  FILE ON UNIT NO.',I3,
     1                  ' PROCESSING DATE',I11,'    FILE = ',A60)
            ELSEIF(IER.NE.120)THEN
               JFOPEN(IN+1)=0
            ENDIF
C
         ENDIF
C
         DO 1142 K=1,NSTA
         XDATA(K)=9999.
 1142    CONTINUE
C
         IER=146
C           ANY RETURN FROM RDDIR MUST BE TREATED IN THE
C           CALLING PROGRAM AS AN EOF = 146.  THE NEW FILE
C           HAS BEEN OPENED IF POSSIBLE, AND THE DATA SET
C           TO MISSING.
         IF(KFILIN(IN).EQ.KFILIN(IN+1))THEN
            IWITCH(IN+1)=0
         ENDIF
C           THIS SHOULD KEEP DIAGNOSTIC AT 1156 FROM PRINTING UNNECESSARILY
C           ON THE NEXT ENTRY.  THAT IS, A SWITCH IS MADE STILL LOOKING
C           FOR A DATE/TIME.  RDVECT WILL BE ENTERED AGAIN LOOKING
C           FOR THE SAME DATE TIME AND PROBABLY NOT FIND ANY DATA, WHICH
C           IS EXPECTED.
         GO TO 230
C
 1143    WRITE(KFILDO,1144)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1            WRITE(IP23,1144)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
 1144    FORMAT(/,' ****ERROR OPENING FILE ON UNIT NO.',I3,
     1            ' PROCESSING DATE',I11,
     2            'IN RDVECT AT 1144, IOSTAT =',I5,/,
     3            '     ON FILE = ',A60)
         JFOPEN(IN+1)=0
         IER=31
      ELSE
         WRITE(KFILDO,1145)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1          WRITE(IP23,1145)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
 1145    FORMAT(/,' ****TROUBLE IN SWITCHING TO FILE ON UNIT NO.',
     1            I3,' PROCESSING DATE',I11,
     2            ' IN RDVECT AT 1145, IOSTAT =',I5,/,
     3            '     ON FILE = ',A60)
         ISTOP=ISTOP+1
         JFOPEN(IN+1)=0
         IER=31
      ENDIF
C
      GO TO 130
C
 115  IF(IDATE.LT.NDATE)THEN
C***D        WRITE(KFILDO,1151)IDATE,NDATE,IER
C***D1151    FORMAT(' AT 1151 IN RDVECT--IDATE,NDATE,IER',3I12)
         GO TO 110
C           THE ABOVE SPACES UP TO THE DAY WANTED.  FOR VECTOR
C           TYPE PROGRAMS, DATA FOR PAST DAYS WILL NOT BE 
C           NEEDED.
C
      ELSEIF(IDATE.GT.LDATE)THEN
         BACKSPACE KFILIN(IN)
C           THE READ ABOVE HAS GONE BEYOND THE DATE WANTED BY 1 RECORD;
C           THEREFORE, THE BACKSPACE.
C***D        WRITE(KFILDO,1153)IDATE,LDATE,MSDATE,NDATE
C***D1153    FORMAT(' RDVECT AT 1153--IDATE,LDATE,MSDATE,NDATE',4I11)
         IF(IP14.NE.0.AND.MSDATE.EQ.0.AND.LDATE.GT.MDATE(IN).
     1          AND.IWITCH(IN).EQ.1)
     2          WRITE(IP14,1156)KFILIN(IN),NDATE,NAMIN(IN)
1156     FORMAT(/,' ****NO DATA FOUND ON UNIT NO.',I3,
     1            ' PROCESSING DATE',I11,' ON FILE = ',A60)
         IF(MSDATE.EQ.0)IPRINT=0
C           IPRINT IS USED TO KEEP A DIAGNOSTIC FROM PRINTING FOR
C           EACH MISSING VARIABLE WHEN THE ENTIRE DAY IS MISSING.
         IF(IWITCH(IN).EQ.0)IWITCH(IN)=1
C           ONLY THE FIRST ENTRY AFTER A SWITCH WILL HAVE 
C           IWITCH( ) = 0.  THE WHOLE PURPOSE OF IWITCH( ) IS
C           TO KEEP 1156 FROM PRINTING IMMEDIATELY AFTER A SWITCH,
C           BECAUSE NORMALLY THE FILE IS SWITCHED AT THE END OF A
C           DATE, BUT RDVECT IS ENTERED AGAIN FOR THAT SAME DATE,
C           SO NOT FINDING DATA IS NORMAL.
         IER=137
         GO TO 130
C
      ENDIF
C
C        THIS IS A DATE/TIME TO USE FOR THIS MODEL FOR THIS DAY.
C        DOES IT HAVE THE NEEDED ID'S?  NOTE THAT IS1(9-11) =
C        IPACK(6-8) ON A 32-BIT MACHINE.  ON A 64-BIT MACHINE,
C        THE 3 ID'S HAVE TO BE UNPACKED.
C
      MSDATE=1
C        MSDATE( ) = 1 INDICATES SOME DATA WERE AVAILABLE ON THIS FILE
C        FOR THIS DATE.
      IWITCH(IN)=1
C        IWITCH( ) = 1 INDICATES SOME DATA HAVE BEEN FOUND FOR THIS DATE
C        FOR THIS UNIT NUMBER AND IS RETAINED IN RDVECT.
C
      IF(L3264B.EQ.32)THEN
         IPA6=IPACK(6)
         IPA7=IPACK(7)
         IPA8=IPACK(8)
         IPA9=IPACK(9)
C
      ELSE
         LOC=3
         IPOS=33
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA6,32,L3264B,IER,*117)
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA7,32,L3264B,IER,*117)
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA8,32,L3264B,IER,*117)
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA9,32,L3264B,IER,*117)
      ENDIF
C
C***D     WRITE(KFILDO,1161)IPA6,IPA7,IPA8,IPA9,IDATE
C***D1161 FORMAT(' READ VARIABLE IN RDVECT ',4I11,I12)
C
      DO 1167 M=1,MITEMS
C        THE INDEX IN THIS LOOP IS M.  LATER, N REFERS TO A PARTICULAR
C        PREDICTOR.
C***D     WRITE(KFILDO,1165)M,IPA6,IPA7,IPA8,IPA9,IDATE,
C***D    1                  (MSTORE(J,M),J=1,8)
C***D1165 FORMAT(/,' AT 1165 IN RDVECT',I4,4I11,33X,I12,/,
C***D    1      (' ',21X,7I11,I12))
C
      IF(IPA6.NE.MSTORE(1,M).OR.
     1   IPA7.NE.MSTORE(2,M).OR.
     2   IPA9.NE.MSTORE(4,M))GO TO 1167
      IF(IPA8.EQ.MSTORE(3,M).AND.IDATE.EQ.MSTORE(8,M))GO TO 118
C
 1167 CONTINUE             
C
C        THE DATA ARE NOT NEEDED.
      GO TO 110
C
C        THIS IS THE ERROR RETURN FOR UNPKBG ABOVE.  IT MUST BE
C        OUT OF THE IF THEN ELSE LOOPS, OR BE DUPLICATED INSIDE 
C        THEM.
C
 117  WRITE(KFILDO,1170)KFILIN(IN),NDATE,IER
 1170 FORMAT(/,' ****ERROR IN UNPKBG IN RDVECT AT 1170.',
     1         '  INPUT UNIT NO.',I4,' FOR DATE',I11,'.  IER =',I4)
      ISTOP=ISTOP+1
      GO TO 130
C
C        THE DATA ARE NEEDED, SO UNPACK.
C
 118  CONTINUE
C        ABOVE STATEMENT SO THAT D COMPILE OPTION CAN BE USED.
C        THE PRINT IS FOR ONLY THE VARIABLE KEPT.
C
C***D           WRITE(KFILDO,1180)IPA6,IPA7,IPA8,IPA9,M,MSTORE(3,M),
C***D    1                        NDATE,IDATE,MSTORE(8,M)
C***D1180       FORMAT(' RDVECT AT 1180, IPA6        IPA7     ',
C***D    1                             ' IPA8       IPA9      ',
C***D    2                             ' M   MSTORE(3,M)',
C***D    3                             ' NDATE      ',
C***D    4                             ' IDATE      MSTORE(8,M)'/
C***D    5             '             '3(1X,I9),1X,I10,I8,3X,I9,4I12)
C
      CALL UNPACK(KFILDO,IPACK,IWORK,DATA,ND5,
     1            IS0,IS1,IS2,IS4,ND7,MISSP,MISSS,
     2            2,L3264B,IER)
C        THE UNPACKED DATA NOW RESIDE IN DATA( ), UNLESS IER NE 0.
C***D     MSTA=IS4(3)
C***C        MSTA IS THE NUMBER OF STATIONS IN THE UNPACKED RECORD.
C***D     IF(IER.EQ.0)WRITE(KFILDO,1298)IPA6,IPA7,IPA8,IPA9,IDATE
C***D1298 FORMAT(/,' DATA AS READ  ',3(1X,I9.9),1X,I10.3,
C***D    1         '    FOR DATE',I13)
C***D     IF(IER.EQ.0)WRITE(KFILDO,1299)(DATA(J),J=1,MSTA)
C***D1299 FORMAT((' ',F10.2))
C
 130  IF(IER.EQ.0)THEN
C
         DO 135 K=1,NSTA
         IF(INDEXC(K,IN).EQ.99999999)THEN
            XDATA(K)=9999.
         ELSE
            XDATA(K)=DATA(INDEXC(K,IN))
            IF(XDATA(K).EQ.9997.)XDATA(K)=PXMISS
         ENDIF
 135     CONTINUE
C
      ELSE
C
         DO 136 K=1,NSTA
         XDATA(K)=9999.
 136     CONTINUE
C
      ENDIF
C
C***D     WRITE(KFILDO,137)M,IN,KFILIN(IN),IDATE,NDATE,
C***D    1      MSDATE,MDATE(IN),IPRINT,IER
C***D137  FORMAT(' AT 137 IN RDVECT--M,IN,KFILIN(IN),',
C***D    1       'IDATE,MDATE,MSDATE,MDATE(IN),IPRINT,IER',/,
C***D    2       '       ',9I12)
C
      IF(M.LE.ND9)MSTORE(8,M)=9999
C        M CAN BE 9999, SO CHECK DIMENSION BEFORE STORING.
C        MSTORE(8,M) SET = 9999 SO THAT IN CASE THERE IS AN
C        OVERLAP IN DATES IN INPUT, OR THERE IS A DUPLICATE
C        THE SAME VARIABLE IS NOT USED AGAIN. HOWEVER, THIS
C        DOES NOT KEEP A VARIABLE BEING USED FROM A NEW
C        INPUT IF IT HAS BEEN STORED FROM A PREVIOUS INPUT.
      IF(M.EQ.9999)GO TO 230
C        M WILL BE 9999 WHEN NO DATA ARE AVAILABLE.  NOTE
C        THAT ND9 SHOULD BE LT 9999.
C
      IF(MSTORE(5,M).LT.7777)GO TO 138
C
      CALL GSTORE(KFILDO,KFIL10,IS1(9),IN,LSTORE,ND9,LITEMS,
     1            XDATA,NSTA,1,IS1(8),IS1(8),
     2            CORE,ND10,LASTL,NBLOCK,LASTD,NSTORE,L3264B,IER)
C        THIS VARIABLE IS STORED AND WILL BE USED LATER.
C        IS1(9) IS THE FIRST OF 4 ID WORDS.  NOTE THAT THE VALUE OF
C        "IN" IS PROVIDED TO BE STORED IN LSTORE(10, ) TO INDICATE
C        FOR FUTURE ROUTINES THE SOURCE OF THE DATA.  LDATE IS 
C        THE LAST DATE/TIME THAT THIS VARIABLE WILL BE NEEDED.
C        IT IS CALCULATED AT THE BEGINNING OF THE ROUTINE.  THE
C        DATE OF THE DATA IS IN IS1(8), AND THE LAST DATE FOR WHICH
C        THE DATA ARE NEEDED IS ALSO THAT DATE.
      IF(IER.NE.0)ISTOP=ISTOP+1
C        THIS VARIABLE HAS BEEN STORED, UNLESS IER NE 0.  NOTE
C        THAT NOT BEING STORED CORRECTLY DOES NOT HALT PROCESSING.
C        IF IER NE 0, A DIAGNOSTIC WILL HAVE BEEN PRINTED IN GSTORE.
C
      IF(MSTORE(5,M).EQ.7777)GO TO 110
C
C        ANY VARIABLES READ THAT MUST BE STORED BY GSTORE HAVE
C        BEEN STORED.  IF THE VARIABLE IS ALSO NEEDED FOR 
C        USE NOW, RETURN IS MADE.  NOTE THAT MSTORE(5, ) IS BASED
C        ON THE PATTERN OF DATES AND DATA AVAILABLE ON DAY 1.
C        IF THIS CHANGES, A VARIABLE MAY BE STORED AND USED
C        LATER THAT COULD HAVE BEEN USED WHEN READ.  THAT IS,
C        IF THERE ARE MISSING DATES IN THE LIST, A VARIABLE
C        MAY BE STORED ONLY AND NOT IMMEDIATELY USED.  HOWEVER,
C        THIS IS NO WORSE THAN HAD THE DATA BEEN AVAILABLE.
C
 138  N=MOD(MSTORE(5,M),7777)
C
C        DETERMINE ISTAB.
C
      IF(MSTORE(1,M).EQ.ID(1,N))THEN
C
         IF(IDPARS(3,N).EQ.0)THEN
            ISTAB=0
         ELSE
            ISTAB=1
         ENDIF
C
      ELSE
         ISTAB=0
      ENDIF
C
C***D     WRITE(KFILDO,139)M,N,MSTORE(1,M),ID(1,N),IDPARS(3,N),ISTAB,
C***D    1                 IER
C***D139  FORMAT(/,' AT 139 IN RDVECT,',
C***D    1                'M,N,MSTORE(1,M),ID(1,N),IDPARS(3,N),ISTAB',
C***D    2                'IER',2I4,2I11.9,3I4)
C
C        N IS THE NUMBER OF THE FIRST PREDICTOR NEEDING THIS VARIABLE.
C        DETERMINE WHETHER OR NOT THE VARIABLE CAN BE USED FOR THE NEXT
C        VARIABLE.  IF SO, SAVE IT IN SDATA( ).
C
      IF(N.EQ.NVRBL)GO TO 230
C        NO REASON TO SAVE THE LAST VARIABLE.
      IF(IER.NE.0)GO TO 230
C        MISSING DATA ARE NOT SAVED.
      IF(ISTAB.EQ.1)GO TO 230
C        DON'T SAVE A BINARY VARIABLE.
      IF(NWHERE(N+1).NE.2)GO TO 230
C        DON'T SAVE UNLESS THE NEXT VARIABLE CAN BE COMPUTED.
C        WHEN THE ABOVE TEST IS MET, THE NEXT VARIABLE WILL NOT COME
C        FROM A SAVED VARIABLE.  THE BELOW TESTS MAY NOT BE NECESSARY,
C        BUT ARE EXECUTED, IN ANY CASE, ONLY WHEN A VARIABLE IS
C        (MAY BE) REUSED.  NOTE THAT A VARIABLE IS NOT TESTED
C        FOR SAVING WHEN MSTORE(5, ) = 7777.
      IF(IDPARS(1,N).GE.400.AND.IDPARS(1,N).LE.499)GO TO 230 
C        CONSTANTS ARE NOT SAVED.  THIS IS BECAUSE RELATIVE
C        FREQUENCIES HAVE A THRESHOLD BUT B = 0.  THE THRESHOLD
C        IS NOT PART OF THE SAVE PROCESS, AND THE SAME
C        RELATIVE FREQUENCY MAY BE USED MORE THAN ONCE WHEN
C        A DIFFERENT ONE IS NEEDED.  THIS IS A SAFETY FEATURE;
C        NWHERE( ) SHOULD KEEP CONTROL OUT OF THE ABOVE TEST.       
      IF(IDPARS(1,N)/100.EQ.9)GO TO 230 
C        STRATIFICATION VARIABLES ARE NOT SAVED.
C
      IF(JD(1,N).NE.JD(1,N+1).OR.
     1   ID(2,N).NE.ID(2,N+1).OR.
     2   ID(3,N).NE.ID(3,N+1).OR.
     3   IDPARS(3,N+1).GE.5.OR.
     4   IDPARS(13,N).NE.IDPARS(13,N+1).OR.
     5   IDPARS(14,N).NE.IDPARS(14,N+1))GO TO 230
C        NOTE THAT IDPARS(3, ) GE 5 DENOTES A GRID BINARY.
C        A GRID BINARY AND A POINT BINARY CANNOT BE USED TOGETHER.
C        A GRID BINARY WOULD NEVER BE ABLE TO BE A RESTORED VARIABLE.
C        ALLOWED TO BE SAVED, THEN, IS ONLY A NON-BINARY VARIABLE WHEN
C        THE FOLLOWING ONE IS NOT A GRID BINARY.
C
      LD(1)=JD(1,N)
      LD(2)=ID(2,N)
      LD(3)=ID(3,N)
      LD(4)=IDPARS(3,N)
      LD(5)=IDPARS(13,N)
      LD(6)=IDPARS(14,N)
      LD(7)=IDATE
C
      DO 140 K=1,NSTA
      SDATA(K)=XDATA(K)
 140  CONTINUE
C
D     WRITE(KFILDO,142)N,(LD(J),J=1,7)
D142  FORMAT(/,' SAVING DATA FOR VARIABLE NO.',I7,' IN RDVECT   ',
D    1        3(1X,I9.9),3I4,I11)
C
C        AT THIS POINT, THE VARIABLE EXISTS IN DATA( ).  THE FULL
C        IDENTIFICATION OF THE VARIABLE IS IN IS1( ), IS2( ), AND IS4( ).
C        IF IT MAY BE NEEDED FOR THE NEXT VARIABLE, THE VARIABLE IS ALSO 
C        IN SDATA( ).
 230  CONTINUE
C
D     CALL TIMPR(KFILDO,KFILDO,'LEAVING   RDVECT    ')
      RETURN
      END
