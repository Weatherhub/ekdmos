      SUBROUTINE PRU660(KFILDO,IP16,CCALL,NSTA,NGP,KGP,JP,NDATE,
     1                  LNGTH,ICHARS,IWDTH,WDTH,IPREC,PREC,CFMT,HEAD,
     2                  AA,PRINT,NVRBL,ISTOP,IER)
C
C        DECEMBER  1997   GLAHN   TDL   MOS-2000
C        APRIL     1998   GLAHN   CHANGED NVRBL TO IEND IN DO 1086
C        SEPTEMBER 1998   GLAHN   PRINT CONCERNING JP(1, ) CHANGED
C        OCTOBER   1998   GLAHN   CHANGED SDATA( ) TO PRINT( )
C        JUNE      1999   GLAHN   CORRECTED ERROR; IAST=IEND+1 AT 1089
C        JUNE      1999   GLAHN   CHANGED COMMENT FOR JP(1, )
C        AUGUST    1999   GLAHN   REMOVED IFIRST SO IT CAN BE USED
C                                 WITH U910 WHICH DOESN'T ENTER WITH
C                                 THE SAME VARIABLES EACH TIME
C        SEPTEMBER 1999   GLAHN   ADDED AUTOMATIC ARRAYS
C        JANUARY   2000   GLAHN   CORRECTED SPELLING IN COMMENTS
C        FEBRUARY  2000   GLAHN   ADDED TEST TO NOT PRINT WHEN IP16=0
C        APRIL     2000   DALLAVALLE   MODIFIED FORMAT STATEMENTS TO
C                                      CONFORM TO FORTRAN 90 STANDARDS
C                                      ON THE IBM SP
C        FEBRUARY  2001   MALONEY EDITED PRFMT, HDFMT, IFC, AND IFD
C                                 SO ALL FORMAT STATEMENT CONFORM TO
C                                 FORTRAN 90 STANDARDS ON THE IBM SP;
C                                 ADDED VARIABLES IFCORG AND IFDORG 
C                                 IN LIEU OF THE HARDCODED RESETS
C                                 OF IFC AND IFD BETWEEN 1089 AND 109 
C        PURPOSE
C            PRU660 PRINTS THE DATA FOR U660
C   
C        DATA SET USE
C            KFILDO    - UNIT NUMBER OF OUTPUT (PRINT) FILE.  SET BY
C                        DATA STATEMENT.  (OUTPUT)
C            KFILIO    - UNIT NUMBER OF OUTPUT TDLPACK FILE.  (OUTPUT)
C             IP16     - UNIT NUMBERS FOR OPTIONAL OUTPUT FOR PRINTING.  
C                        (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C                IP16 = INDICATES WHETHER (>0) OR NOT (=0) THE DATA
C                       WILL BE WRITTEN TO UNIT IP16 WHEN JP(2, ) >0.
C                       THIS PRINT IS UNDER CONTROL OF THE FORMAT
C                       PROVIDED WITH EACH VARIABLE.  (INPUT)
C            CCALL(K) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR.  (CHARACTER*8)  (INPUT)
C                NSTA = THE NUMBER OF STATIONS BEING DEALT WITH.  THE
C                       NUMBER OF VALUES IN CCALL( , ), ETC.  (INPUT)
C              NGP(J) = THE NUMBER OF STATIONS IN EACH GROUP (J=1,KGP).
C                       (INPUT)
C                 KGP = THE NUMBER OF STATIONS OR GROUPS TO BE PROCESSED.
C                       FOR SINGLE STATION EQUATIONS, THIS IS THE NUMBER 
C                       OF STATIONS.  MAXIMUM OF ND1.  (INPUT)
C             JP(J,N) = CONTROLS THE OUTPUT BY VARIABLE (N=1,ND4).
C                       J=1--INDICATES WHETHER (>0) OR NOT (=0) VARIABLE N
C                            WILL BE WRITTEN TO THE BINARY OUTPUT;
C                       J=2--INDICATES WHETHER (>0) OR NOT (=0) VARIABLE N
C                            WILL BE WRITTEN TO UNIT IP(16) WITH THE FORMAT 
C                            PROVIDED WITH THE VARIABLE; AND 
C                       J=3--INDICATES WHETHER (>0) OR NOT (=0) VARIABLE N
C                            WILL BE WRITTEN TO UNIT IP(15) NOT UNDER
C                            CONTROL OF THE FORMAT PROVIDED BUT TO THE
C                            RESOLUTION PACKED.
C                       ONLY JP(2, ) IS USED IN PRU660.  (INPUT)
C               NDATE = THE DATE OF THE DATA TO PRINT.  (INPUT)
C               LNGTH = LINE LENGTH FOR PRINTING TO IP16.  (INPUT)
C              ICHARS = NUMBER OF CHARACTERS FOR CALL LETTERS IN 
C                       PRINTING, BETWEEN 4 AND OF 8.  (INPUT)
C            IWDTH(J) = WIDTH OF FIELD FOR PRINTING (J=1,NVRBL). (INPUT)
C             WDTH(J) = WIDTH OF FIELD FOR PRINTING (J=1,NVRBL).  THIS
C                       THE CHARACTER EQUIVALENT OF (INTERNAL/OUTPUT)
C            IPREC(J) = PRECISION FOR PRINTING (J=1,NVRBL).  THIS IS THE
C                       NUMBER OF PLACES AFTER THE DECIMAL POINT.  
C                       (INPUT)
C             PREC(J) = CHARACTER REPRESENTATION OF IPREC(J) (J=1,ICOUNT).
C                       (INTERNAL/OUTPUT)
C             CFMT(J) = FORMAT FOR PRINTING, EITHER I OR F (J=1,NVRBL).
C                       (CHARACTER*1)  (INPUT)
C          HEAD(30,N) = HEADING FOR COLUMNS WHEN PRINTING DATA (N=1,NVRBL).
C                       (CHARACTER*1)  (INPUT)
C             AA(N,K) = THE MATRIX OF DATA FOR PRINTING (N=1,NVRBL) 
C                       (K=1,NSTA).  (INPUT)
C            PRINT(K) = WORK ARRAY TO TRANSFER DATA INTO FOR PRINTING
C                       (K=1,NVRBL).  (INTERNAL/OUTPUT)
C               NVRBL = NUMBER OF VARIABLES BEING DEALT WITH.  (INPUT)
C               ISTOP = 0 MEANS THE PROGRAM IS RUNNING OK UP TO THIS
C                       POINT.  WHENEVER AN ERROR OCCURS THAT SHOULD
C                       HALT THE PROGRAM AFTER INPUT DIAGNOSTICS ARE
C                       PRINTED, ISTOP IS SET = ISTOP+1.  (INPUT-OUTPUT)
C                 IER = STATUS RETURN.
C                       0 = GOOD RETURN.
C                       OTHER VALUES CAN COME FROM INTERNAL WRITE.
C                       (OUTPUT)
C                 NDX = SIZE OF HDFMT AND PRFMT.  THIS CAN BE INCREASED
C                       IF NECESSARY, BUT AT 300 SHOULD ACCOMMODATE
C                       ALMOST 50 ELEMENTS PER LINE.  (SET BY PARAMETER)
C               HDFMT = FORMAT FOR PRINTING HEADING.  (CHARACTER*NDX)
C                       (INTERNAL)
C               PRFMT = FORMAT FOR PRINTING DATA.  (CHARACTER*NDX)
C                       (INTERNAL)
C              IFIRST = INITIALLY SET TO 0, AND CONTROLS FLOW WITHIN
C                       THE PROGRAM UPON ENTRY.  REMOVED 9/9/99.
C                       (INTERNAL)
C              ICOUNT = COUNTS THE NUMBER OF VARIABLES TO PRINT.  THIS
C                       IS THE NUMBER OF NONZERO JP(2, ) VALUES.
C                       (INTERNAL)
C              KGPVRB = THE NUMBER OF VARIABLE GROUPS NEEDED.  CALCULATED
C                       INTERNALLY.  WHEN IT IS 1, THE FORMATS DO NOT NEED
C                       TO BE RECALCULATED.  (INTERNAL)
C                 IFC = COUNTS THE CHARACTERS IN THE HEADING FORMAT.
C                       (INTERNAL)
C              IFCORG = ORIGINAL VALUE OF IFC.  USED TO RESET IFC FOR
C                       MULTIPLE BLOCKS OF OUTPUT INSTEAD OF HARDCODED
C                       VALUE. (INTERNAL)
C                 IFD = COUNTS THE CHARACTERS IN THE DATA FORMAT.
C                       (INTERNAL)
C              IFDORG = ORIGINAL VALUE OF IFD.  USED TO RESET IFD FOR
C                       MULTIPLE BLOCKS OF OUTPUT INSTEAD OF HARDCODED
C                       VALUE. (INTERNAL)
C                 IFL = COUNTS THE NUMBER OF CHARACTERS TO BE PRINTED
C                       ON A LINE.  WHEN THE NEXT VARIABLE WOULD MAKE
C                       IFL EXCEED LNGTH, THE DATA FOR STATIONS HAVE TO BE 
C                       PRINTED, AND ANOTHER FORMAT GENERATED FOR THE
C                       NEXT SET OF VARIABLES.  (INTERNAL)
C            IWDTH(J) = WIDTH OF FIELD FOR PRINTING (J=1,NCOUNT).
C                       (AUTOMATIC)
C            CCFMT(J) = FORMAT FOR PRINTING, EITHER I OR F (J=1,NCOUNT).
C                       (CHARACTER*1)  (AUTOMATIC)
C         HHEAD(30,N) = HEADING FOR COLUMNS WHEN PRINTING DATA (N=1,NCOUNT).
C                       (CHARACTER*1)  (AUTOMATIC)
C 
C        NONSYSTEM SUBROUTINES USED 
C            NONE
C
      PARAMETER (NDX=300)
C
      CHARACTER*1 CFMT(NVRBL),PREC(NVRBL),CHARS
      CHARACTER*1 CCFMT(NVRBL)
C        CCFMT( ) IS AN AUTOMATIC ARRAY.
      CHARACTER(LEN=NDX) HDFMT,PRFMT
      CHARACTER*2 WDTH(NVRBL)
      CHARACTER*8 CCALL(NSTA)
      CHARACTER*1 HEAD(30,NVRBL)
      CHARACTER*1 HHEAD(30,NVRBL)
C        HHEAD( , ) IS AN AUTOMATIC ARRAY.
      DIMENSION NGP(NSTA)
      DIMENSION IWDTH(NVRBL),IPREC(NVRBL),PRINT(NVRBL),
     1          JP(3,NVRBL)
      DIMENSION JWDTH(NVRBL)
C        JWDTH( ) IS AN AUTOMATIC ARRAY.
      DIMENSION AA(NVRBL,NSTA)
C
      DATA HDFMT/' '/
      DATA PRFMT/' '/
      DATA CHARS/' '/
C
      IER=0
      ICOUNT=0
      IF(IP16.EQ.0)GO TO 400
C 
C        DETERMINE THE NUMBER OF VARIABLES TO PRINT,
C        IF ANY.
C
      DO 100 N=1,NVRBL
      IF(JP(2,N).NE.0)ICOUNT=ICOUNT+1
 100  CONTINUE
C
      IF(ICOUNT.GT.0)THEN
         WRITE(KFILDO,1000)ICOUNT
 1000    FORMAT(/,' ',I4,' VARIABLES WILL BE WRITTEN FOR PRINTING.')
      ELSE
         WRITE(KFILDO,1001)
 1001    FORMAT(/,' NO VARIABLES WILL BE WRITTEN FOR PRINTING.')
         GO TO 400
      ENDIF
C
C        BLANK OUT HHEAD( , ).
C
      DO 1005 J=1,ICOUNT
      DO 1004 I=1,30
      HHEAD(I,J)=' '
 1004 CONTINUE
 1005 CONTINUE
C
C        PUT INTEGER ICHARS INTO CHARACTER CHARS.
C
      WRITE(CHARS,101)ICHARS
 101  FORMAT(I1.1)
C        CHARS NOW HOLDS ICHARS IN CHARACTER FORM, 2 DIGITS.
D     WRITE(KFILDO,1010)NVRBL,ICHARS,CHARS
D1010 FORMAT(/' NVRBL, ICHARS, CHARS '2I4,10X,A2)
C
C        PUT THE NUMERIC FIELD WIDTHS IN IWDTH( ) INTO
C        CHARACTER FORM IN WDTH( ), BUT ONLY THOSE TO BE
C        USED.  ALSO, DO THE SAME FOR IPREC( ) AND 
C        PREC( ).  CHARACTERS IN HEAD( ) ARE MOVED
C        SO THAT HEAD( ) INCLUDES ONLY THE ONES TO
C        BE PRINTED, RIGHT JUSTIFIED.
C
      J1=0
C
C        PUT INTEGER IWDTH( ) INTO CHARACTER WDTH( )
C        SO THAT THOSE VALUES TO BE USED WILL BE
C        SEQUENTIAL.
C
      DO 106 N=1,NVRBL
      IF(JP(2,N).EQ.0)GO TO 106
      J1=J1+1
      WRITE(WDTH(J1),102,ERR=1025,IOSTAT=IOS)IWDTH(N)
 102  FORMAT(I2.2)
C        WDTH( ) NOW HOLDS THE WIDTH OF EACH COLUMN IN 
C        CHARACTER FORM, 2 DIGITS EACH.
      JWDTH(J1)=IWDTH(N)
C        WIDTHS NOT USED ARE ELIMINATED FOR PRINTING.
      CCFMT(J1)=CFMT(N)
C        FORMATS NOT USED ARE ELIMINATED FOR PRINTING.
      GO TO 1029
C
 1025 WRITE(KFILDO,1026)IOS
 1026 FORMAT(/,'****ERROR WRITING INTERNAL FILE WDTH',
     1         ' AT 1026 IN PRU660, IOSTAT = ',I3)
      STOP 1026
C
C        PUT INTEGER IPREC( ) INTO CHARACTER PREC( )
C        SO THAT THOSE VALUES TO BE USED WILL BE
C        SEQUENTIAL.
C
 1029 WRITE(PREC(J1),103,ERR=1031,IOSTAT=IOS)IPREC(N)
 103  FORMAT(I1.1)
C        PREC( ) NOW HOLDS THE PRECISION (NUMBER OF PLACES
C        AFTER THE DECIMAL POINT FOR "F" FORMATS IN 
C        CHARACTER FORM, 1 DIGIT EACH.
      GO TO 1033
 1031 WRITE(KFILDO,1032)IOS
 1032 FORMAT(/,'****ERROR WRITING INTERNAL FILE PREC',
     1         ' AT 1032 IN PRU660, IOSTAT = ',I3)
      STOP 1032
C
C        MOVE THOSE ELEMENTS OF HEAD( ) TO BE USED
C        TO SEQUENTIAL LOCATIONS IN HHEAD( ).
C
 1033 L1=0
C
      DO 104 L=JWDTH(J1),1,-1
C
      IF(HEAD(L,N).EQ.' ')THEN
         L1=L1+1
      ELSE
C
C***D        WRITE(KFILDO,1034)N,J1,L,JWDTH(J1),L1,HHEAD(1:JWDTH(J1),J1)
C***D1034    FORMAT(/ 'N,J1,L,JWDTH(J1),L1,HHEAD(1:JWDTH(J1),J1)'5I5,30A1)
C
         HHEAD(1+L1:JWDTH(J1),J1)=HEAD(1:JWDTH(J1)-L1,N)
C
         IF(L1.EQ.0)GO TO 106
C
         DO 1035 M=1,L1
         HHEAD(M:M,J1)=' '
 1035    CONTINUE
C
         GO TO 106
C
      ENDIF
C
 104  CONTINUE

 106  CONTINUE
C
D     WRITE(KFILDO,1070)(JWDTH(J),J=1,ICOUNT)
D1070 FORMAT(/,' JWDTH',20I3)
D     WRITE(KFILDO,1071)(WDTH(J),J=1,ICOUNT)
D1071 FORMAT(/,' WDTH ',20(1X,A2))
D     WRITE(KFILDO,1072)(IPREC(J),J=1,NVRBL)
D1072 FORMAT(/,' IPREC',20I3)
D     WRITE(KFILDO,1073)(PREC(J),J=1,ICOUNT)
D1073 FORMAT(/,' PREC',20(A2))
D     WRITE(KFILDO,1074)(HHEAD(1:30,J),J=1,ICOUNT)
D1074 FORMAT(/,' HHEAD',30A1,/('      ',30A1))
C
C        BUILD FORMATS.
C
      KGPVRB=1
C        KBPVRB IS THE NUMBER OF GROUPS OF VARIABLES.
      ISTART=1
C        ISTART REFERENCES VALUES IN HEAD( , ), ETC.
      JSTART=1
C        JSTART REFERENCES VALUES IN JP( , ), ETC.
C
C        START THE FORMAT FOR PRINTING DATA.
C
      PRFMT(1:10)='(1X,I4,1X,'
      PRFMT(11:11)='A'
      PRFMT(12:12)=CHARS
      PRFMT(13:13)=','
      IFD=14
      IFDORG=14
C        IFD IS THE COUNT OF CHARACTERS IN THE DATA FORMAT
C        PLUS 1.  THAT IS, THE ONE TO BE FILLED NEXT.
C        IFDORG WILL CARRY THE ORIGINAL VALUE FOR MULTIPLE
C        BLOCKS OF OUTPUT.
      IFL=6+ICHARS
C        IFL IS THE CHARACTERS IN THE LINE FILLED.
C
C        START THE FORMAT FOR PRINTING THE HEADINGS.
C
      HDFMT(1:16)='(/,"  VARIABLE",'
      NOX=6+ICHARS-10
      WRITE(HDFMT(17:17),1080,ERR=1081,IOSTAT=IOS)NOX
 1080 FORMAT(I1.1)
      GO TO 1083
C 
 1081 WRITE(KFILDO,1082)IOS
 1082 FORMAT(/,'****ERROR WRITING INTERNAL FILE HDFMT',
     1         ' AT 1082 IN PRU660, IOSTAT = ',I3)
      STOP 1082
C        IBM DOES NOT LIKE 0X IN A FORMAT STATEMENT.  HP HAS 
C        NO PROBLEM WITH THIS.  IF NOX IS ZERO, JUST GET
C        RID OF THE X FORMATTER; OTHERWISE, PUT IT IN.
 1083 IF(NOX.EQ.0) THEN
         HDFMT(17:17)=' '
         IFC=17
         IFCORG=17
      ELSE  
         HDFMT(18:19)='X,'
         IFC=20
         IFCORG=20
      ENDIF
C        IFC IS THE COUNT OF CHARACTERS IN THE HEADING FORMAT
C        PLUS 1.  THAT IS, THE ONE TO BE FILLED NEXT.
C        IFCORG WILL CARRY THE ORIGINAL VALUE FOR MULTIPLE
C        BLOCKS OF OUTPUT.
      MSAVE=0
C        MSAVE INITIALIZES M, WHICH COUNTS VALUES IN PRINT( )
C        AND CORRESPONDS TO VALUES IN HEAD( , ).  
C
      DO 160 N=1,ICOUNT 
C
      IF(IFD+6.GT.NDX.OR.
     1   IFC+4.GT.NDX)THEN
C           THE DATA (HEADING) FORMAT REQUIRES 6 (4) CHARACTERS
C           PER ITEM.
         WRITE(KFILDO,1084)NDX
 1084    FORMAT(/,' ****FORMAT FOR PRINTING ABOUT TO BE OVERFLOWED.',
     1           '  INCREASE PARAMETER NDX IN PRU660.',
     2           '  STOP IN PRU600 AT 1084.')
         STOP 1084
      ENDIF
C
      IF(IFL+JWDTH(N).LE.LNGTH)GO TO 109
C
C        MUST PRINT THESE VARIABLES, ISTART TO N-1.
C
      PRFMT(IFD:IFD)=')'
C        ADDED THIS FIX IN FEB 2001 TO ELIMINATE FNN.N,) AT END
C        OF HDFMT.
      HDFMT(IFC-1:IFC)=') '
      IEND=N-1
C
      IF(IEND.LT.ISTART)THEN
         WRITE(KFILDO,1085)
 1085    FORMAT(/,' ****LINE LENGTH NOT LARGE ENOUGH TO PUT THE',
     1           ' NEXT VARIABLE ON THE LINE.  INCREASE LNGTH.',/
     2           '     STOP IN PRU660 AT 1085.')
      STOP 1085
      ENDIF
C
      WRITE(IP16,201)NDATE,KGPVRB
C        THE DATE IS NOT WRITTEN FOR EACH STATION GROUP,
C        BUT IS WRITTEN FOR EACH VARIABLE GROUP.
D     WRITE(IP16,'(A120," 368")')HDFMT(1:IFC)
      WRITE(IP16,HDFMT)(HHEAD(1:JWDTH(J1),J1),J1=ISTART,IEND)
      K=0
C
      DO 1089 L=1,KGP
      IF(L.EQ.1.AND.KGP.GT.1)WRITE(IP16,205)L
C
      DO 1088 LK=1,NGP(L)
      IF(LK.EQ.1.AND.L.NE.1)WRITE(IP16,205)L
      K=K+1
      M=MSAVE
C
      DO 1086 J1=JSTART,NVRBL
C
      IF(JP(2,J1).NE.0)THEN
         M=M+1
C
         IF(CCFMT(M).EQ.'I')THEN
            PRINT(M)=NINT(AA(J1,K))
C              ABOVE STATEMENT ROUNDS FOR INTEGER PRINTING.
         ELSE
            PRINT(M)=AA(J1,K)
         ENDIF
C
D        WRITE(KFILDO,9998)J1,L,KGP,LK,NGP(L),K,M,JSTART,IEND
D9998    FORMAT(' PRU660--J1,L,KGP,LK,NGP(L),K,M,JSTART,IEND',
D    1          10I8)
      IF(M.EQ.IEND)THEN
         J1SAVE=J1+1
         GO TO 1087
      ENDIF
C
      ENDIF
C
 1086 CONTINUE
C
C        GET RID OF EXTRA COMMA ON END OF FORMAT STATEMENT
 1087 PRFMT(IFD-1:IFD)=') ' 
D     WRITE(IP16,'(A120, "406")')PRFMT(1:IFD)
      WRITE(IP16,PRFMT)K,CCALL(K),(PRINT(J1),J1=ISTART,IEND)
C
 1088 CONTINUE
C  
 1089 CONTINUE
C
      JSTART=J1SAVE
      MSAVE=M
      KGPVRB=KGPVRB+1
C        KFPVRB KEEPS COUNT OF NUMBER OF GROUPS OF VARIABLES.
      ISTART=IEND+1
C        
      IFC=IFCORG
      IFD=IFDORG
      IFL=6+ICHARS
C        IFC, IFD, AND IFL ARE RESET, BECAUSE ANOTHER GROUP WILL
C        BE NEEDED AND THE BEGINNING OF EACH LINE IS THE SAME.
C
C        ADD VALUE TO DATA FORMAT.
C
 109  IFL=IFL+JWDTH(N)
      PRFMT(IFD:IFD)=CCFMT(N)
      IFD=IFD+1
      PRFMT(IFD:IFD+1)=WDTH(N)
      IFD=IFD+2
      PRFMT(IFD:IFD)='.'
      IFD=IFD+1
      PRFMT(IFD:IFD)=PREC(N)
      IFD=IFD+1
C        NOTE THAT F AND I FORMATS ARE TREATED THE SAME.
C        FOR F, PREC( ) IS THE NUMBER OF PLACES AFTER THE POINT.
C        FOR I, PREC( ) IS THE NUMBER OF PLACES, INCLUDING 
C        LEADING ZEROS.  THIS WORKS OK FOR I FORMAT, EVEN
C        THOUGH THE DATA BEING PRINTED IS REAL.  HOWEVER,
C        FOR I FORMAT, DATA ARE TRUNCATED, NOT ROUNDED, AND
C        A REAL (TRUNCATED TO) ZERO WILL PRINT AS A BLANK
C        UNLESS THE FORMAT IS IX.0, WHERE X IS THE FIELD
C        WIDTH.
C  
      IF(N.LT.ICOUNT)THEN    
         PRFMT(IFD:IFD)=','
         IFD=IFD+1
      ELSE
         PRFMT(IFD:IFD)=')'
      ENDIF
C
D     WRITE(KFILDO,115)PRFMT(1:IFD-1)
D115  FORMAT(/,' PRINTING FORMAT FOR DATA IN PRU660',/,' ',A120)
C
C        ADD VALUE TO DATA FORMAT.
C
      HDFMT(IFC:IFC+1)=WDTH(N)
      IFC=IFC+2
      HDFMT(IFC:IFC)='A' 
      IFC=IFC+1
      HDFMT(IFC:IFC)='1'
      IFC=IFC+1
C  
      IF(N.LT.ICOUNT)THEN    
         HDFMT(IFC:IFC)=','
         IFC=IFC+1
      ELSE
         HDFMT(IFC:IFC)=')'
      ENDIF
C
 160  CONTINUE
C
      IEND=ICOUNT
D     WRITE(KFILDO,165)HDFMT(1:IFC)
D165  FORMAT(/,' PRINTING FORMAT FOR HEADING IN PRU660',/
D    1       ,' ',A120)
C
      IF(KGPVRB.EQ.1)THEN
         WRITE(IP16,200)NDATE
C           THE DATE IS NOT WRITTEN FOR EACH STATION GROUP,
C           BUT IS WRITTEN FOR EACH VARIABLE GROUP.
 200     FORMAT(/,' DATA FOR',I12)
      ELSE
         WRITE(IP16,201)NDATE,KGPVRB
 201     FORMAT(/,' DATA FOR',I12,'  FOR VARIABLE GROUP',I4)
      ENDIF
C    
      WRITE(IP16,HDFMT)(HHEAD(1:JWDTH(J1),J1),J1=ISTART,IEND)
C
D     WRITE(KFILDO,202)KGP,(NGP(L),L=1,KGP)
D202  FORMAT(/,' KGP,NGP( )',40I3)
      K=0
C
      DO 230 L=1,KGP
      IF(L.EQ.1.AND.KGP.GT.1)WRITE(IP16,205)L
 205  FORMAT(/,' STATION GROUP NO.',I4,/)
C
      DO 229 LK=1,NGP(L)
      IF(LK.EQ.1.AND.L.NE.1)WRITE(IP16,205)L
      K=K+1
      M=MSAVE
C
      DO 225 N=JSTART,NVRBL
C
      IF(JP(2,N).NE.0)THEN
         M=M+1
C
         IF(CCFMT(M).EQ.'I')THEN
            PRINT(M)=NINT(AA(N,K))
C              ABOVE STATEMENT ROUNDS FOR INTEGER PRINTING.
         ELSE
            PRINT(M)=AA(N,K)
         ENDIF
C
D        WRITE(KFILDO,9997)N,L,KGP,LK,NGP(L),K,M,JSTART,IEND
D9997    FORMAT(' PRU660--N,L,KGP,LK,NGP(L),K,M,JSTART,IEND'
D    1           10I8)
      IF(M.EQ.IEND)GO TO 226
C
      ENDIF
C
 225  CONTINUE
C
 226  WRITE(IP16,PRFMT)K,CCALL(K),(PRINT(J1),J1=ISTART,IEND)
C
 229  CONTINUE
C
 230  CONTINUE
C
 400  CONTINUE
      RETURN
      END
