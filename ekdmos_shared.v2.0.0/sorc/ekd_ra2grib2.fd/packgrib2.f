      SUBROUTINE PACKGRIB2(KFILDO,MDATE,CGRIB,LCGRIB,FLD,
     1                     LISTSEC0,LISTSEC1,JLCL,FSCT2,NFSCT2,
     2                     IGDS,IGDSTMPL,IGDSTMPLEN,IDEFLIST,IDEFNUM,
     3                     COORDLIST,NUMCOORD,IPDSNUM,IPDSTMPL,
     4                     IPDSTMPLEN,IDRSNUM,IDRSTMPL,
     5                     IDRSTMPLEN,BMAP,IDMDL,NX,NY,K,J,
     6                     JPACK,JBMAP,ISTOP)
C
C$$$   SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: PACKGRIB2
C   PRGMMR: RUDACK         ORG: W/OST22          DATE: 2004-11-11
C
C ABSTRACT: PLACE A GRIDDED DATA FIELD AND ITS ASSOCIATED METADATA 
C   INTO GRIB2 FORMAT.
C
C        DETAILED DESCRIPTION OF EACH GRIB2 SECTION:
C           THERE ARE EIGHT MANDATORY AND ONE OPTIONAL SECTIONS
C           CONTAINED WITHIN A GRIB2 MESSAGE.  THESE SECTIONS ARE:
C
C              SECTION 0 - THE INDICATOR SECTION
C              SECTION 1 - THE IDENTIFICATION SECTION
C              SECTION 2 - THE LOCAL USE SECTION (OPTIONAL)
C              SECTION 3 - THE GRID DEFINITION SECTION
C              SECTION 4 - THE PRODUCT DEFINITION SECTION
C              SECTION 5 - THE DATA REPRESENTATION SECTION
C              SECTION 6 - THE BIT-MAP SECTION
C              SECTION 7 - THE DATA SECTION
C              SECTION 8 - THE END SECTION
C
C           SECTION 0, THE INDICATOR SECTION, CONTAINS GRIB2
C           DISCIPLINE, EDITION, AND MESSAGE LENGTH INFORMATION.
C
C           SECTION 1, THE IDENTIFICATION SECTION, CONTAINS DATA
C           THAT DESCRIBES CHARACTERISTICS THAT APPLY TO ALL OF THE
C           PROCESSED DATA IN THE GRIB2 MESSAGE.
C
C           SECTION 2, THE LOCAL USE SECTION, CONTAINS SUPPLEMENTAL
C           INFORMATION FOR LOCAL USE BY THE ORIGINATING CENTERS.
C           THIS SECTION IS OPTIONAL; IT DOES NOT NEED TO BE INCLUDED
C           IN THE GRIB2 MESSAGE.
C
C           SECTION 3, THE GRID DEFINITION SECTION, DESCRIBES THE
C           GEOMETRY OF THE VALUES WITHIN A PLANE DESCRIBED BY
C           TWO FIXED COORDINATES.
C
C           SECTION 4, THE PRODUCT DEFINITION SECTION, PROVIDES A
C           DESCRIPTION OF THE DATA PACKED WITHIN SECTION 7.
C
C           SECTION 5, THE DATA REPRESENTATION SECTION, DESCRIBES
C           WHAT METHOD IS USED TO COMPRESS THE DATA IN SECTION 7.
C
C           SECTION 6, THE BIT-MAP SECTION, CONTAINS A BIT-MAP WHICH
C           INDICATES THE PRESENCE OR ABSENCE OF DATA AT EACH GRID
C           POINT.  A BIT-MAP IS ONLY APPLICABLE TO THE SIMPLE
C           AND COMPLEX PACKING METHODS.  A BIT-MAP DOES NOT
C           APPLY TO COMPLEX PACKING WITH SPATIAL DIFFERENCES.
C
C           SECTION 7, THE DATA SECTION, CONTAINS THE PACKED DATA
C           VALUES.
C
C           SECTION 8, THE END SECTION, CONTAINS THE STRING "7777"
C           INDICATING THE END OF THE GRIB2 MESSAGE.
C
C           SECTIONS 3, 4, 5, AND 7 PROVIDE A VARIETY OF TEMPLATES
C           THAT DESCRIBE AND DEFINE THE GRIDDED PRODUCT WITHIN THE 
C           GRIB2 MESSAGE. 
C
C PROGRAM HISTORY LOG:
C   04-11-11  RUDACK
C   05-03-16  MALONEY   ADDED NCEP DOCBLOCK.  ADDED CALLS TO W3TAGE.
C   13-11-15  HUNTEMANN ADDED LOCAL USE/SECTION 2.
C                       ADDED MACHINE ENDIAN CHECK AND CALL TO BSWAP
C                       FOR SMALL ENDIAN MACHINES TO HANDLE EQUIVALENCE.
C
C USAGE:  CALLED BY RDTDLPK
C
C        DATA SET USE:
C        INPUT FILES: - NONE
C        OUTPUT FILES:
C          FORT.KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C
C        VARIABLES
C            KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE. (INPUT)
C          MDATE(J) = INITIAL DATE LIST (J=1,NDATES) WHICH MAY CONTAIN
C                     NEGATIVE VALUES INDICATING A DATE SPAN.
C                     THIS IS MODIFIED IN DATPRO TO CONTAIN THE
C                     COMPLETE DATE LIST WITH THE DATES IN THE SPANS
C                     FILLED IN (J=1,NDATES), WHERE NDATES HAS BEEN
C                     INCREASED IF NECESSARY.  DATES ARE INPUT AS
C                     YYMMDDHH AND MODIFIED TO YYYYMMDDHH.  ZEROS IN
C                     THE INPUT ARE ELIMINATED.  TERMINATOR IS
C                     99999999.  MAXIMUM NUMBER OF DATES IS ND8.  (INPUT)
C          CGRIB(J) = CHARACTER*1 ARRAY THAT CONTAINS THE GRIB2 MESSAGE
C                     (J=1,LCGRIB).  (OUTPUT)
C            LCGRIB = MAXIMUM LENGTH (BYTES) OF CHARACTER ARRAY CGRIB( ).  
C                     (INPUT)
C            FLD(J) = ARRAY CONTAINING THE GRIDPOINT DATA FIELD TO BE 
C                     PACKED INTO GRIB2 FORMAT (J=1,NX*NY). (INPUT)
C       LISTSEC0(J) = CONTAINS INFORMATION NEEDED FOR GRIB INDICATOR 
C                     SECTION 0.  MUST BE DIMENSIONED GREATER THAN OR 
C                     EQUAL TO 2 (J=1,2).  (INPUT)
C       LISTSEC1(J) = CONTAINS INFORMATION NEEDED FOR GRIB IDENTIFICATION 
C                     SECTION 1. MUST BE DIMENSIONED GREATER THAN OR 
C                     EQUAL TO 13 (J=1,13).   (INPUT)
C          FSCT2(J) = CONTAINS THE DATA VALUES TO PACK. (J=1,NFSCT2) (INPUT)
C            NFSCT2 = THE NUMBER OF DATA VALUES IN ARRAY FSCT2().
C     ISECT2TMPL(5) = CONTAINS THE ARRAY OF VALUES FOR SIMPACK. 
C                    (1) = REFERENCE VALUE - IGNORED ON INPUT
C                    (2) = BINARY SCALE FACTOR
C                    (3) = DECIMAL SCALE FACTOR
C                    (4) = NUMBER OF BITS USED TO PACK DATA, IF VALUE IS
C                          > 0 AND  <= 31.
C                          IF THIS INPUT VALUE IS 0 OR OUTSIDE ABOVE RANGE
C                          THEN THE NUM OF BITS IS CALCULATED BASED ON 
C                          GIVEN DATA AND SCALE FACTORS.
C                    (5) = ORIGINAL FIELD TYPE - CURRENTLY IGNORED ON INPUT
C                          DATA VALUES ASSUMED TO BE REALS.
C                  CSEC2 = CHARACTER ARRAY CONTAINING INFORMATION TO BE
C                          ADDED TO SECTION 2
C                 LCSEC2 = NUMBER OF BYTES OF CHARACTER ARRAY CSEC2 TO BE 
C                          ADDED TO SECTION 2
C           IGDS(J) = CONTAINS INFORMATION NEEDED FOR GRIB2 GRID 
C                     DEFINITION SECTION 3.  MUST BE DIMENSION GREATER 
C                     THAN OR EQUAL TO 5 (J=1,5).  (INPUT)
C       IGDSTMPL(J) = CONTAINS THE DATA VALUES FOR THE SPECIFIED GRID 
C                     DEFINITION TEMPLATE (NN=IGDS(5)).  EACH ELEMENT 
C                     OF THIS INTEGER ARRAY CONTAINS AN ENTRY (IN THE 
C                     ORDER SPECIFIED) OF GRID DEFINITION TEMPLATE 3.NN 
C                     (J=1,IGDSTMPLEN).  (INPUT)
C        IGDSTMPLEN = MAXIMUM DIMENSION OF IGDSTMPL( ).  GRID DEFINITION
C                     SECTION OF THE GRIB2 MESSAGE (SECTION 3).  (INPUT)
C       IDEFLIST(J) = (USED IF IGDS(3).NE.0)  THIS ARRAY CONTAINS THE 
C                     NUMBER OF GRIDPOINTS CONTAINED IN EACH ROW 
C                     (OR COLUMN) (J=1,IDEFNUM).  (NOT CURRENTLY USED)
C                     (INTERNAL)
C           IDEFNUM = (USED IF IGDS(3).NE.0) THE NUMBER OF ENTRIES IN 
C                     ARRAY IDEFLIST( ).  I.E., THE NUMBER OF ROWS 
C                     (COLUMNS) FOR WHICH OPTIONAL GRIDPOINTS ARE DEFINED.  
C                     (SET IN PARAMETER STATEMENT IN DRIVER)  (INPUT)
C      COORDLIST(J) = ARRAY CONTAINING FLOATING POINT VALUES INTENDED TO 
C                     DOCUMENT THE VERTICAL DISCRETIZATION ASSOCIATED TO 
C                     THE MODEL DATA ON THE HYBRID COORDINATE VERTICAL 
C                     LEVELS (J=1,NUMCOORD).  (INTERNAL)
C          NUMCOORD = NUMBER OF VALUES IN ARRAY COORDLIST( ).  SET IN
C                     PARAMETER STATEMENT IN DRU135.  (INPUT)
C           IPDSNUM = PRODUCT DEFINITION TEMPLATE NUMBER (SEE CODE TABLE 4.0).  
C                     (INPUT)
C       IPDSTMPL(J) = CONTAINS THE DATA VALUES FOR THE SPECIFIED PRODUCT 
C                     DEFINITION TEMPLATE.  EACH ELEMENT OF THIS INTEGER 
C                     ARRAY CONTAINS AN ENTRY (IN THE ORDER SPECIFIED) OF 
C                     THE PRODUCT DEFINITION TEMPLATE 4.N (J=1,IPDSTMPLEN). 
C                     (INPUT)
C        IPDSTMPLEN = MAXIMUM DIMENSION OF IPDSTMPL( ).  PRODUCT
C                     DEFINITION SECTION OF THE GRIB2 MESSAGE (SECTION 4).
C                     (INPUT)
C           IDRSNUM = DATA REPRESENTATION TEMPLATE NUMBER (SEE CODE TABLE 5.0).
C                     (INPUT)
C       IDRSTMPL(J) = CONTAINS THE DATA VALUES FOR THE SPECIFIED DATA
C                     REPRESENTATION TEMPLATE.  EACH ELEMENT OF THIS INTEGER
C                     ARRAY CONTAINS AN ENTRY (IN THE ORDER SPECIFIED) OF 
C                     DATA REPRESENTATION TEMPLATE 5.N.  NOTE THAT SOME VALUES 
C                     IN THIS TEMPLATE (E.G. REFERENCE VALUES, NUMBER OF BITS, 
C                     ETC...) MAY BE CHANGED BY THE DATA PACKING ALGORITHMS.  
C                     USE THIS TO SPECIFY SCALING FACTORS AND ORDER OF SPATIAL 
C                     DIFFERENCING, IF DESIRED (J=1,IDRSNUM).  (INPUT)
C        IDRSTMPLEN = MAXIMUM DIMENSION OF IDRSTMPL( ).  DATA REPRESENTATION
C                     SECTION OF THE GRIB2 MESSAGE (SECTION 5).  (INPUT)
C           BMAP(J) = LOGICAL*1 ARRAY CONTAINING BITMAP TO BE ADDED (J=1,NX*NY).
C                     (INPUT)
C          IDMDL(J) = FOUR WORD MOS-2000 ID TO BE PROCESSED. (J=1,4)  (INPUT)
C                NX = NUMBER OF DATA POINTS IN THE X-DIRECTION ON THE INPUT GRID.  
C                     (INPUT)
C                NY = NUMBER OF DATA POINTS IN THE Y-DIRECTION ON THE INPUT GRID. 
C                     (INPUT)
C                 K = CURRENT ENTRY NUMBER IN GROUP BEING PROCESSED.
C                     (INPUT)          
C                 J = CURRENT GROUP BEING PROCESSED.  (INPUT)          
C             JPACK = COUNTER THAT TALLYS THE TOTAL NUMBER OF ENTRIES
C                     PACKED FOR A SPECIFIC GROUP OF ENTRIES.  (INPUT)
C             JBMAP = FLAG (=1) INDICATES THAT THE BITMAP SUPPLIED BY THE
C                     USER ON INPUT WILL BE PACKED INTO THE GRIB2 MESSAGE.
C                     (INPUT)
C          ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                     FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER
C                     AN INPUT DATA RECORD IS NOT FOUND.  (INPUT/OUTPUT) 
C             NDPTS = NUMBER OF DATA POINTS TO PACK (NDPTS=NX*NY).  (INTERNAL)
C             IBAMP = BITMAP INDICATOR (SEE CODE TABLE 6.0)  (INTERNAL)
C                        0 -      BITMAP APPLIES AND IS INCLUDED IN SECTION 6.
C                        1 - 253  PREDEFINED BITMAP APPLIES.
C                      254 -      PREVIOUSLY DEFINED BITMAP APPLIES TO THIS FIELD.
C                      255 -      BIT MAP DOES NOT APPLY TO THIS PRODUCT.
C             KPROJ = FOR NON-AVERAGED OR NON-ACCUMULATING VARIABLES 
C                     (E.G., TEMPERATURE), THE FORECAST PROJECTION.  FOR AVERAGED
C                     OR ACCUMULATING VARIABLES (E.G., QPF) THE BEGINNING OF 
C                     THE PROJECTION PERIOD FOR WHICH THE ACCUMULANT APPLIES.
C                     (INTERNAL)
C           KLENGTH = ACTUAL CHARACTER LENGTH OF DATA INPUT FILE INCLUDING ITS
C                     PATH.  (INTERNAL)
C           JSWITCH = FLAG (=1) INDICATES THAT THE BITMAP HAS BEEN MANIPULATED IF
C                     THE USER SUPPLIES A BITMAP WITH A SCANNING MODE OF '64' AND
C                     DESIRES A VALUE OF '80' ON THE GRIB2 FILE.  (INTERNAL)
C              IERR = ERROR MESSAGES RETURNED FROM THE GRIB2 ENCODER.  (INTERNAL)
C
C         (NOTE:  THE LAST SIX SUBROUTINES MENTIONED ARE FROM
C                 NCEP LIBRARIES)
C
C        SUBPROGRAMS CALLED:  UPDAT, GRIBCREATE, SIMPACK, ADDLOCAL, 
C                             ADDGRID, ADDFIELD, GRIBEND, W3TAGE
C          UNIQUE: - NONE
C          LIBRARY:
C          MDLLIB - UPDAT 
C           W3LIB - W3TAGE
C            GRIB - GRIBCREATE, ADDLOCAL, ADDGRID, ADDFIELD, GRIBEND
C
C        EXIT STATES:
C          COND =    0 - SUCCESSFUL RUN
C                  110 - NON-GRIB2 IN GRIBCREATE
C                  120 - GRIB MESSAGE ALREADY EXISTS
C                  130 - SUM OF SECTION BYTES DOES NOT ADD UP TO TOTAL BYTE COUNT
C                  140 - PREVIOUS SECTION NOT 1,2,OR 7
C                  150 - COULD NOT FIND GRID DEFINITION TEMPLATE
C                  210 - GRIB MESSAGE NOT INITIALIZED
C                  220 - GRIB2 MESSAGE ALREADY COMPLETED
C                  230 - SUM OF SECTION BYTES DOES NOT ADD UP TO TOTAL BYTE COUNT
C                  240 - PREVIOUS SECTION NOT 3 OR 7
C                  250 - COULD NOT FIND REQUESTED PRODUCT DEFN TEMPLATE
C                  260 - SECTION 3 NOT PREVIOUSLY DEFINED
C                  270 - UNSUPPORTED DATA REPRESENTATION TEMPLATE
C                  280 - GRIB2 MESSAGE ALREADY COMPLETE
C
C REMARKS:  NONE
C
C ATTRIBUTES:
C   LANGUAGE:  FORTRAN 90 (xlf90 compiler)
C   MACHINE:  IBM SP
C
C$$$
C
      CHARACTER*1 CGRIB(LCGRIB)
      CHARACTER CSEC2(50000)
      CHARACTER CTEMP(4)
      INTEGER*4 ITEMP
      REAL*4 RTEMP
      EQUIVALENCE (ITEMP, CTEMP, RTEMP)
C
      LOGICAL*1 BMAP(NX*NY),JTEMP
C
      DIMENSION LISTSEC0(2),LISTSEC1(13),IGDS(5),
     1          IGDSTMPL(IGDSTMPLEN),IDRSTMPL(IDRSTMPLEN),
     2          IPDSTMPL(IPDSTMPLEN),IDEFLIST(IDEFNUM),IDMDL(4)
      DIMENSION COORDLIST(NUMCOORD),FLD(NX*NY),ISTOP(2)
      DIMENSION FSCT2(NFSCT2),ISCT2TMPL(IDRSTMPLEN)
C
      DATA JSWITCH/0/
C 
      IERR=0
C
      NDPTS=NX*NY
C
C        PARSE THE DATE INTO THE APPROPRIATE COMPONENTS FOR PACKING.
C
      JYEAR=MDATE/1000000
      JMONTH=MDATE/10000-JYEAR*100
      JDAY=MDATE/100-JYEAR*10000-JMONTH*100
      JHOUR=MDATE-JYEAR*1000000-JMONTH*10000-JDAY*100
C
      LISTSEC1(6) = JYEAR    ! YEAR TO WHICH THE DATA APPLIES
      LISTSEC1(7) = JMONTH   ! MONTH TO WHICH THE DATA APPLIES
      LISTSEC1(8) = JDAY     ! DAY TO WHICH THE DATA APPLIES
      LISTSEC1(9) = JHOUR    ! HOUR TO WHICH THE DATA APPLIES
      LISTSEC1(10) = 0       ! MINUTE TO WHICH THE DATA APPLIES
      LISTSEC1(11) = 0       ! SECOND TO WHICH THE DATA APPLIES      
C
C        CHECK THAT THE PROJECTION IN THE MOS-2000 ID WORD IS IDENTICAL
C        TO THE FORECAST TIME ASSIGNED IN THE PRODUCT DEFINITION SECTION 4.
C
      KPROJ=MOD(IDMDL(3),1000)
C
C        IF THE PROCESSING DOES NOT INVOLVE AN AVERAGE OR ACCUMULATION
C        OF A VARIABLE OVER A TIME PERIOD, CHECK THAT THE FORECAST VALUE
C        IN THE MOS-2000 ID WORD IS IDENTICAL TO THE FORECAST TIME ASSIGNED 
C        IN THE PRODUCT DEFINITION SECTION 4.
C
      IF((IPDSNUM.NE.8).AND.(IPDSNUM.NE.9).AND.(IPDSNUM.NE.10)) THEN
C
         IF(KPROJ.NE.IPDSTMPL(9)) THEN
            WRITE(KFILDO,90) K,J,KPROJ,IPDSTMPL(9)
 90         FORMAT(/,' ****THE MOS-2000 ID FORECAST PROJECTION',
     1               ' FOR ENTRY ',I5,' IN MESSAGE',I5,' IS ',I3,'.',
     2               '  THIS DOES',/,4X,' NOT MATCH THE FORECAST',
     3               ' PROJECTION OF ',I3,' PLACED IN THE PRODUCT',
     4               ' DEFINITION DESCRIPTOR.',/,5X,'CONTINUE',
     5               ' PROCESSING.')
            ISTOP(1)=ISTOP(1)+1
         ENDIF
C
      ELSE
C
C           IF PRODUCT DEFINITION TEMPLATE 8,9, OR 10 IS SPECIFIED (AVERAGES
C           OR ACCUMULATIONS), CALCULATE THE FORECAST TIME AND THE OVERALL
C           END OF THE TIME INTERVAL RELATIVE TO THE REFERENCE TIME.
C
C           THE FORECAST TIME IN THIS INSTANCE IS DEFINED AS THE PROJECTION
C           IN HOURS THAT DEFINES THE BEGINNING OF THE PERIOD BEING 
C           PROCESSED.  THIS NUMBER IS DEFINED AS THE DIFFERENCE BETWEEN
C           THE PROJECTION FOUND IN THE THIRD MOS-2000 ID AND "THE NUMBER
C           OF TIME RANGE SPECIFICATIONS DESCRIBING THE TIME INTERVALS USED
C           TO CALCULATE THE FIELD BEING PROCESSED", I.E. 'IPDSTMPL(22)'. 
C
         CALL UPDAT(MDATE,KPROJ,JDATE)
C
         IF(IPDSNUM.EQ.8) THEN
C
C              ASSIGN ENDING OF TIME INTERVAL FOR NON-PROBABALISTIC
C              FORECASTS AT A HORIZONTAL LEVEL OR LAYER.  (TEMPLATE 4.8)
C
C              ASSIGN THE END TIME OF THE OVERALL TIME INTERVAL
C              IN TERMS OF YEAR-MONTH-DAY-HOUR.  THE MINUTE AND
C              SECOND IS SET TO ZERO.
C
            IPDSTMPL(16)=JDATE/1000000
            IPDSTMPL(17)=JDATE/10000-IPDSTMPL(16)*100
            IPDSTMPL(18)=JDATE/100-IPDSTMPL(16)*10000-
     1                             IPDSTMPL(17)*100
            IPDSTMPL(19)=JDATE-IPDSTMPL(16)*1000000-
     1                         IPDSTMPL(17)*10000-IPDSTMPL(18)*100
            IPDSTMPL(20)=0  !MINUTES ARE SET TO ZERO.
            IPDSTMPL(21)=0  !SECONDS ARE SET TO ZERO.
C
         ELSEIF(IPDSNUM.EQ.9) THEN
C
C              ASSIGN ENDING OF TIME INTERVAL FOR PROBABALISTIC FORECASTS AT
C              A HORIZONTAL LEVEL OR LAYER.  (TEMPLATE 4.9)
C
            IPDSTMPL(23)=JDATE/1000000
            IPDSTMPL(24)=JDATE/10000-IPDSTMPL(23)*100
            IPDSTMPL(25)=JDATE/100-IPDSTMPL(23)*10000-
     1                             IPDSTMPL(24)*100
            IPDSTMPL(26)=JDATE-IPDSTMPL(23)*1000000-
     1                         IPDSTMPL(24)*10000-IPDSTMPL(25)*100
            IPDSTMPL(27)=0  !MINUTES ARE SET TO ZERO.
            IPDSTMPL(28)=0  !SECONDS ARE SET TO ZERO.
C
         ELSEIF(IPDSNUM.EQ.10) THEN
C
C              ASSIGN ENDING OF TIME INTERVAL FOR PERCENTILE FORECASTS AT
C              A HORIZONTAL LEVEL OR LAYER.  (TEMPLATE 4.10)
C
            IPDSTMPL(17)=JDATE/1000000
            IPDSTMPL(18)=JDATE/10000-IPDSTMPL(17)*100
            IPDSTMPL(19)=JDATE/100-IPDSTMPL(17)*10000-
     1                             IPDSTMPL(18)*100
            IPDSTMPL(20)=JDATE-IPDSTMPL(17)*1000000-
     1                         IPDSTMPL(18)*10000-IPDSTMPL(19)*100
            IPDSTMPL(21)=0  !MINUTES ARE SET TO ZERO.
            IPDSTMPL(22)=0  !SECONDS ARE SET TO ZERO.
C
         ENDIF         
C
      ENDIF
C
C        BEGIN A NEW GRIB2 MESSAGE (SECTIONS 0 AND 1).  THESE TWO SECTIONS
C        ARE ADDED ONLY TO THE FIRST FIELD IN EACH GRIB2 MESSAGE.  
C
      IF(JPACK.EQ.0) THEN
         CALL GRIBCREATE(CGRIB,LCGRIB,LISTSEC0,LISTSEC1,IERR)
      ENDIF
C     
C        ERROR CHECK.
C
      IF(IERR.EQ.1) THEN        
         WRITE(KFILDO,100) IERR
 100     FORMAT(/,' ****ATTEMPTED TO USE VERSION OTHER THAN GRIB2.',
     1            '  STOP 100 IN PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 100
      ENDIF
C
C        IF PRESENT, ENCODE THE LOCAL USE SECTION IN SECTION 2 USING 
C        THE SIMPLE PACKING METHOD. THE LOCAL USE DATA IS PACKED INTO
C        THE MESSAGE USING THE FOLLOWING FORMAT:
C
C        SECTION 2 OCTET(S)   DESCRIPTION
C        1-4                  TOTAL LENGTH OF SECTION 2
C        5                    SECTION NUMBER (2)
C        6                    SECTION 2 FORMAT VERSION NUMBER
C                             THE CURRENT VERSION IS 1.
C        7-8                  TOTAL NUMBER OF DATA GROUPS IN
C                             THE LOCAL USE SECTION. HERE WE USE 1.
C        9-12                 NUMBER OF VALUES IN FIRST
C                             GROUP OF LOCAL USE DATA
C        13-16                REFERENCE VALUE OF FIRST GROUP OF
C                             DATA 
C        17-18                DECIMAL SCALE FACTOR
C        19                   NUMBER OF BITS TO PACK EACH VALUE
C                             OF THE FIRST GROUP OF DATA WITH
C        20                   TYPE OF DATA IN FIRST GROUP
C                             ("0" = FLOATING POINT, "1" =
C                             INTEGER)
C        21-NN                THE FIRST GROUP OF DATA PACKED
C                             USING THE SIMPLE PACKING METHOD
C
      IF(JLCL.EQ.1) THEN
         ISCT2TMPL(2)=0
         ISCT2TMPL(3)=0
         ISCT2TMPL(4)=0
         ISCT2TMPL(5)=0
C
C        PACK DATA FIELD USING SIMPLE PACK ALGORITHM
C
         CALL SIMPACK(FSCT2,NFSCT2,ISCT2TMPL,CSEC2,LCSEC2) 
C
C        SHIFT PACKED DATA TO APPROPRIATE OCTETS
C
         DO 1006 LL=LCSEC2,1,-1
           CSEC2(LL+15)=CSEC2(LL)
1006     CONTINUE
C
C        ASSIGN APPROPRIATE VALUES TO OCTETS PRIOR TO PACKED DATA
C
C        DENOTE THAT THIS IS MDL-SECTION2 SIMPLE PACK
C
         CSEC2(1) = CHAR(1)
C
C        ADD THE NUMBER OF GROUPS (1)
C
         CSEC2(2) = CHAR(0)
         CSEC2(3) = CHAR(1)
C
C        ADD NUMBER OF VALUES (4 BYTE INTEGER)
C
         ITEMP = NFSCT2
         ISYSEND=0
CINTEL
C        CHECK SYSTEM ENDIANNESS.  IF LITTLE ENDIAN,
C        SWAP THE BYTES IN ITEMP.
         CALL CKSYSEND(KFILDO,'NOPRINT',ISYSEND,IER)
         IF(ISYSEND.EQ.-1) CALL BSWAP(ITEMP)
CINTEL
         CSEC2(4) = CTEMP(1)
         CSEC2(5) = CTEMP(2)
         CSEC2(6) = CTEMP(3)
         CSEC2(7) = CTEMP(4)
C
C        ADD REFVAL (4 BYTE FLOAT)
C
         RTEMP = ISCT2TMPL(1)
CINTEL
C        CHECK SYSTEM ENDIANNESS.  IF LITTLE ENDIAN,
C        SWAP THE BYTES IN RTEMP.
         CALL CKSYSEND(KFILDO,'NOPRINT',ISYSEND,IER)
         IF(ISYSEND.EQ.-1.AND.RTEMP.NE.0) CALL BSWAP(RTEMP)
CINTEL
         CSEC2(8) = CTEMP(1)
         CSEC2(9) = CTEMP(2)
         CSEC2(10) = CTEMP(3)
         CSEC2(11) = CTEMP(4)
C
C        ADD SCALE (2 BYTE INTEGER) (0)
C
         CSEC2(12) = CHAR(0)
         CSEC2(13) = CHAR(0)
C
C        ADD NUMBER OF BITS (1 BYTE INTEGER)
C
         CSEC2(14) = CHAR(ISCT2TMPL(4))
C
C        ADD DATA TYPE (1 BYTE INTEGER) (0 = FLOAT, 1 = INTEGER)
C
         CSEC2(15) = CHAR(1)
C
         LCSEC2=LCSEC2+15
C
C        ADD LOCAL USE SECTION TO GRIB2 MESSAGE
C
         IF(JPACK.EQ.0) THEN
            CALL ADDLOCAL(CGRIB,LCGRIB,CSEC2,LCSEC2,IERR)
         ENDIF
C     
C        ERROR CHECKS.
C
         IF(IERR.EQ.1) THEN   
            WRITE(KFILDO,101) IERR
 101        FORMAT(/,' ****GRIB2 MESSAGE WAS NOT INITIALIZED.  NEED TO',
     1               ' CALL ROUTINE GRIBCREATE FIRST.',/,5X,'STOP ', 
     2               ' 101 IN PACKGRIB2.  IERR = ',I2)
            STOP 101
         ELSEIF(IERR.EQ.2) THEN
            WRITE(KFILDO,102) IERR
 102        FORMAT(/,' ****GRIB2 MESSAGE ALREADY COMPLETE.  CANNOT ADD',
     1               ' NEW SECTION.',/,5X,'STOP 102 IN PACKGRIB2.',
     2               '  IERR = ',I2)
            STOP 102
         ELSEIF(IERR.EQ.3) THEN
            WRITE(KFILDO,103) IERR
 103        FORMAT(/,' ****SUM OF SECTION BYTE COUNTS DOES NOT ADD TO',
     1               ' TOTAL BYTE COUNT.',/,5X,'STOP 103 IN',
     2               ' PACKGRIB2.  IERR = ',I2)
            STOP 103
         ELSEIF(IERR.EQ.4) THEN
            WRITE(KFILDO,104) IERR
 104        FORMAT(/,' ****PREVIOUS SECTION WAS NOT 1, 2 OR 7.',
     1               '  STOP 104 IN PACKGRIB2.  IERR = ',I2)
            STOP 104
         ENDIF
      ENDIF
C
C         ENCODE THE GRID DEFINITION INTO SECTION 3.  THIS SECTION
C         IS ADDED ONLY TO THE FIRST FIELD IN EACH GRIB2 MESSAGE.
C     
       IF(JPACK.EQ.0) THEN
         CALL ADDGRID(CGRIB,LCGRIB,IGDS,IGDSTMPL,IGDSTMPLEN,
     1                IDEFLIST,IDEFNUM,IERR) 
       ENDIF
C
C        ERROR CHECKS.
C
      IF(IERR.EQ.1) THEN   
         WRITE(KFILDO,110) IERR
 110     FORMAT(/,' ****GRIB2 MESSAGE WAS NOT INITIALIZED.  NEED TO',
     1            ' CALL ROUTINE GRIBCREATE FIRST.',/,5X,'STOP 110 IN', 
     2            ' PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 110
      ELSEIF(IERR.EQ.2) THEN
         WRITE(KFILDO,120) IERR
 120     FORMAT(/,' ****GRIB2 MESSAGE ALREADY COMPLETE.  CANNOT ADD',
     1            ' NEW SECTION.',/,5X,'STOP 120 IN PACKGRIB2.',
     2            '  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 120
      ELSEIF(IERR.EQ.3) THEN
         WRITE(KFILDO,130) IERR
 130     FORMAT(/,' ****SUM OF SECTION BYTE COUNTS DOES NOT ADD TO',
     1            ' TOTAL BYTE COUNT.',/,5X,'STOP 130 IN',
     2            ' PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 130
      ELSEIF(IERR.EQ.4) THEN
         WRITE(KFILDO,140) IERR
 140     FORMAT(/,' ****PREVIOUS SECTION WAS NOT 1, 2 OR 7.',
     1            '  STOP 140 IN PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 140
      ELSEIF(IERR.EQ.5) THEN
         WRITE(KFILDO,150) IERR
 150     FORMAT(/,' ****COULD NOT FIND REQUESTED GRID DEFINITION',
     1            ' TEMPLATE.  STOP 150 IN PACKGRIB2.',
     2            '  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 150
      ENDIF
C
C        IF AN EXTERNAL TDLPACK BITMAP GRIDDED RANDOM ACCESS 
C        FILE HAS BEEN DEFINED IN THE CONTROL FILE AND THE 
C        USER HAS INDICATED THAT THE BITMAP SHOULD BE PACKED 
C        INTO THE GRIB2 MESSAGE, SET THE BITMAP INDICATOR
C        ('IBMAP') TO EITHER 0 OR 254.  IF A BITMAP IS NOT
C        TO BE PACKED 'IBMAP' IS SET TO 255.
C
C        IF 'JPACK = 0', THIS MEANS  THE FIRST ENTRY IN THE 
C        GROUP WILL BE PROCESSED.  THEREFORE, 'IBMAP' IS SET
C        TO A VALUE OF ZERO.  'IBMAP' FOR ALL SUBSEQUENT 
C        PROCESSING FOR THIS GROUP IS SET TO A VALUE OF 254 
C        (I.E., PREVIOUSLY DEFINED BITMAP APPLIES TO THIS FIELD.)
C
      IF(JBMAP.EQ.1) THEN
C
         IF(JPACK.EQ.0) THEN
            IBMAP=0
         ELSE
            IBMAP=254
         ENDIF
C
      ELSE
C
C           A BITMAP DOES NOT APPLY TO THIS PRODUCT.
C
         IBMAP=255
C
      ENDIF
C
C        CHECK THE SCANNING MODE VALUE STIPULATED IN 
C        THE SECTION 3 INPUT FILE.  IF THE SCANNING
C        MODE OF THE DATA IS TO BE PACKED INTO GRIB2 
C        BOUSTROPHEDONICALLY, (BEGINNING AT THE LOWER 
C        LEFT PORTION OF THE GRID MOVING RIGHT TO LEFT),
C        RESTRUCTURE THE DATA FIELD TO A SCANNING MODE
C        OF 80.
C
      IF((((IGDS(5).EQ.20).OR.(IGDS(5).EQ.30)).AND.
     1     (IGDSTMPL(18).EQ.80)).OR.
     2   ((IGDS(5).EQ.10).AND.(IGDSTMPL(16).EQ.80))) THEN
C
         DO 175 IY=1,NY
            IF(MOD(IY,2).EQ.0) THEN
               DO 170 IX=1,NX/2
                  TEMP=FLD((IY-1)*NX+IX)
                  FLD((IY-1)*NX+IX)=FLD(IY*NX-IX+1)
                  FLD(IY*NX-IX+1)=TEMP
 170           CONTINUE
            ENDIF
 175     CONTINUE 
C
C           IF A BITMAP IS SUPPLIED BY THE USER, AND THE
C           BITMAP IS TO BE PACKED INTO THE GRIB2 MESSAGE, 
C           RESTRUCTURE THE BITMAP VALUES TO A SCANNING 
C           MODE OF 80. 
C
         IF((JBMAP.EQ.1).AND.(JSWITCH.EQ.0)) THEN
C
            DO 185 IY=1,NY
               IF(MOD(IY,2).EQ.0) THEN
                  DO 180 IX=1,NX/2
                     JTEMP=BMAP((IY-1)*NX+IX)
                     BMAP((IY-1)*NX+IX)=BMAP(IY*NX-IX+1)
                     BMAP(IY*NX-IX+1)=JTEMP
 180              CONTINUE
               ENDIF
 185        CONTINUE
C
            JSWITCH=1 
C
         ENDIF
C
      ENDIF
C
C        ADD THE PRODUCT DEFINITION SECTION 4, DATA REPRESENTATION 
C        SECTION 5 AND THE DATA FIELD TO THE GRIB2 MESSAGE.
C        (SECTIONS 4,5,6 AND 7)
C
      CALL ADDFIELD(CGRIB,LCGRIB,IPDSNUM,IPDSTMPL,IPDSTMPLEN,
     1              COORDLIST,NUMCOORD,IDRSNUM,IDRSTMPL,
     2              IDRSTMPLEN,FLD,NDPTS,IBMAP,BMAP,IERR) 
C
C        ERROR CHECKS.
C
      IF(IERR.EQ.1) THEN
         WRITE(KFILDO,210) IERR
 210     FORMAT(/,' ****GRIB2 MESSAGE WAS NOT INITIALIZED.  NEED TO',
     1            ' CALL ROUTINE GRIBCREATE FIRST.',/,5X,'STOP 210 IN',
     2            ' PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 210
      ELSEIF(IERR.EQ.2) THEN
         WRITE(KFILDO,220) IERR
 220     FORMAT(/,' ****GRIB2 MESSAGE ALREADY COMPLETE.  CANNOT ADD',
     1            ' NEW SECTION.',/,5X,'STOP 220 IN PACKGRIB2.',
     2            '  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 220
      ELSEIF(IERR.EQ.3) THEN
         WRITE(KFILDO,230) IERR
 230     FORMAT(/,' ****SUM OF SECTION BYTE COUNTS DOES NOT ADD TO',
     1            ' TOTAL BYTE COUNT.',/,5X,'STOP 230 IN',
     2            ' PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 230
      ELSEIF(IERR.EQ.4) THEN
         WRITE(KFILDO,240) IERR
 240     FORMAT(/,' ****PREVIOUS SECTION WAS NOT 3 OR 7.',
     1            '  STOP 240 IN PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 240
      ELSEIF(IERR.EQ.5) THEN
         WRITE(KFILDO,250) IERR
 250     FORMAT(/,' ****COULD NOT FIND REQUESTED PRODUCT DEFINITION',
     1            ' TEMPLATE.  STOP 250 IN PACKGRIB2.',
     2            '  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 250
      ELSEIF(IERR.EQ.6) THEN
         WRITE(KFILDO,260) IERR
 260     FORMAT(/,' ****SECTION 3 (GDS) NOT PREVIOUSLY DEFINED',
     1            ' IN MESSAGE.  STOP 260 IN PACKGRIB2.',
     2            '  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 260
      ELSEIF(IERR.EQ.7) THEN
         WRITE(KFILDO,270) IERR
 270     FORMAT(/,' ****ATTEMPTED TO USE AN UNSUPPORTED DATA',
     1            ' REPRESENTATION TEMPLATE.',/,5X,'STOP 270 IN',
     2            ' PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 270
      ELSEIF(IERR.EQ.8) THEN
         WRITE(KFILDO,280) IERR
 280     FORMAT(/,' ****SPECIFIED USE OF A PREVIOUSLY DEFINED BITMAP,',
     1            ' BUT ONE DOES NOT EXIST IN THE GRIB2 MESSAGE.',/,5X,
     2            'STOP 280 IN PACKGRIB2.  IERR = ',I2)
         CALL W3TAGE('PACKGRIB2')
         STOP 280
      ENDIF
C
      RETURN 
      END
