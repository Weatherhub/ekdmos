      SUBROUTINE PRED23(KFILDO,KFIL10,KFILIO,KFILGO,NFIRST,
     1                  ID,IDPARS,THRESH,JD,JP,IFIND,ISTAV,ITIME,ISCALD,
     2                  SMULT,SADD,ORIGIN,CINT,IPLAIN,PLAIN,UNITS,NPRED,
     3                  NDATE,KFILRA,RACESS,NUMRA,
     4                  ICALL,CCALL,ICALLD,CCALLD,NAME,NSTA,NGRID,DIR,
     5                  NGRIDC,ISDATA,SDATA,SDATA1,L1DATA,
     6                  NELEV,STALAT,STALON,ITIMEZ,ND1,ND11,
     7                  IPACK,IWORK,DATA,ND5,MINPK,
     8                  LSTORE,MSTORE,ND9,LITEMS,MITEMS,CORE,ND10,LASTL,
     9                  NBLOCK,LASTD,NSTORE,NFETCH,
     A                  IS0,IS1,IS2,IS4,ND7,
     B                  FD1,FD2,FD3,FD4,FD5,FD6,FD7,DATACDF,NCDF,
     C                  FDA,FDVERT,FDTIME,FDSINS,FDMS,ND2X3,
     D                  IP12,IP13,IP14,IP15,IP16,
     E                  NTOTBY,NTOTRC,NTOTBG,NTOTRG,NTOTGB,NTOTGR,
     F                  L3264B,L3264W,MISTOT,ISTOP,IER)
C
C$$$   SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: PRED23
C   PRGMMR: GLAHN          ORG: W/OST22          DATE: 2000-12-01
C
C ABSTRACT: TO OBTAIN FOR U202 ALL VARIABLES IDENTIFIED IN ID( , ),
C   IDPARS( , ), AND THRESH( ) FOR "DAY 1".  "BASIC" VARIABLES 
C   (THE VARIABLES SANS "PROCESSING" INFORMATION)
C   ARE IN JD( , ), RESPECTIVELY.  AVAILABLE VARIABLES ARE
C   INDICATED IN LSTORE( , ).  VARIABLES MAY BE OBTAINED 
C   FROM CORE( ) OR FROM DISK AS INDICATED IN LSTORE( , ),
C   OR THEY CAN BE COMPUTED THROUGH CALLING THE SUBROUTINE
C   OPTION.  THE VARIABLES ARE COMPUTED AND WRITTEN TO THE
C   OUTPUT FILE.  PRED23 IS ENTERED (ONLY) FOR THE FIRST
C   DATE/TIME.  
C
C   PRED23 FOR U202 WAS ADAPTED FROM PRED21 FOR U201.  ITS
C   PRIMARY PURPOSE IS TO COPY SELECTED GRIDPOINT DATA FROM A
C   TDLPACK FILE TO ANOTHER, BUT WILL ALSO COPY VECTOR DATA FROM
C   A VECTOR FILE TO ANOTHER.  THE COMPUTATIONAL ASPECTS OF U201
C   ARE RETAINED, EXCEPT INTERPOLATION INTO THE GRIDPOINT DATA
C   IS NOT DONE; RATHER THE GRIDPOINT DATA ARE PACKED AND
C   WRITTEN AS GRIDPOINT DATA.  THEREFORE, TWO OUTPUT FILES
C   ARE USED, ONE FOR VECTOR DATA, KFILIO AS IN U201, AND
C   ONE FOR GRIDPOINT DATA, KFILGO.
C
C   BECAUSE THE COMPUTATIONAL CAPABILITIES ON GRIDS ARE
C   RETAINED, THE GRIDPOINT DATA TO BE USED ARE UNPACKED,
C   AND THEREFORE HAVE TO BE REPACKED, EVEN IF UNMODIFIED.
C
C   IT IS A DIFFICULT CIRCUMSTANCE WHEN ALL DATA FOR 
C   DAY 1 ARE NOT AVAILABLE.  IN THAT CASE, WHEN OPTION
C   CANNOT IDENTIFY THE VARIABLE, IT IS ASSUMED THAT
C   IT IS NOT A COMPUTED VARIABLE BUT ONE THAT SHOULD
C   BE AVAILABLE FROM INPUT, BUT NOT FOR DAY 1.  SO,
C   ENTRIES ARE MADE DIRECTLY IN MSTORE( , ), WHICH
C   IS NORMALLY FILLED IN LMSTR2.  THE MAXIMUM RR
C   IN IDPARS(9, ) HAS TO BE APPLIED. 
C   
C PROGRAM HISTORY LOG:
C   00-12-01  GLAHN
C   01-02-01  GLAHN   MODIFIED TO NOT DO GRIDPOINT CALCULATIONS 
C                     WHEN FULL ID IS FOUND; CHANGED GO TO 350 
C                     TO 210 WHEN FINDING DUPLICATE IDS.
C   02-10-01  SFANOS  MODIFIED FORMAT STATEMENTS TO CONFORM TO
C                     FORTRAN90 STANDARDS ON THE IBM-SP
C   02-11-01  GLAHN   CHANGED ISDATA( ) TO FD1( ) AND ND1 TO ND2X3 
C                     IN CALL TO PACKG
C   03-02-01  WEISS   ADDED NGRID AND NAME( ) TO CALL TO OPTION.
C   05-01-28  MALONEY ADDED NCEP DOCBLOCK. ADDED CALLS TO W3TAGE.
C   05-03-09  MALONEY ADDED CALL TO PACKGR_OPER TO PACK GRIDDED
C                     RANDOM ACCESS FILES.
C   05-08-08  RLC     MODIFIED CALL TO PACKGR_OPER TO SEND IN THE
C                     VALUE 0 FOR ISCALE AS THE COMMENTS SUGGEST.
C                     IT WAS CAUSING CODE TO HANG WITH THE NEW 
C                     MDLLIB IF I DIDN'T.  DID NOT MAKE THE CHANGE 
C                     TO PRED24 BECAUSE WE DON'T USE IT IN OPERATIONS.
C   12-01-10  JLW     ADDED LOOPS TO TO WRITE PROBABILISTIC GRIDS TO
C		      RANDOM ACCESS FILES. 
C   12-06-25  ENGLE   ADDED PLAIN( ) TO THE CALLING SEQUENCE FOR ALL
C                     CALLS PACKG, PACKGR_OPER.
C
C USAGE:  CALLED BY U202
C
C        DATA SET USE:
C        INPUT FILES:
C          FORT.KFIL10 - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                        (INPUT-OUTPUT) 
C
C        OUTPUT FILES:
C          FORT.KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C          FORT.KFIL10 - UNIT NUMBER FOR INTERMEDIATE PREDICTOR STORAGE.
C                        (INPUT/OUTPUT)
C          FORT.KFILIO - UNIT NUMBER OF VECTOR OUTPUT FILE.
C                        (OUTPUT)
C          FORT.KFILGO - UNIT NUMBER OF GRIDPOINT OUTPUT FILE.
C                        (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              KFILIO = UNIT NUMBER OF INTERPOLATED OUTPUT FILE.  (INPUT)
C              KFILGO = UNIT NUMBER OF GRIDPOINT OUTPUT FILE. (INPUT)
C              NFIRST = 1 FOR FIRST DAY, 2 FOR SECOND, 3 OTHERWISE.  
C                       FOR PRED23, NFIRST WILL ALWAYS BE 1.  (INPUT)  
C             ID(J,N) = THE INTEGER VARIABLE ID'S (J=1,4) (N=1,NPRED).
C                       (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE VARIABLE
C                       ID CORRESPONDING TO ID( ) (J=1,15) (N=1,NPRED).
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C           THRESH(N) = THE BINARY THRESHOLD ASSOCIATED WITH IDPARS( ,N)
C                       (N=1,NPRED).  (INPUT)
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID (J=1,4) (N=1,NPRED).
C                       THIS IS THE SAME AS ID(J,N), EXCEPT THAT THE PORTIONS
C                       PERTAINING TO PROCESSING ARE OMITTED:
C                       B = IDPARS(3, ),
C                       T = IDPARS(8, ),
C                       I = IDPARS(13, ),
C                       S = IDPARS(14, ),
C                       G = IDPARS(15, ), AND
C                       THRESH( ).
C                       JD( , ) IS USED TO IDENTIFY THE BASIC MODEL FIELDS
C                       AS READ FROM THE ARCHIVE.  (INPUT)
C             JP(J,N) = JP( ,N) INDICATES WHETHER (>0) OR NOT (=0) VARIABLE N
C                       WILL BE OUTPUT FOR VIEWING (N=1,NPRED).
C                       J=1--GRIDPOINT VALUES,
C                       J=2--GRIDPRINT WITH CONTOURS, AND
C                       J=3--INTERPOLATED VALUES.
C                       THIS ALLOWS INDIVIDUAL VARIABLE CONTROL ON THE PRINT
C                       PARAMETERS IP12, IP13, AND IP14.  (INPUT)
C            IFIND(N) = SET TO 1 WHEN THE VARIABLE CAN BE FOUND DIRECTLY
C                       FROM GFETCH (DOESN'T HAVE TO GO THRU OPTION).
C                       SET TO 0 WHEN ID( , ) DOES NOT EXIST
C                       IN OPTION.  (OUTPUT)
C            ISTAV(N) = INDICATES FOR EACH VARIABLE (N=1,NPRED) WHETHER 
C                       DATA ARE CURRENTLY VECTOR (=1) OR GRIDPOINT (=0).
C                       WHEN STILL UNDETERMINED, SET = 2.
C                       (INTERNAL/OUTPUT)
C            ITIME(N) = FOR EACH VARIABLE (N=1,NPRED) INDICATES
C                       WHETHER (=1) OR NOT (=0) THE RR IS TO BE USED 
C                       BY GFETCH WHEN FETCHING DATA.  (OUTPUT)
C           ISCALD(N) = THE DECIMAL SCALING CONSTANT TO USE WHEN PACKING THE 
C                       INTERPOLATED DATA (N=1,ND4).  THE BINARY SCALING
C                       CONSTANT IS USED AS ZERO.  (INPUT)
C            SMULT(N) = THE MULTIPLICATIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C             SADD(N) = THE ADDITIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C           ORIGIN(N) = THE CONTOUR ORIGIN, APPLIES TO THE UNITS IN UNITS(N)
C                       (N=1,ND4).  (INPUT)
C             CINT(N) = THE CONTOUR INTERVAL, APPLIES TO THE UNITS IN
C                       UNITS(N) (N=1,ND4).  (INPUT)
C       IPLAIN(L,J,N) = 32 CHARACTERS (L=1,L3264W) (J=1,4) OF PLAIN LANGUAGE
C                       DESCRIPTION OF VARIABLES (N=1,ND4).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       EQUIVALENCED TO PLAIN( ).  (INPUT)
C            PLAIN(N) = THE PLAIN LANGUAGE DESCRIPTION OF THE VARIABLES
C                       (N=1,ND4).  EQUIVALENCED TO IPLAIN( , ).
C                       (CHARACTER*32)  (INPUT)
C            UNITS(N) = THE UNITS OF THE DATA THAT APPLY AFTER MULTIPLYING
C                       BY SMULT(N) AND ADDING SADD(N) (N=1,ND4).
C                       (CHARACTER*12)
C               NPRED = THE NUMBER OF VARIABLES NEEDED AND IDENTIFIED IN 
C                       ID( , ), ETC.  ALSO TREATED AS THE DIMENSION OF THE
C                       VARIABLES ID( , ), ETC.  THIS NAME IS A HOLDOVER,
C                       AS IS THE NAME OF THE ROUTINE ITSELF, TO WHEN 
C                       U201 WAS WRITTEN ONLY FOR PREDICTORS.  (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH VARIABLES ARE TO BE
C                       FURNISHED ON THIS CALL TO PRED23.  (INPUT)
C           KFILRA(J) = HOLDS THE UNIT NUMBERS FOR ACCESSING THE MOS-2000
C                       EXTERNAL RANDOM ACCESS FILES (J=1,ND12).  (INPUT)
C           RACESS(J) = THE FILE NAMES CORRESPONDING TO KFILRA(J) (J=1,NUMRA).
C                       (CHARACTER*60)  (INPUT)
C               NUMRA = THE NUMBER OF UNIT NUMBERS AND NAMES IN KFILRA( )
C                       AND RACESS( ).  (INPUT)
C        ICALL(L,K,J) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,NSTA) (J=1,6).
C                       EQUIVALENCED TO CCALL( , )  (INPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST, EXCEPT POSSIBLY 
C                       CCALLD( ).  EQUIVALENCED TO ICALL( , , ).
C                       (CHARACTER*8)  (INPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,ND5).
C                       EQUIVALENCED TO CCALLD( ).  (INPUT)
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5).  EQUIVALENCED 
C                       TO ICALLD( , ).  (CHARACTER*8)  (INTERNAL)
C             NAME(K) = NAMES OF STATIONS (K=1,NSTA).  USED FOR PRINTOUT
C                       ONLY.  (CHARACTER*20)  (INPUT)
C                NSTA = THE NUMBER OF STATIONS IN ICALL( , , ) AND CCALL( , ).
C                       (INPUT)
C               NGRID = THE NUMBER OF GRID COMBINATIONS IN DIR( , , ),
C                       MAXIMUM OF ND11.  (NOT ACTUALLY USED.)  (INPUT)
C          DIR(K,J,M) = THE IX (J=1) AND JY (J=2) POSITIONS ON THE GRID
C                       FOR THE COMBINATION OF GRID CHARACTERISTICS M
C                       (M=1,NGRID) AND STATION K (K=1,NSTA) IN NGRIDC( ,M).
C                       (INPUT)
C         NGRIDC(L,M) = HOLDS THE GRID CHARACTERISTICS (L=1,6) FOR EACH GRID
C                       COMBINATION (M=1,NGRID).
C                       L=1--MAP PROJECTION NUMBER (3=LAMBERT, 5=POLAR
C                            STEREOGRAPHIC). 
C                       L=2--GRID LENGTH IN MILLIMETERS,
C                       L=3--LATITUDE AT WHICH GRID LENGTH IS CORRECT *10000,
C                       L=4--GRID ORIENTATION IN DEGREES *10000,
C                       L=5--LATITUDE OF LL CORNER IN DEGREES *10000,
C                       L=6--LONGITUDE OF LL CORNER IN DEGREES *10000.
C           ISDATA(K) = USED IN PACK1D (K=1,NSTA).  (INTERNAL)
C            SDATA(K) = INTERPOLATED DATA FOR WRITING (K=1,NSTA).
C                       (INTERNAL)
C           SDATA1(K) = WORK ARRAY RESERVED FOR USE IN L2D2 (K=1,NSTA).
C                       (INTERNAL)
C           L1DATA(K) = THE ARRAY RESERVED FOR USE BY LINEARIZATION
C                       ROUTINES (K=1,NSTA).  (INTERNAL)  
C            NELEV(K) = ELEVATION OF STATIONS (K=1,NSTA).  (INPUT)
C           STALAT(K) = LATITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           STALON(K) = LONGITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           ITIMEZ(K) = TIME ZONE INDICATOR.  THE NUMBER OF HOURS
C                       THE STATION IS DIFFERENT FROM UTC (K=1,NSTA).
C                       (INPUT)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT WITH.
C                       (INPUT)
C                ND11 = MAXIMUM NUMBER OF GRID COMBINATIONS THAT CAN BE
C                       DEALT WITH ON THIS RUN.  LAST DIMENSION OF
C                       NGRIDC( , ) AND DIR( , , ).  (INPUT)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = ARRAY TO FURNISH TO SUBROUTINE GFETCH AND OPTION
C                       TO HOLD RETURNED DATA (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).
C                       MUST BE GE GRID SIZE, MAX IN RUN OF ND2X3.
C                       (INPUT)
C               MINPK = MINIMUM GROUP SIZE WHEN PACKING THE INTERPOLATED
C                       VALUES.  (INPUT)
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR( , ,L) AND
C                              IN NGRIDC( ,L) DEFINING THE CHARACTERISTICS
C                              OF THIS GRID.
C                       L=11 --THE NUMBER OF THE FIRST VARIABLE IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NPRED) FOR WHICH THIS
C                              VARIABLE IS NEEDED, WHEN IT DOES NOT NEED
C                              TO BE STORED AFTER DAY 1.  WHEN THE VARIABLE
C                              MUST BE STORED (TO BE ACCESSED THROUGH OPTION)
C                              FOR ALL DAYS, ID(11,N) IS 7777 + THE NUMBER
C                              OF THE FIRST VARIABLE IN THE SORTED LIST
C                              FOR WHICH THIS VARIABLE IS NEEDED.
C                       L=12 --USED INITIALLY IN ESTABLISHING MSTORE( , ).
C                              LATER USED AS A WAY OF DETERMINING WHETHER
C                              TO KEEP THIS VARIABLE.
C         MSTORE(L,J) = THE ARRAY HOLDING THE VARIABLES NEEDED AS INPUT, AFTER
C                       DAY 1, AND ASSOCIATED INFORMATION (L=1,7) (J=1,MITEMS).
C                       J=1,4 --THE 4 ID'S OF THE DATA.
C                       J=5   --THE VALUE TAKEN FROM LSTORE(11, ) WHICH
C                               INDICATES WHETHER OR NOT TO STORE THE
C                               VARIABLE AND THE FIRST PREDICTOR TO USE IT FOR.
C                       J=6   --THE CYCLE TIME FOR WHICH THIS VARIABLE
C                               IS NEEDED FOR THE DATE BEING PROCESSED.  A
C                               VARIABLE NEEDED FOR MORE THAN ONE CYCLE TIME
C                               WILL HAVE ONE (AND ONLY ONE) ENTRY FOR EACH
C                               CYCLE.
C                       J=7   --THE MAXIMUM TIME OFFSET RR (SEE IDPARS(9, )
C                               CORRESPONDING TO MSTORE(6, )
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , ) THAT 
C                       HAVE BEEN USED IN THIS RUN.
C              MITEMS = THE NUMBER OF ITEMS IN MSTORE( , ).
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA IDENTIFIED IN
C                       LSTORE( , ) (J=1,ND10).  WHEN CORE( ) IS FULL
C                       DATA ARE STORED ON DISK.  (OUTPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C               LASTL = THE LAST LOCATION IN CORE( ) USED FOR MOS-2000 INTERNAL
C                       STORAGE.  INITIALIZED TO 0 ON FIRST ENTRY TO GSTORE.
C                       ALSO INITIALIZED IN U201 IN CASE GSTORE IS NOT ENTERED.
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK FOR MOS-2000
C                       INTERNAL STORAGE.
C              NSTORE = THE NUMBER OF TIMES GSTORE HAS BEEN ENTERED.  GSTORE
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  THE USER 
C                       NEED NOT WORRY ABOUT THIS.   (OUTPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.  GFETCH
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).  (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).  (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C  FD1(J),FD2(J), ETC = WORK ARRAYS (J=1,ND2X3).  THESE MAY BE USED IN
C                       ROUTINES AS 2-DIMENSIONAL ARRAYS, WHERE THE
C                       TOTAL ARRAY SIZE IS ND2*ND3=ND2X3 AS DECLARED IN
C                       THE CALLING PROGRAM.  (INTERNAL)
C              FDA(J) = USED TO RETAIN A GRID WITHIN PRED23 TO ELIMINATE
C                       MULTIPLE SEARCHES BY GFETCH AND UNPACKING OF
C                       THE DATA.  (INTERNAL)
C           FDVERT(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE VERTP
C                       (J=1,ND2X3).
C           FDTIME(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE TEMEP
C                       (J=1,ND2X3).
C       FDSINS(IX,JY) = USED TO SAVE THE SIN OF THE LATITUDE IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C         FDMS(IX,JY) = USED TO SAVE THE MAP FACTOR IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C               ND2X3 = DIMENSION OF FD1( ), FD2( ), ETC.   MUST BE
C                       AT LEAST AS LARGE AS THE LARGEST GRID AND AS
C                       LARGE AS NSTA.  (INPUT)
C                IP12 = INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE INPUT VECTOR FILES WILL BE WRITTEN 
C                       TO UNIT IP12.
C                IP13 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE WRITTEN TO UNIT IP13 FOR VIEWING.  (INPUT)
C                IP14 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE CONTOURED AND WRITTEN TO UNIT IP14 FOR
C                       VIEWING.  (INPUT)
C                IP15 = INDICATES WHETHER (>1) OR NOT (=0) INTERPOLATED
C                       VALUES WILL BE WRITTEN TO UNIT IP15 FOR VIEWING.
C                       (INPUT)
C                IP16 = INDICATES WHETHER (>0) OR NOT (=0) DIAGNOSTICS
C                       WILL BE WRITTEN TO UNIT IP16 FOR LINEARIZATION
C                       AND CONSTANT ROUTINES (E.G., STATIONS IN
C                       THRESHOLD LISTS THAT ARE NOT BEING DEALT WITH
C                       IN THIS RUN).  (INPUT)
C              NTOTBY = THE TOTAL NUMBER OF BYTES IN THE FILE ASSOCIATED
C                       WITH UNIT NO. KFILIO (THE INTERPOLATED FILE).
C                       IT IS UPDATED WHEN THE DATA IN IPACK( ) ARE WRITTEN.
C                       (INPUT-OUTPUT)
C              NTOTRC = THE TOTAL NUMBER OF RECORDS IN THE FILE.  IT IS
C                       UPDATED AS NEEDED IN WRITEP.  (INPUT-OUTPUT)
C              NTOTBG = THE TOTAL NUMBER OF BYTES ON THE FILE ASSOCIATED
C                       WITH UNIT NO. KFILGO (THE GRIDPOINT FILE).
C                       IT IS UPDATED WHEN THE DATA IN IPACK( ) ARE
C                       WRITTEN.  (INPUT/OUTPUT)
C              NTOTRG = THE TOTAL NUMBER OF RECORDS IN THE GRIDPOINT FILE.
C                       IT IS UPDATED AS NEEDED IN WRITEP.  (INPUT/OUTPUT)
C              NTOTGB = THE TOTAL NUMBER OF BYTES ON THE FILE ASSOCIATED
C                       WITH UNIT NO. KFILRA(JJ) (THE TDLPACK RA FILE).
C                       IT IS UPDATED WHEN THE DATA IN IPACK( ) ARE
C                       WRITTEN.  (INPUT-OUTPUT)
C              NTOTGR = THE TOTAL NUMBER OF RECORDS ON THE RA FILE.  IT
C                       IS UPDATED WHEN THE DATA IN IPACK( ) ARE
C                       WRITTEN.  (INPUT-OUTPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING USED
C                       (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  (INPUT)  
C              MISTOT = TOTAL NUMBER OF TIMES A PRIMARY MISSING INDICATOR
C                       HAS BEEN ENCOUNTERED IN UNPACKING GRIDS.  NOTE 
C                       THAT THIS IS LIMITED TO GRIDS AND DOES NOT
C                       INCLUDE VECTORS.  (INPUT-OUTPUT)
C            ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT MAY BE FATAL.
C                       FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER AN
C                       INPUT DATA RECORD IS NOT FOUND.  (INPUT-OUTPUT)
C                 IER = STATUS RETURN.
C                        0 = GOOD RETURN.
C                       38 = ND2X3 NOT LARGE ENOUGH.
C                       SEE OTHER ROUTINES FOR OTHER VALUES.
C                       (INTERNAL-OUTPUT)
C               NSLAB = THE NUMBER OF THE SLAB IN DIR( , , ) AND
C                       IN NGRIDC( , ) DEFINING THE CHARACTERISTICS
C                       OF THIS GRID.  SEE LSTORE(10, ).  (INTERNAL) 
C              NTIMES = THE NUMBER OF TIMES, INCLUDING THIS ONE, THAT THE 
C                       DATA HAVE BEEN FETCHED.  THIS IS STORED IN
C                       LSTORE(9, ).  (INTERNAL)
C              NFETCH = INCREMENTED EACH TIME DATA ARE STORED BY GFETCH.
C                       IF THIS IS NOT MODIFIED BY THE USER, IT IS A RUNNING
C                       COUNT FROM THE BEGINNING OF THE PROGRAM.  THIS COUNT
C                       IS MAINTAINED IN CASE THE USER NEEDS IT (DIAGNOSTICS,
C                       ETC.).  (INTERNAL)
C                 NYR = YEAR, 4 DIGITS.  (INTERNAL)
C                 NMO = MONTH.  (INTERNAL)
C                 NDA = DAY OF MONTH.  (INTERNAL)
C                 NHR = HOUR, 2 DIGITS.  (INTERNAL)
C               LD(J) = HOLDS THE 3 ID WORDS OF THE DATA IN FDA( ) (J=1,3).  
C                       (INTERNAL)
C               LPARS = HOLDS THE VALUE OF IDPARS(15, ) OF THE DATA IN FDA( ).
C                       INITIALIZED TO 9999 FOR SAFETY.  (INTERNAL)
C               NSIZE = THE NUMBER OF VALUES IN VARIOUS ARRAYS, EITHER
C                       VECTOR OR GRIDPOINT.  (INTERNAL)
C               MISSP = PRIMARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C               MISSS = SECONDARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C              XMISSP = PRIMARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C              XMISSS = SECONDARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C              NGOMIS = SWITCH TO KEEP FROM PROCESSING A MISSING GRID.
C                       1 = MISSING GRIDPOINT DATA,
C                       0 = GOOD GRID DATA.
C                       (INTERNAL)
C              NWORDS = NUMBER OF WORDS IN IPACK( ) RETURNED FROM PACKV.
C                       (INTERNAL)
C               IDYES = 1 WHEN THE FULL ID WAS FOUND BY GFETCH; 
C                       0 OTHERWISE. 
C               LDYES = SAVES IDYES WHEN GRID IS SAVED FOR RESTORING.
C        1         2         3         4         5         6         7 X
C 
C        SUBPROGRAMS CALLED:  GFETCH, OPTION, GRIDB, SMTH5, SMTH9, 
C            SMTH25, SMTH2X, SMTH3X, TRANS, BINARY, PREDX1, PACKV, 
C            PACKG, TIMPR, W3TAGE
C          UNIQUE: NONE
C          LIBRARY:
C           MOSLIB - GFETCH, OPTION, GRIDB, SMTH5, SMTH9, SMTH25, 
C             SMTH2X, SMTH3X, TRANS, BINARY, PREDX1, PACKV, PACKG, TIMPR
C           W3LIB  - W3TAGE
C
C        EXIT STATES:
C          COND =    0 - SUCCESSFUL RUN
C                   38 - ND2X3 NOT LARGE ENOUGH. 
C                 1345 - ND9 NOT LARGE ENOUGH (SHOULD NOT HAPPEN)
C                 1351 - ND9 NOT LARGE ENOUGH (SHOULD NOT HAPPEN)
C                   SEE OTHER ROUTINES FOR OTHER VALUES.
C
C REMARKS:  NONE
C
C ATTRIBUTES:
C   LANGUAGE:  FORTRAN 90 (xlf90 compiler)
C   MACHINE:  IBM SP
C
C$$$
C
      CHARACTER*8 CCALL(ND1,6),
     1            CCALLD(ND5)
      CHARACTER*12 UNITS(ND1)
      CHARACTER*20 NAME(ND1)
      CHARACTER*32 PLAIN(NPRED)
      CHARACTER*60 RACESS(NUMRA)
C
      DIMENSION ICALL(L3264W,ND1,6),
     1          NELEV(ND1),STALAT(ND1),STALON(ND1),ITIMEZ(ND1),
     2          ISDATA(ND1),SDATA(ND1),SDATA1(ND1),L1DATA(ND1)
      DIMENSION SDATACDF(ND1,NCDF)
      DIMENSION DIR(ND1,2,ND11),NGRIDC(6,ND11)
      DIMENSION ID(4,NPRED),IDPARS(15,NPRED),THRESH(NPRED),
     1          JD(4,NPRED),JP(3,NPRED),IFIND(NPRED),ISTAV(NPRED),
     2          ITIME(NPRED),ISCALD(NPRED),SMULT(NPRED),SADD(NPRED),
     3          ORIGIN(NPRED),CINT(NPRED)
      DIMENSION IPLAIN(L3264W,4,NPRED)
      DIMENSION FD1(ND2X3),FD2(ND2X3),FD3(ND2X3),FD4(ND2X3),
     1          FD5(ND2X3),FD6(ND2X3),FD7(ND2X3),FDA(ND2X3),
     2          FDVERT(ND2X3),FDTIME(ND2X3),FDSINS(ND2X3),FDMS(ND2X3)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5),ICALLD(L3264W,ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9),MSTORE(7,ND9),DATACDF(ND5,NCDF)
      DIMENSION CORE(ND10)
      DIMENSION KFILRA(NUMRA)
      DIMENSION LD(3),ISTOP(2)
      DIMENSION CDFTABLE(11)
C
      DATA LPARS/9999/,
     1     NGOMIS/0/
      DATA CDFTABLE/000050000,
     1             000100000,
     2             000200000,
     3             000300000,
     4             000400000,
     5             000500000,
     6             000600000,
     7             000700000,
     8             000800000,
     9             000900000,
     A             000950000/
C
      IER=0
C***D     CALL TIMPR(KFILDO,KFILDO,'START PRED23        ')
C
C        SET UP SOME VALUES FOR LOADING IS1( ).
C
      NYR=NDATE/1000000
      NMO=NDATE/10000-NYR*100
      NDA=NDATE/100-NYR*10000-NMO*100
      NHR=NDATE-NYR*1000000-NMO*10000-NDA*100
C
C        FIND/COMPUTE ALL VARIABLES FOR THE DATE IN NDATE.
C      
      MITEMS=0
C 
      DO 400 N=1,NPRED
      ITIME(N)=1
C        ITIME(N) = 1 SIGNIFIES RR IS TO BE USED.  THIS WILL
C        BE MODIFIED LATER IF THE FULL ID IS LOCATED BY GFETCH.
      IFIND(N)=1
C        SET IFIND( ) FOR SAFETY.  IT SHOULD BE REPLACED.
C
      IF(IDPARS(1,N).EQ.799)GO TO 390
C           NO NEED TO LOOK FOR THE SPECIAL CCC = 799.
C
      IF(N.EQ.1)GO TO 130
      IF(ISTAV(N-1).EQ.1)GO TO 130
C        NOTE THAT ISTAV(N) HAS NOT BEEN INITIALIZED YET.
C
C        THIS SECTION IS NOT ENTERED FOR VECTOR DATA.
C        THIS VARIABLE CAN BE REUSED FROM THE PREVIOUS ONE ONLY IF:
C           (1) IT IS A GRID AND ONLY THE POINT COMPUTATIONS
C               ARE NECESSARY (E.G., INTERPOLATION).
C        IF GRID PROCESSING (E.G., SMOOTHING) IS NEEDED ON A 
C        BASIC GRID, IT MAY BE SAVED IN FDA( ).
C        THE MAIN PURPOSE OF THESE BYPASSES IS TO COUNT THE NUMBER OF
C        TIMES A GRID MUST BE ACCESSED ON SUBSEQUENT DATES.  THIS IS 
C        SO THAT ONLY THOSE DATA THAT MUST BE ACTUALLY RETRIEVED FROM 
C        THE MOS-2000 INTERNAL STORAGE SYSTEM WILL BE STORED WITH
C        GSTORE.)
C
      ISTAV(N)=ISTAV(N-1)
C        ISTAV(N) MAY LATER BE REPLACED.
      IF(JD(1,N).EQ.JD(1,N-1).AND.
     1   JD(2,N).EQ.JD(2,N-1).AND.
     2   JD(3,N).EQ.JD(3,N-1).AND.
     3   IDPARS(3,N).NE.5.AND.
     4   IDPARS(3,N-1).NE.5.AND.
     5   IDPARS(13,N).EQ.IDPARS(13,N-1).AND.
     6   IDPARS(14,N).EQ.IDPARS(14,N-1).AND.
     7   IDPARS(15,N).EQ.IDPARS(15,N-1).AND.
     8   NGOMIS.EQ.0)THEN
C           THE CHECK ON IDPARS(3,N-1) IS NOT NECESSARY WHEN
C           THE VARIABLES ARE ORDERED, AS THEY SHOULD BE
C           UNLESS SORTEM IS TAKEN OUT OF RDPRED.  NGOMIS
C           IS 1 WHEN THE PREVIOUS VARIABLE WAS MISSING.
C           THE CHECK ABOVE WAS FOR U201 AND WILL PROBABLY NEVER
C           BE MET IN U202.
         IFIND(N)=1
         GO TO 210
      ENDIF
C        WHEN THE ABOVE TEST IS MET, THE VARIABLE NEEDED IS THE
C        SAME AS THE PREVIOUS ONE.  THIS WILL BE A GRID, AND
C        THE DATA ARE IN DATA( ).  POINT COMPUTATIONS
C        (E.G., INTERPOLATION) WILL NOT BE DONE,  THE GRID WILL
C        JUST BE WRITTEN AND PERHAPS GRIDPRINTED.  IDYES IS 
C        PRESERVED.
C
C        IS THIS VARIABLE REUSABLE AND STORED IN FDA( )?  NOTE THAT
C        THESE DATA ARE USED FOR MAKING A GRID BINARY AND/OR
C        SMOOTHING.
C
      IF(JD(1,N).NE.LD(1).OR.
     1   JD(2,N).NE.LD(2).OR.
     2   JD(3,N).NE.LD(3).OR.
     3   LPARS.NE.IDPARS(15,N))GO TO 130
C
C        TAKE DATA FROM FDA( ), UNLESS THE VALUES ARE MISSING, IN
C        WHICH CASE JUST SET THE INTERPOLATED VALUES MISSING.
C        DATA CAN BE USED FROM FDA( ) WHEN THE GRID (FROM GSTORE
C        OR OPTION) IS THE SAME, BUT MAKING A GRID BINARY AND
C        SMOOTHING CAN BE DIFFERENT, AS WELL AS THE POINT
C        CALCULATIONS OF MAKING A POINT BINARY, TRANSFORMATION,
C        AND INTERPOLATION.
C
D     WRITE(KFILDO,119)(JD(K,N),K=1,4)
D119  FORMAT( ' RESTORING GRID AT 119 IN PRED23 ',I11.9,3I11)
C
      IFIND(N)=1
      IDYES=LDYES
C        PRESERVE IDYES.
C
      DO 120  K=1,NSIZE
      DATA(K)=FDA(K)
 120  CONTINUE
C
      GO TO 205
C
C        LOOK FOR ID( ) FIRST IN CASE PROCESSING HAS ALREADY BEEN
C        DONE AND THE FULL ID IS THERE.  THIS CAN BE TRUE FOR 
C        BOTH VECTOR AND GRIDPOINT DATA (E.G., SMOOTHED GRID FROM
C        U150).
C
 130  JTIME=0
C        FIRST TRY WITH RR INOPERATIVE UNLESS THE PREVIOUS
C        VARIABLE IS THE SAME WITH ITIME = 0.  THEN, IN
C        ORDER TO NOT GET THE SAME VARIABLE, RR MUST BE
C        OPERATIVE.
 1300 CALL GFETCH(KFILDO,KFIL10,ID(1,N),N,LSTORE,ND9,LITEMS,
     1            IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,DATA,ND5,
     2            NSIZE,NPACK,NDATE,NTIMES,CORE,ND10,
     3            NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,JTIME,
     4            IER)
C         DATA ARE RETURNED IN DATA( ) BOTH VECTOR AND GRIDPOINT
C         DATA WILL BE UNPACKED.
C***D     WRITE(KFILDO,1301)IER,(ID(KK,N),KK=1,4)
C***D1301 FORMAT(' AT 1301 IN PRED23, IER,ID( , ) ='5I12)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN GFETCH.
      IF(IER.EQ.0)THEN
         ITIME(N)=JTIME
C           IF THE FULL ID WAS FOUND (WITH NO RR TIME OFFSET),
C           ITIME(N) IS SET TO JTIME SIGNIFYING WHETHER OR NOT RR
C           IS NOT TO BE USED ON SUBSEQUENT DAYS FOR THIS VARIABLE.
         IDYES=1
C           IDYES=1 INDICATES DATA FOR THE FULL ID WERE FOUND.
C           RR MAY OR MAY NOT HAVE BEEN OPERATIVE.
         GO TO 1305
      ELSE
         IDYES=0
         IF(IER.NE.47)ISTOP(1)=ISTOP(1)+1
C           THIS IS AN ERROR EXCEPT WHEN IER = 47.
C
         IF(JTIME.EQ.0)THEN
            JTIME=1
C              JTIME SET = 1 THE FIRST TIME THROUGH LETS
C              STATEMENT 1300 BE REPEATED ONLY ONCE.
            IF(IDPARS(9,N).NE.0)GO TO 1300
C              NO NEED TO ENTER GFETCH AGAIN IF RR = 0.
         ENDIF
C
      ENDIF
C
      IF(IER.EQ.47)THEN
         IF(ID(1,N).EQ.JD(1,N).AND.
     1      ID(2,N).EQ.JD(2,N).AND.
     2      ID(3,N).EQ.JD(3,N).AND.
     3      ID(4,N).EQ.JD(4,N))GO TO 1305
C              NO USE TO CALL GFETCH AGAIN FOR THE SAME THING.
C              CALLS GFETCH HERE ONLY ON IER = 47 FROM ABOVE.
C
         CALL GFETCH(KFILDO,KFIL10,JD(1,N),N,LSTORE,ND9,LITEMS,
     1               IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,DATA,ND5,
     2               NSIZE,NPACK,NDATE,NTIMES,CORE,ND10,
     3               NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,1,
     4               IER)
C           DATA ARE RETURNED IN DATA( ); VECTOR DATA WILL BE
C           UNPACKED, GRIDPOINT DATA WILL BE PACKED WITH THE
C           IDENTIFIERS IN IS0( ), ETC.
C***D        WRITE(KFILDO,1302)IER,(JD(KK,N),KK=1,4)
C***D1302    FORMAT(' AT 1302, IER,JD( , ) ='5I12)
C
C           MOST NON-ZERO VALUES OF IER SHOULD BE NEAR FATAL.
C           ISTOP(1) IS INCREMENTED, EXCEPT WHEN IER = 47,
C           WHICH JUST MEANS DATA COULD NOT BE FOUND.  RETURNED
C           DATA WILL BE UNPACKED WHETHER OR NOT THEY WERE STORED
C           PACKED, AND NSIZE WILL BE THE NUMBER OF VALUES.
C           FOR GRIDPOINT DATA, THIS WILL BE IS2(3)*IS2(4); FOR
C           VECTOR DATA, THIS WILL BE NSTA.
      ENDIF
C
 1305 IF(IER.EQ.0)THEN
         IFIND(N)=1
C
         IF(NSIZE.GT.ND2X3)THEN
            WRITE(KFILDO,131)ND2X3,NSIZE
 131        FORMAT(/' ****ND2X3 =',I6,' TOO SMALL FOR GRID SIZE',
     1              ' IN PRED23 AT 131.  INCREASE TO GE',I6)
            IER=38
            ISTOP(1)=ISTOP(1)+1
            GO TO 300
         ENDIF
C
         IF(NSLAB.EQ.0)THEN
C
C              THIS IS VECTOR DATA.
C
            IF(IDYES.EQ.0)THEN
               IFIND(N)=0
C                 IDYES = 0 INDICATES THAT THE FULL ID WAS NOT
C                 FOUND BY GFETCH, AND WHEN THE DATA ARE VECTOR,
C                 DATA FOR THE PARTIAL ID, EVEN IF FOUND, ARE
C                 NOT USED.  A PARTIAL ID INDICATES PROCESSING
C                 IS NEEDED, AND PROCESSING ON VECTOR DATA IS
C                 NOT DONE OUTSIDE OPTION.  NOTE THAT IT IS
C                 NOT KNOWN BEFORE CALLING GFETCH THE SECOND 
C                 TIME THAT THE DATA ARE VECTOR.
               GO TO 133
            ENDIF
C
            ISTAV(N)=1
C              WHEN NSLAB = 0, THE DATA ARE VECTOR, NOT GRIDPOINT.
C              TRANSFER DATA FROM DATA( ) TO SDATA( ) AND DO NO
C              PROCESSING.   THE ONLY PROCESSING THAT CAN BE DONE 
C              ON VECTOR DATA MUST BE DONE IN OPTION.
C              THEREFORE, PUT DATA INTO SDATA( ) AND OUTPUT.
C              NOTE THAT THE ARRANGEMENT OF VECTOR DATA HAS
C              ALREADY BEEN MADE IN RDSTR2.
            NSTA=NSIZE
C            
            DO 132 K=1,NSIZE
            SDATA(K)=DATA(K)
 132        CONTINUE
C
            GO TO 350
         ELSE
C
C              THIS IS GRIDPONT DATA.
C
            ISTAV(N)=0
            IF(MISSP.NE.0)MISTOT=MISTOT+1
C              MISTOT IS AUGMENTED ONLY WHEN DATA ARE GRIDPOINT.
         ENDIF
C
         GO TO 138
C
      ELSEIF(IER.EQ.47)THEN
C           JUST MISSING DATA, A NOT UNEXPECTED EVENT.  GO TO OPTION,
C           DO NOT COUNT THIS AS AN ERROR.  (IT WOULD BE AN ERROR IN
C           PRED22.)
         ISTAV(N)=2
C           THE TYPE OF DATA IS UNDETERMINED.
         GO TO 133
C
      ELSE
         IFIND(N)=1
         ISTOP(1)=ISTOP(1)+1
C           FATAL ERROR FOR THIS VARIABLE.  IT WAS FOUND BY GFETCH, BUT
C           COULD NOT BE RETURNED.  ALL VALUES WILL BE MISSING.
C           GO TO 300 TO PUT MISSING VALUES INTO SDATA( ).
         ISTAV(N)=2
C           THE TYPE OF DATA IS UNDETERMINED.
         GO TO 300
C
      ENDIF
C
C        MUST COMPUTE THIS VARIABLE.
C
 133  CALL OPTION(KFILDO,KFIL10,NFIRST,
     1            ID(1,N),IDPARS(1,N),THRESH(N),JD(1,N),NDATE,
     2            KFILRA,RACESS,NUMRA,
     3            ICALL,CCALL,ICALLD,CCALLD,NAME,NELEV,STALAT,STALON,
     4            ITIMEZ,ISDATA,SDATA,SDATA1,L1DATA,DIR,ND1,NSTA,
     5            NGRIDC,NGRID,ND11,NSLAB,IPACK,IWORK,DATA,ND5,
     6            LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     7            NBLOCK,LASTD,NSTORE,NFETCH,
     8            IS0,IS1,IS2,IS4,ND7,
     9            FD1,FD2,FD3,FD4,FD5,FD6,FD7,DATACDF,NCDF,
     A            FDVERT,FDTIME,FDSINS,FDMS,ND2X3,IP12,IP16,
     B            ISTAV(N),L3264B,L3264W,MISTOT,IER)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN OPTION.
      NSIZE=IS2(3)*IS2(4)
      IF(ISTAV(N).EQ.1)NSIZE=NSTA
C***D     WRITE(KFILDO,134)N,(ID(J,N),J=1,4),ISTAV(N),IER
C***D134  FORMAT(' OUT OF OPTION AT 133 IN PRED23--N,ID( ,N),ISTAV(N),IER',
C***D    1         8I10)
C
C        AS A SPECIAL FEATURE, IER = -1 FROM A SUBROUTINE CALLED
C        BY OPTION MEANS THAT THE DATA ARE NOT TO BE WRITTEN.
C        THIS CAN BE USED WHEN NOT ALL HOURS BEING PROCESSED
C        HAVE DATA FOR THAT HOUR (E.G., MAX/MIN TEMPERATURE).
C        ALSO, WHEN THE VARIABLE ID CANNOT BE LOCATED IN OPTION,
C        IER IS RETURNED AS -2.  THIS FACILITATES THE USE OF THE
C        LOOKBACK FEATURE WHEN NOT ALL DATA ARE AVAILABLE 
C        FOR DAY 1.
C 
      IF(IER.EQ.0)THEN
C           THE VARIABLE IS TO COME FROM OPTION.  THE SUBROUTINE
C           SHOULD HAVE SET ISTAV( ).
         IFIND(N)=0
         IDYES=0
C           IDYES = 0 ALLOWS PROCESSING ON GRIDPOINT DATA FROM
C           OPTION.
         GO TO 1375
C
      ELSEIF(IER.EQ.-1)THEN
C           SURELY, THE VARIABLE IS TO COME FROM OPTION. 
C           THE SUBROUTINE SHOULD HAVE SET ISTAV( ).
         IFIND(N)=0
C            DON'T WRITE THIS VARIABLE.  IER = -1 IS RETURNED FROM
C            A SUBROUTINE.  IT SHOULD NOT REPRESENT AN ERROR; AN
C            ERROR SHOULD BE IER GT 0.
         WRITE(KFILDO,1342)(ID(J,N),J=1,4)
         ISTOP(2)=ISTOP(2)+1
         GO TO 390
C
      ELSEIF(IER.EQ.-2)THEN
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=1
C           IER = -2 IS RETURNED FROM OPTION, WHICH MEANS VARIABLE
C           COULD NOT BE IDENTIFIED.  PUT THIS VARIABLE INTO 
C           MSTORE( , ) IN CASE IT IS A "RAW" VARIABLE AND IS 
C           JUST NOT AVAILABLE ON DAY 1.  SETTING IFIND( ) TO 1
C           KEEPS CONTROL OUT OF OPTION IN PRED22.
         ISTAV(N)=2
C           ISTAV(N) SET TO 2 WHEN THE VARIABLE COULD NOT BE
C           IDENTIFIED IN OPTION.  THIS WILL LET IT BE FOUND
C           ON INPUT IN CASES WHERE IT WAS NOT AVAILABLE ON
C           DAY 1.  DON'T WRITE THIS VARIABLE; IT IS NOT KNOWN
C           WHETHER IT IS VECTOR OR GRIDPOINT.
         WRITE(KFILDO,1342)(ID(J,N),J=1,4)
 1342    FORMAT('     VARIABLE                   ',
     1           I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     2          ' WILL NOT BE WRITTEN.')
         ISTOP(2)=ISTOP(2)+1
         GO TO 1343
C
      ELSEIF(IER.EQ.47)THEN
C           DON'T COUNT THIS AS AN ERROR.  IT IS POSSIBLE THE
C           VARIABLE IS FOUND IN OPTION, BUT MISSING DATA FROM
C           GFETCH THROWS IT TO OPTN2, WHERE THE VARIABLE CAN'T
C           BE IDENTIFIED.  THIS IS PROBABLY JUST CAUSED BY
C           MISSING DATA, AND OPTN2 DOES NOT WRITE A DIAGNOSTIC
C           UNLESS COMPILED WITH /D.
         IFIND(N)=2
C           STILL DON'T KNOW WHERE THE VARIABLE IS TO COME FROM.
C           DON'T WRITE IT.
         WRITE(KFILDO,1342)(ID(J,N),J=1,4)
         ISTOP(2)=ISTOP(2)+1
         GO TO 1343
C
      ELSEIF(IER.EQ.120)THEN
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=0
C           THE VARIABLE IS TO COME FROM OPTION.
         IER=0
C           IER = 120 IS FROM FINDST IN CONST AND MEANS SOME
C           STATIONS COULD NOT BE FOUND.  THIS IS NOT FATAL.
         GO TO 1375
C
      ELSE
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=0
C           SURELY, THE VARIABLE IS TO COME FROM OPTION.
         WRITE(KFILDO,1342)(ID(J,N),J=1,4)
         ISTOP(2)=ISTOP(2)+1
         GO TO 400
C
      ENDIF
C        IF OPTION COULD NOT IDENTIFY A VARIABLE, THEN IT
C        IT IS LIKELY THE VARIABLE IS ONE AVAILABLE ON
C        INPUT, BUT NOT AT THE FIRST DATE/TIME.  ENTER
C        IT INTO MSTORE( , ) IN ANTICIPATION.  THIS MAY
C        NOT WORK IN ALL CASES.  ONE PROBLEM IS THAT IT
C        IS NOT KNOWN WHETHER THIS IS A GRID NEEDED AT
C        TAU = IDPARS(12, ), IN WHICH CASE THE 4TH ID
C        WORD WOULD BE 0, OR WHETHER IT IS INTERPOLATED
C        DATA FROM A GRID, IN WHICH CASE THE 4TH ID 
C        WORD WOULD CONTAIN THE THRESHOLD, I, AND S.
C        MORE THAN ONE POSSIBILITY IS INCLUDED TO TRY
C        COVER ALL BASES.  NORMALLY, A BINARY WOULD
C        NOT BE LOOKED FOR AND IS NOT PROVIDED FOR,
C        EXCEPT FOR A GRID BINARY.
C
 1343 MITEMS=MITEMS+1
C
      IF(MITEMS.GT.ND9)THEN
         WRITE(KFILDO,1345)
 1345    FORMAT(/' ****ND9 =',I5,' NOT LARGE ENOUGH.',
     1           '  CATASTROPHIC ERROR.  STOP AT 1345 IN PRED23.')
         CALL W3TAGE('PRED23')
         STOP 1345
      ENDIF
C
      MSTORE(1,MITEMS)=IDPARS(1,N)*1000000+
     1                 IDPARS(2,N)*1000+
     2                 IDPARS(4,N)
      MSTORE(2,MITEMS)=ID(2,N)
      MSTORE(3,MITEMS)=IDPARS(8,N)*100000000+
     1                 IDPARS(10,N)*100000+
     2                 IDPARS(11,N)*1000+
     3                 IDPARS(12,N)
      MSTORE(4,MITEMS)=0
C
      IF(IDPARS(9,N).EQ.0)THEN
C           NOTE THAT ONLY "ON-TIME" DATA HAVE OTHER THAN 7777.
         MSTORE(5,MITEMS)=N+7777
         MSTORE(6,MITEMS)=NDATE
         MSTORE(7,MITEMS)=0
      ELSE
         MSTORE(5,MITEMS)=7777
         CALL UPDAT(NDATE,-IDPARS(9,N),LDATE)
         MSTORE(6,MITEMS)=LDATE
         MSTORE(7,MITEMS)=IDPARS(9,N)
C           DATA MAY BE KEPT LONGER THAN NEEDED; CAN'T
C           BE HELPED.
      ENDIF
C
C        DON'T KEEP IF A DUPLICATE, AND MAKE SURE
C        IT IS KEPT FAR ENOUGH BACK.
C
      IF(MITEMS.EQ.1)GO TO 1350
C
      DO 135 L=1,MITEMS-1
      IF(MSTORE(1,L).NE.MSTORE(1,MITEMS).OR.
     1   MSTORE(2,L).NE.MSTORE(2,MITEMS).OR.
     2   MSTORE(3,L).NE.MSTORE(3,MITEMS).OR.
     3   MSTORE(4,L).NE.MSTORE(4,MITEMS))GO TO 135
      IF(MOD(MSTORE(6,L),100).NE.MOD(MSTORE(6,MITEMS),100))GO TO 135
C        THE ABOVE STATEMENT KEEPS THE ENTRY IF ITS CYCLE 
C        IS DIFFERENT.
C
      IF(MSTORE(5,L).GT.7777)THEN 
         GO TO 1348
      ELSEIF(MSTORE(5,L).EQ.7777)THEN
C
         IF(MSTORE(5,MITEMS).EQ.7777)THEN
            GO TO 1348
         ELSEIF(MSTORE(5,MITEMS).LT.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,MITEMS)+7777
         ENDIF
C
      ELSE
C
         IF(MSTORE(5,MITEMS).LE.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,L)+7777
         ENDIF
C
      ENDIF
C
 1348 MSTORE(6,L)=MIN(MSTORE(6,L),MSTORE(6,MITEMS))
      MSTORE(7,L)=MAX(MSTORE(7,L),MSTORE(7,MITEMS))
C        
      MITEMS=MITEMS-1 
      GO TO 1350
C
 135  CONTINUE
C
C        THE BELOW IS FOR VECTOR DATA.  THIS SHOULD WORK
C        FOR OBSERVATIONS AND PREVIOUSLY COMPUTED/INTERPOLATED
C        DATA.  BINARIES ARE NOT PROVIDED FOR, EXCEPT FOR
C        GRID BINARIES.
C
 1350 MITEMS=MITEMS+1
C
      IF(MITEMS.GT.ND9)THEN
         WRITE(KFILDO,1351)
 1351    FORMAT(/' ****ND9 =',I5,' NOT LARGE ENOUGH.',
     1           '  CATASTROPHIC ERROR.  STOP AT 1351 IN PRED23.')
         CALL W3TAGE('PRED23')
         STOP 1351
      ENDIF
C
      MSTORE(1,MITEMS)=IDPARS(1,N)*1000000+
     1                 IDPARS(2,N)*1000+
     2                 IDPARS(4,N)
C
      IF(IDPARS(3,N).EQ.5)THEN
C           THIS IS A GRID BINARY.
         MSTORE(1,MITEMS)=MSTORE(1,MITEMS)+IDPARS(3,N)*100
      ENDIF
C
      MSTORE(2,MITEMS)=ID(2,N)
      MSTORE(3,MITEMS)=ID(3,N)
      MSTORE(4,MITEMS)=ID(4,N)
C        
      IF(IDPARS(9,N).EQ.0)THEN
C           NOTE THAT ONLY "ON-TIME" DATA HAVE OTHER THAN 7777.
         MSTORE(5,MITEMS)=N
      ELSE
         MSTORE(5,MITEMS)=7777
      ENDIF
C
      MSTORE(6,MITEMS)=NDATE
      MSTORE(7,MITEMS)=0
C
C        DON'T KEEP IF A DUPLICATE, AND MAKE SURE
C        IT IS KEPT FAR ENOUGH BACK.
C
      IF(MITEMS.EQ.1)GO TO 1370
C
      DO 137 L=1,MITEMS-1
      IF(MSTORE(1,L).NE.MSTORE(1,MITEMS).OR.
     1   MSTORE(2,L).NE.MSTORE(2,MITEMS).OR.
     2   MSTORE(3,L).NE.MSTORE(3,MITEMS).OR.
     3   MSTORE(4,L).NE.MSTORE(4,MITEMS))GO TO 137
C
      IF(MSTORE(5,L).GT.7777)THEN 
         GO TO 136
      ELSEIF(MSTORE(5,L).EQ.7777)THEN
C
         IF(MSTORE(5,MITEMS).EQ.7777)THEN
            GO TO 136
         ELSEIF(MSTORE(5,MITEMS).LT.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,MITEMS)+7777
         ENDIF
C
      ELSE
C
         IF(MSTORE(5,MITEMS).LE.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,L)+7777
         ENDIF
C
      ENDIF
C        
 136  MSTORE(6,L)=MIN(MSTORE(6,L),MSTORE(6,MITEMS))
      MSTORE(7,L)=MAX(MSTORE(7,L),MSTORE(7,MITEMS))
C        
      MITEMS=MITEMS-1
      GO TO 1370    
C
 137  CONTINUE
C
 1370 IER=0
C***D     WRITE(KFILDO,1374)((MSTORE(I,J),I=1,7),J=1,MITEMS)
C***D1374 FORMAT(' MSTORE IN PRED23 AT 1374'/(' '7I12))
      GO TO 400
C
C        COMES THROUGH HERE ONLY FOR IER = 0.
C        THIS SECTION FOR GRIDPOINT DATA.
C
 1375 IF(ISTAV(N).EQ.1)GO TO 350
C        VECTOR DATA ARE NOT SAVED IN FDA( ).  TRANSFORMATION
C        AND BINARY OPERATORS ARE USED FOR VECTOR DATA FROM
C        OPTION (BUT NOT FOR VECTOR DATA NOT FROM OPTION). 
C
C        DETERMINE WHETHER OR NOT THE DATA IN DATA( ) CAN BE USED FOR
C        THE NEXT VARIABLE.  IF SO, SAVE IT IN FDA( ).  THIS IS OK 
C        EVEN THOUGH THE VALUES MAY BE SET TO THE MISSING VALUE.
C        NORMALLY, A MISSING FIELD IS NOT SAVED  OPTION DOES NOT SET
C        MISSING VALUES WHEN THE FIELD CANNOT BE RETURNED BECAUSE 
C        GFETCH HAS JUST BEEN CALLED WHICH DOES RETURN MISSING VALUES
C        WHICH ARE CARRIED OVER.  WHEN ISTAV( ) EQ 1, MISSING STATION
C        VALUES SHOULD BE RETURNED.
C
 138  IF(N.EQ.NPRED)GO TO 204
C        THE LAST VARIABLE IN THE LIST NEED NOT BE SAVED.
C
C        SAVE GRID FOR POSSIBLE REUSE.  IT IS POSSIBLE IT WON'T BE 
C        NEEDED FOR THE NEXT VARIABLE (E.G., POINT BINARY) BUT
C        WILL BE NEEDED FOR THE NEXT (E.G., GRID BINARY).  OR IT
C        MAY NOT BE NEEDED AT ALL, BUT THIS CONTINGENCY KEEPS
C        GRIDS FROM BEING STORED BY GSTORE UNNECESSARILY IN
C        SUBSEQUENT PASSES IN PRED22.
C
      IF(JD(1,N).NE.JD(1,N+1).OR.
     1   JD(2,N).NE.JD(2,N+1).OR.
     2   JD(3,N).NE.JD(3,N+1).OR.
     3   IDPARS(15,N).NE.IDPARS(15,N+1))GO TO 204
C        THE IDPARS(15, ) CHECK IS A SAFETY.  AT PRESENT, IDPARS(15, )
C        IS NOT USED.     
C
      LD(1)=JD(1,N)
      LD(2)=JD(2,N)
      LD(3)=JD(3,N)
      LPARS=IDPARS(15,N)
      LDYES=IDYES
C        PRESERVE IDYES.
C
D     WRITE(KFILDO,139)(JD(K,N),K=1,4)
D139  FORMAT(/' SAVING GRID AT 139 IN PRED23    ',I11.9,3I11)
C
      DO 140 K=1,NSIZE
      FDA(K)=DATA(K)
 140  CONTINUE
C
C        AT THIS POINT, THE VARIABLE HAS BEEN FOUND OR COMPUTED AND
C        EXISTS IN DATA( ).  THE FULL IDENTIFICATION IS IN IS1( ),
C        IS2( ), AND IS4( ).  IF IT MAY BE NEEDED FOR THE NEXT
C        VARIABLE AND IS A GRID, THE DATA ARE ALSO IN FDA( ).
C
 204  IF(IER.NE.0)GO TO 300
C        IT IS POSSIBLE THIS POINT COULD BE REACHED WITH MISSING
C        VALUES; HENCE, THE CHECK FOR IER=0 FOR SAFETY.
C
C        MAKE GRID BINARY IF DESIRED.
C        THIS SECTION FOR GRIDPOINT DATA.
C
 205  IF(IDYES.EQ.1)GO TO 206
C        IDYES = 1 INDICATES FULL ID WAS FOUND.  THEREFORE,
C        ADDITIONAL PROCESSING IS NOT NEEDED OR DESIRED.  IF IT
C        WERE DONE, DOUBLE SMOOTHING, FOR INSTANCE, MIGHT BE DONE.
C
      IF(IDPARS(3,N).EQ.5)
     1    CALL GRIDB(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),
     2    DATA,FD1,IS2(3),IS2(4),IER)
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
         GO TO 300
      ENDIF
C
C        SMOOTH FIELD IF DESIRED.
C
      IF(IDPARS(14,N).EQ.0)GO TO 206
C
      IF(IDPARS(14,N).EQ.1)THEN
         CALL SMTH5 (KFILDO,DATA,FD1,IS2(3),IS2(4))
      ELSEIF(IDPARS(14,N).EQ.2)THEN
         CALL SMTH9 (KFILDO,DATA,FD1,IS2(3),IS2(4))
      ELSEIF(IDPARS(14,N).EQ.3)THEN
         CALL SMTH25(KFILDO,DATA,FD1,IS2(3),IS2(4))
      ELSEIF(IDPARS(14,N).EQ.4)THEN
         CALL SMTH2X(KFILDO,DATA,FD1,IS2(3),IS2(4))
      ELSEIF(IDPARS(14,N).EQ.5)THEN
         CALL SMTH3X(KFILDO,DATA,FD1,IS2(3),IS2(4))
      ENDIF
C
C        PRINT GRIDPOINT VALUES IF DESIRED.  TRY TO MATCH PRECISION
C        OF PRINTING TO SIZE OF VALUES THROUGH ISCALD( ).  WHILE
C        THE LOOP IS INEFFICIENT, IT WILL BE EXECUTED VERY RARELY.
C
 206  IF(IP13.EQ.0)GO TO 210
      IF(JP(1,N).EQ.0)GO TO 210
      WRITE(IP13,207)(ID(J,N),J=1,4),NDATE
 207  FORMAT(/' GRIDPOINT VALUES FOR VARIABLE',I11.9,3I11,
     1        ' FOR DATE',I12/)
C
      DO 209 JY=1,IS2(4)
C
      IF(ISCALD(N).LE.-1)THEN
         WRITE(IP13,208)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 208     FORMAT(' ',10F10.1/(' ',10F10.1))
      ELSEIF(ISCALD(N).EQ.0)THEN
         WRITE(IP13,2080)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2080    FORMAT(' ',10F10.2/(' ',10F10.2))
      ELSEIF(ISCALD(N).EQ.1)THEN
         WRITE(IP13,2081)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2081    FORMAT(' ',10F10.3/(' ',10F10.3))
      ELSEIF(ISCALD(N).EQ.2)THEN
         WRITE(IP13,2082)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2082    FORMAT(' ',10F10.4/(' ',10F10.4))
      ELSE
         WRITE(IP13,2083)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2083    FORMAT(' ',10F10.5/(' ',10F10.5))
      ENDIF
C
 209  CONTINUE
C
C        GRIDPRINT FIELD IF DESIRED.
C
 210  IF(IP14.EQ.0)GO TO 215
      IF(JP(2,N).EQ.0)GO TO 215
C
      CALL PREDX1(KFILDO,IDPARS(1,N),THRESH(N),
     1            SMULT(N),SADD(N),ORIGIN(N),CINT(N),
     2            PLAIN(N),UNITS(N),NDATE,-IDPARS(9,N),DATA,ND5,
     3            IS2,ND7,IP14,ISTOP(1),IER)
C        PREDX1 ALWAYS RETURNS IER = 0, EXCEPT FOR A PROBLEM
C        WITH GRIDPRINTING.  THIS DOES NOT CAUSE MISSING DATA.
C
C        PACK AND WRITE THE GRIDPOINT FIELD.  IT IS POSSIBLE SOME
C        GRIDS WILL HAVE PRIMARY MISSINT VALUES (E.G., CEILING
C        HEIGHT FOR LAMP).
C
 215  XMISSP=9999.
      XMISSS=0.
C
C        SEQUENTIAL GRIDDED OUTPUT
C
      IF(KFILGO.NE.0) THEN
         ID(4,N)=0
         CALL PACKG(KFILDO,KFILGO,ID(1,N),IDPARS(1,N),
     1              ISCALD(N),0,NGRIDC(1,NSLAB),
     2              IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3              FD1,DATA,ND2X3,IS2(3),IS2(4),IPACK,IWORK,ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              NWORDS,NTOTBG,NTOTRG,
     6              L3264B,L3264W,ISTOP(1),IER)
C
           IF((((IDPARS(4,N).EQ.62).OR.(IDPARS(4,N).EQ.63))).AND.
     2      ((IDPARS(2,N).EQ.301).OR.(IDPARS(2,N).EQ.351).OR.
     3      (IDPARS(2,N).EQ.361)))THEN
            DO 216 K=1,NCDF
            ID(2,N)=CDFTABLE(K)
            ID(4,N)=000
                CALL PACKG(KFILDO,KFILGO,ID(1,N),IDPARS(1,N),
     1              ISCALD(N),0,NGRIDC(1,NSLAB),
     2              IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3              FD1,DATACDF(1,K),ND2X3,IS2(3),IS2(4),IPACK,IWORK,
     3              ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              NWORDS,NTOTBG,NTOTRG,
     6              L3264B,L3264W,ISTOP(1),IER)
 216        CONTINUE 
           ENDIF
      ENDIF
C
C        RANDOM ACCESS GRIDDED OUTPUT.  WRITE ONLY TO UNIT 42.
C
      DO 220 JJ=1,NUMRA
         IF(KFILRA(JJ).EQ.42) THEN
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C	WE NEED TO USE IDPARS(6,) AND IDPARS(7,) INSTEAD OF ID(2)
C	OTHERWISE THE HIGHEST PROBABILITY WILL BE WRITTEN INSTEAD
C       OF THE HEIGHT FOR ENSEMBLE MEAN PRODUCTS
         ID(2,N)=IDPARS(6,N)*10000+IDPARS(7,N)
         ID(4,N)=0
            CALL PACKGR_OPER(KFILDO,KFILRA(JJ),RACESS(JJ),ID(1,N),
     +                       IDPARS(1,N),
     1                       ISCALD(N),0,NGRIDC(1,NSLAB),
     2                       IPLAIN(1,1,N),PLAIN(N),
     3                       NDATE,NYR,NMO,NDA,NHR,
     4                       FD1,DATA,ND2X3,IS2(3),IS2(4),IPACK,IWORK,
     5                       ND5,
     6                       MINPK,IS0,IS1,IS2,IS4,ND7,
     7                       XMISSP,XMISSS,NWORDS,NTOTGB,NTOTGR,
     8                       L3264B,L3264W,ISTOP(1),IER)
C
           IF((((IDPARS(4,N).EQ.62).OR.(IDPARS(4,N).EQ.63))).AND.
     1      ((IDPARS(2,N).EQ.301).OR.(IDPARS(2,N).EQ.351).OR.
     2      (IDPARS(2,N).EQ.361)))THEN
            DO 222 K=1,NCDF
            ID(2,N)=CDFTABLE(K)
            ID(4,N)=000
            CALL PACKGR_OPER(KFILDO,KFILRA(JJ),RACESS(JJ),ID(1,N),
     +                       IDPARS(1,N),
     1                       ISCALD(N),0,NGRIDC(1,NSLAB),
     2                       IPLAIN(1,1,N),PLAIN(N),
     3                       NDATE,NYR,NMO,NDA,NHR,
     4                       FD1,DATACDF(1,K),ND2X3,IS2(3),IS2(4),
     5                       IPACK,IWORK,ND5,
     6                       MINPK,IS0,IS1,IS2,IS4,ND7,
     7                       XMISSP,XMISSS,NWORDS,NTOTGB,NTOTGR,
     8                       L3264B,L3264W,ISTOP(1),IER)
 222        CONTINUE 
           ENDIF
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
         ENDIF
         GO TO 225
 220  CONTINUE
C
C        NOTE THAT GRIDPOINT DATA TO PACK ARE IN DATA( ).
C
 225  GO TO 390
C
C        THIS SECTION FOR VECTOR DATA.
C
 300  DO 310 K=1,NSTA
      SDATA(K)=9999.
 310  CONTINUE
C
C        SET XMISSP AND XMISSS.  NOTE THAT ANY VALUES OF 9997
C        IN VECTOR DATA HAVE BEEN SET TO PXMISS IN RDSTR2.
C        9997 IS NOT EXPECTED OR DEALT WITH IN GRIDPOINT DATA.
C        OPTION SHOULD NOT RETURN 9997 UNLESS IT IS DESIRED
C        TO LEAVE THOSE VALUES IN THE OUTPUT.
C
 350  CALL SETMIS(KFILDO,SDATA,NSTA,XMISSP,XMISSS)
C
C        PACK AND WRITE THE DATA.
C
      CALL PACKV(KFILDO,KFILIO,ID(1,N),IDPARS(1,N),JP(1,N),ISCALD(N),0,
     1           IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,CCALL,
     2           ISDATA,SDATA,ND1,NSTA,IPACK,ND5,MINPK,
     3           IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     4           IP15,NWORDS,NTOTBY,NTOTRC,
     5           L3264B,L3264W,ISTOP(1),IER)
C        NOTE THAT VECTOR DATA TO PACK ARE IN SDATA( ).
C
 390  CONTINUE
C***D     WRITE(KFILDO,391)N,(ID(J,N),J=1,4),
C***D    1                 ISTAV(N),ISTOP(1),ISTOP(2),IFIND(N),IER
C***D391  FORMAT(/' AT 391 IN PRED23--N,(ID(J,N),J=1,4),',
C***D    1                'ISTAV(N),ISTOP(1),ISTOP(2),IFIND(N),IER',
C***D    2                 /10I10)
 400  CONTINUE
C
C***D     WRITE(KFILDO,405)((MSTORE(I,J),I=1,7),J=1,MITEMS)
C***D405  FORMAT(' MSTORE IN PRED23 AT 405'/(' '7I12))
C
      RETURN
      END
