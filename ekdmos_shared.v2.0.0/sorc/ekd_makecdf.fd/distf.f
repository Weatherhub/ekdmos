      SUBROUTINE DISTF(KFILDO,KFIL10,KFILAO,KFILAI,IP12,IP15,
     1                 KFILRA,RACESS,NUMRA,
     2                 ID,IDPARS,JD,TRESHL,TRESHU,ITAU,NVRBL,
     3                 NDATE,CCALL,ISDATA,SDATA,ND1,NSTA,
     4                 XDATA,SDDATA,ND2,KER,ISD,SD,DS,NN,M,
     5                 ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     6                 LSTORE,ND9,LITEMS,CORE,ND10,
     7                 NBLOCK,NFETCH,MODRUN,
     8                 IS0,IS1,IS2,IS4,ND7,
     9                 XAXIS,PDF,CDF,ND11,NPCDF,CDFTH,XCDF,NCDFTH,
     A                 L3264B,L3264W,ISTOP,IER)
C
C        FEBRUARY  2007   GLAHN   TDL   MOS-2000
C        APRIL     2007   GLAHN   CHANGED DD=79 TO DD=76 FOR OUTPUT
C                                 WHEN MORE THAN ONE ENSEMBLE IS USED
C                                 MODIFIED FORMAT 204; TWO FORMAT NOS
C        APRIL     2007   GLAHN   ACCOMMODATED IER = 778 FROM KERNEL
C        MAY       2007   GLAHN   TESTED FOR DIVISION BY 0 IN DO 220;
C                                 IMPROVED DIAGNOSTIC AT 207
C        MAY       2007   GLAHN   ADDED ISD( ) = 2 OPTION
C        JULY      2007   GLAHN   ADDED FAC CAPABILITY; CALL TO 
C                                 SCALE3; FAC IN CALL TO KERNEL
C        JULY      2007   GLAHN   IF(ISD(NN).EQ.0) CHANGED TO
C                                 IF(ISD(NN).EQ.1) ABOVE 2145
C        JULY      2007   GLAHN   ADDED OPTX CAPABILITY; REMOVED
C                                 NWHERE( ) FROM DIMENSION
C        AUGUST    2007   GLAHN   ADDED DIAGNOSTIC AT DO 250
C        AUGUST    2007   GLAHN   ADDED FAC CAPABILITY TO KERNELW CALL
C        SEPTEMBER 2007   GLAHN   CHANGED DEFINTION OF SD( )
C        DECEMBER  2007   GLAHN   CHANGED M TO MM IN TWO TESTS JUST
C                                 BEFORE KERN=2
C        AUGUST    2008   WAGNER      MODIFIED CODE BY REMOVING CALLS TO 
C                                     KERNEL AND SCALE3 SO CODE COULD
C                                     RUN IN PARALLEL.
C        AUGUST    2008   WIEDENFELD  MODIFIED SYNTAX WHEN FETCHING SD'S.  SD'S 
C                                     DO NOT GET POST-PROCESSED.
C        SEPTEMBER 2008   WIEDENFELD  MODIFIED THE SIZE OF THE STANDARD
C                                     DEVIATION TO BE 12 INSTEAD OF 9.
C        SEPTEMBER 2008   WIEDENFELD  CLEANED UP COMMENTS. UNCOMMENTED
C                                     GOTO 250. ADDED FDS AND N TO PRIVATE
C                                     LIST FOR PARALLEL PROCESSING.  MODIFIED
C                                     DIMENSIONS OF SDATA, RDATA, TDATA, TSD 
C                                     BE ND2 INSTEAD OF ND1.
C        OCTOBER   2008   WIEDENFELD  MODIFIED CODE TO GOTO 250 WHEN 
C                                     NPCDF IS GT ND11. ISTOP(3) IS INCREMENTED.
C        APRIL     2010   GLAHN       MODS FOR MULTIPLE MODELS; SPELL CHECK
C        DECEMBER  2010   WAGNER      ADDED XLOW TO PREVENT DIVIDING BY ZERO
C				      WHEN YOU HAVE A BIMODAL ARRAY AND THE 
C                                     PROBABILITY AT THE MEDIAN IS ZERO.
C        DECEMBER  2010   VEENHUIS    RESOLVED DISCREPANCIES BETWEEN SEVERAL
C                                     DIFFERENT VERSION OF THIS CODE. AS OF
C                                     12/03/2010 THIS IS THE MOST RECENT
C                                     VERSION.
C        FEBRUARY  2011   VEENHUIS    MODIFIED TO USE THE PRECOMPUTED
C                                     SPREAD SKILL RELATIONSHIP FROM U714.
C                                     ADDED KFILAI TO INPUT CALL LIST.
C                                     REMOVED ORIGINAL SPREAD ADJUSTMENT CODE.
C                                     ADDED NEW CODE TO SCALE THE STDDEV OF THE
C                                     FINAL PDF.
C        FEBRUARY 2011    VEENHUIS    MODFIED CALL LIST FOR RDSPSK. ADDED
C                                     NEW ARRAYS.
C        FEBRUARY 2011    VEENHUIS    ADDED ND5 TO CALL TO RDSPSK.
C        MARCH    2011    VEENHUIS    ADDED NDATE TO CALL TO RDSPSK.
C        APRIL    2011    WAGNER      ADDED MODRUN.
C        APRIL    2011    VEENHUIS    ADDED XSUM,XSUM2,XSRAW,XMEAN,AND,XMEMSP
C                                     TO PRIVATE OMP DECLARATION.
C        MAY      2011    VEENHUIS    MODIFIED TO RETURN THE ACTUAL STANDARD
C                                     DEVIATION OF THE FINAL FORECAST PDF.  
C        NOVEMBER 2011    WAGNER      ADDED AVGSD TO DETERMINE THE PRECISION
C                                     OF THE PDF.  REMOVED UNNEEDED CODE.
C                                     REPLACED FAC FROM PREDICTOR LIST WITH THE
C                                     RATIO OF THE AVERAGE STDDEV FROM THE 
C                                     REGRESSION TO THE STDDEV OF THE RAW PDF.
C        MAY      2012    WAGNER      REMOVED "-1" FROM FINC WHEN AVGSD EXCEEDS
C                                     12.
C        JANUARY  2014    WAGNER      ADDED MODRUN
C        MAY      2014    WAGNER      MERGED VERSIONS OF DISTF TO USE
C                                     LATEST VERSION OF SPREAD-SKILL
C
C        PURPOSE
C            DISTF IS CALLED FROM OPTY AND COMPUTES A DISTRIBUTION
C            FUNCTION FROM SEVERAL DIFFERENT SOURCES.
C   
C        DATA SET USE 
C            KFILDO    - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10    - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM
C                        ACCESS.  (INPUT-OUTPUT) 
C            KFILAO    - UNIT NUMBER OF ASCII OUTPUT FILE.  ZERO MEANS
C                        OUTPUT WILL NOT BE WRITTEN.  (OUTPUT)
C            IP12      - LIST OF STATIONS ON THE INPUT FILES.  (OUTPUT)
C            IP15      - LIST OF DATA IN DIST.  (OUTPUT)
C            KFILRA(J) - UNIT NUMBERS FOR EXTERNAL RANDOM ACCESS FILES
C                        (J=1,5).  (INPUT)
C 
C        VARIABLES 
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              KFILAO = UNIT NUMBER OF ASCII OUTPUT FILE.
C                       ZERO MEANS OUTPUT WILL NOT BE WRITTEN.  (INPUT)
C                IP12 = INDICATES WHETHER (>0) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE EXTERNAL RANDOM ACCESS FILES
C                       WILL BE LISTED TO UNIT IP12.  (INPUT)
C                IP15 = LIST OF DATA IN DIST.  (INPUT)
C           KFILRA(J) = THE UNIT NUMBERS FOR THE MOS-2000 EXTERNAL
C                       RANDOM ACCESS FILES (J=1,NUMRA)
C           RACESS(J) = THE FILE NAME FOR THE MOS-2000 EXTERNAL RANDOM
C                       ACCESS FILE (J=1,NUMRA).  (CHARACTER*60)
C               NUMRA = THE NUMBER OF VALUES IN KFILRA( ) AND RACESS( ).
C                       (INPUT)
C             ID(J,N) = THE VARIABLE ID (J=1,4) (N=1,NVRBL).  (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE
C                       VARIABLE ID CORRESPONDING TO ID( ) (J=1,15)
C                       (N=1,NVRBL).
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY
C                            1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK
C                            IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C                       (INPUT)
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID (J=1,4)
C                       (N=1,NVRBL).  THIS IS THE SAME AS ID(J), EXCEPT
C                       THAT THE FOLLOWING PORTIONS ARE OMITTED:
C                       B = IDPARS(3),
C                       G = IDPARS(15), AND
C                       THRESH.
C                       (INPUT)
C           TRESHL(N) = THE LOWER BINARY THRESHOLD ASSOCIATED WITH 
C                       IDPARS( ,N) (N=1,NVRBL).  (INPUT)
C           TRESHU(N) = THE UPPER BINARY THRESHOLD ASSOCIATED WITH
C                       IDPARS( ,N) (N=1,NVRBL).  (INPUT)
C             ITAU(N) = THE NUMBER OF HOURS AHEAD TO FIND A VARIABLE
C                       (N=1,NVRBL).  THIS DOES NOT APPLY TO ALL
C                       SUBROUTINES.  NO PRESENT USE; SHOULD BE ZERO.
C                       (INPUT)
C               NVRBL = THE NUMBER OF VARIABLES IN ID( , ), ETC.
C                       (INPUT)
C              MODRUN - USED TO SET THE OUTPUT DD. READ FROM CONTROL FILE.
C               NDATE = THE DATE/TIME FOR WHICH VARIABLE IS NEEDED.
C                       (INPUT)
C            CCALL(K) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (K=1,NSTA).  ALL STATION DATA ARE
C                       KEYED TO THIS LIST.  (CHARACTER*8)  (INPUT)
C           ISDATA(K) = WORK ARRAY (K=1,ND1). (INTERNAL)
C            SDATA(K) = WORK ARRAY (K=1,ND1).  (INTERNAL)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT
C                       WITH.  (INPUT)
C                NSTA = NUMBER OF STATIONS OR LOCATIONS BEING DEALT
C                       WITH.  (INPUT)
C          XDATA(K,L) = THE ARRAY USED FOR VECTOR VALUES (K=1,ND1) 
C                       (L=1,ND2).  THE COLUMNS HOLD THE VALUES FOR
C                       THE M MEMBERS (SEE M BELOW).
C                       (INTERNAL/OUTPUT)
C         SDDATA(K,L) = USED FOR THE STANDARD ERRORS (K=1,ND1)
C                       (L=1,ND2).  THE COLUMNS HOLD THE SD'S FOR THE
C                       M MEMBERS (SEE M BELOW).  (INTERNAL/OUTPUT)
C                 ND2 = MAXIMUM NUMBER OF ENSEMBLE MEMBERS.  (INPUT)
C              KER(N) = DESIGNATES THE KERNEL TO BE USED FOR VARIABLE N
C                       (N=1,ND4).
C                       1 = NORMAL (GAUSIAN).
C                       (INPUT)
C              ISD(N) = DESIGNATES WHETHER THE KERNEL WIDTH FOR
C                       VARIABLE N (N=1,ND4) IS TO BE TAKEN FROM SD( )
C                       IN THE VARIABLE RECORD OR FROM A PACKED INPUT
C                       RECORD.
C                       0 = COMES FROM PACKED RECORD;
C                       2 = WHEN THERE ARE MULTIPLE ENSEMBLES OR
C                           ONLY ONE ENSEMBLE AND SD( ) > 9, 
C                           CALL KERNELW; OTHERWISE, CALL KERNEL.
C                       3 = CALL SUBROUTINE SCALE3 TO SCALE THE
C                           DISPERSION OF THE KERNEL DENSITY OUTPUT
C                           TO APPROXIMATELY WHAT IT WOULD HAVE BEEN
C                           WITH A SINGLE RUN.
C                       (INPUT)
C               SD(N) = A FACTOR TO USE IN THE SPREAD ADJUSTMENT FOR
C                       MULTIPLE ENSEMBLES FOR THIS VARIABLE N
C                       (N=1,ND4).  (INPUT)
C               DS(N) = SCALING FACTOR FOR THE STANDARD DEVIATION FOR
C                       THIS VARIABLE (N=1,ND4).  (INPUT)      
C                  NN = ON INPUT, THE FIRST VARIABLE IN THE ID LIST NOT
C                       ALREADY USED.  THIS IS THE VARIABLE TO PROCESS.
C                       ON OUTPUT, THE FIRST VARIABLE IN THE ID LIST NOT
C                       USED.  WHEN ALL VARIABLES HAVE BEEN PROCESSED,
C                       NN IS RETURNED = 9999.  (INPUT/OUTPUT)
C                   M = THE NUMBER OF MEMBERS AVERAGED IN DISTF.
C                       (OUTPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN 
C                       INTEGER VARIABLE (L=1,L3264W) (K=1,ND1).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       NEEDED IN CONST FOR ARGUMENT TO RDTDLM.
C                       EQUIVALENCED TO CCALLD( ).
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5).  EQUIVALENCED
C                       TO ICALLD( , ).  (INTERNAL)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), WORK( ), DATA( ), AND
C                       CALLD( ), AND SECOND DIMENSION OF ICALLD( , ).
C                       (INPUT)
C         LSTORE(L,J) = THE ARRAY TO HOLD INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.  NOTE THAT WHEN A FIELD 
C                              CANNOT BE STORED IN CORE( ), IT IS PUT
C                              ON DISK.  IT MAY BE THAT A LATER FIELD 
C                              WILL FIT, AND IT IS PUT IN CORE( ).
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDLPACK, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --THE NUMBER IN THE LIST OF INPUT SOURCES
C                              THIS VARIABLE CAME FROM.
C                       L=11 --FOR U715, THIS WILL BE 7777, INDICATING
C                              THE VARIABLE IS ALWAYS STORED IN THE
C                              INTERNAL STORAGE FACILITY.
C                       L=12 --MINUS THE NUMBER OF HOURS THIS VARIABLE
C                              MUST BE KEPT.  LATER SET TO A DATE WHEN
C                              THIS VARIABLE CAN BE DISCARDED.
C                       (INPUT)
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , )
C                       FILLED.  (INPUT)
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA
C                       IDENTIFIED IN LSTORE( , ) (J=1,ND10).  WHEN
C                       CORE( ) IS FULL DATA ARE STORED ON DISK.
C                       (INPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.
C                       GFETCH KEEPS TRACK OF THIS AND RETURNS THE
C                       VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).
C                       (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).
C                       (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).
C                       (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4). 
C                       (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C            XAXIS(J) = THE DATA VALUES ALONG THE X-AXIS, EACH
C                       VALUE CORRESPONDING TO A VALUE IN PDF(J) AND
C                       CDF(J) (J=1,NPCDF).  (OUTPUT) 
C              PDF(J) = THE PDF WRITTEN TO UNIT KFILAO (J=1,NPCDF).
C                       (OUTPUT)
C              CDF(J) = THE CDF WRITTEN TO UNIT KFILAO (J=1,NPCDF).
C                       (OUTPUT) 
C                ND11 = THE MAXIMUM NUMBER OF VALUES IN XAXIS( ),
C                       PDF( ), AND CDF( ).  (INPUT)
C               NPCDF = THE NUMBER OF VALUES IN PDF( ), CDF( ), AND
C                       XAXIS( ).  (OUTPUT)
C            CDFTH(J) = THE THRESHOLDS, OR PROBABILITY LEVELS, FOR
C                       OUTPUTTING THE CDF VALUES (J=1,NCDFTH).
C                       (INPUT)
C           XCDF(K,J) = THE VALUES FOR STATION K (K=1,NSTA) OF THE CDF
C                       FOR EACH OF THE LEVELS IN CDFTH(J) (J=1,NCDFTH)
C                       (OUTPUT)
C              NCDFTH = NUMBER OF VALUES IN CDFTH( ) AND XCDF( ).
C                       (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  
C                       CALCULATED BY PARAMETER, BASED ON L3464B.
C                       (INPUT)
C            ISTOP(J) = FOR J=1, ISTOP IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT MAY BE FATAL.
C                       FOR J=2, ISTOP IS INCREMENTED BY 1 WHENEVER AN
C                       INPUT DATA RECORD IS NOT FOUND.
C                       FOR J=3, ISTOP IS INCREMENTED BY 1 WHENEVER AN
C                       AN UNUSUAL CIRCUMSTANCE OCCURS WHICH IS NOT FATAL.
C                       (INPUT/OUTPUT)
C                 IER = STATUS RETURN.
C                         0 = GOOD RETURN.
C                       777 = SD = 0.
C                       OTHER VALUES CAN COME FROM CALLED SUBROUTINES.
C                       (OUTPUT)
C               MDATE = NDATE UPDATED WITH ITAU( ).  NO REASON FOR
C                       ITAU( ) TO BE OTHER THAN ZERO.  NEEDED FOR 
C                       RETVEC.  (INTERNAL)
C            RDATA(J) = HOLDS THE SINGLE VALUE FORECASTS TO FURNISH
C                       TO KERNEL (J=1,ND1).  (AUTOMATIC)  (INTERNAL)
C                  MM = THE NUMBER OF VALUES IN RDATA( ) AND SDATA( ).
C                       THIS IS THE NUMBER OF ENSEMBLES BEING 
C                       PROCESSED.  (INTERNAL)
C                KERN = DETERMINES HOW THE PDF WILL BE ASSESSED
C                       1=TENTHS OF A DEGREE
C                       2=WHOLE DEGREES (INTERNAL)
C                 DIF = WIDTH OF THE BIN IN THE CDF (INTERNAL)
C              NSTART = STARTING POSITION OF THE CDF (INTERNAL)
C                 TID = ID ASSOCIATED WITH THE PARALLEL PROCESS
C                       (INTERNAL)
C                RMAX = THE MAXIMUM VALUE OF RDATA() (INTERNAL)
C                RMIN = THE MINIMUM VALUE OF RDATA() (INTERNAL)
C                SMAX = THE MAXIMUM VALUE OF SDATA() (INTERNAL)
C                SMIN = THE MINIMUM VALUE OF SDATA() (INTERNAL)
C                 FAC = THE XAXIS IN XASIS( ) WILL BE MODIFIED BY
C                       THE FACTOR FAC.  THIS IS TO CORRECT FOR
C                       OVERDISPERSION.  IT COULD BE USED FOR
C                       UNDERDISPERSION IF NEEDED.  (INTERNAL)
C             FMAXVAL = MAXIMUM XAXIS VALUE USED WHEN CALCULATING THE
C                       KERNELS (INTERNAL)
C             FMINVAL = MINIMUM XAXIS VALUE USED WHEN CALCULATING THE
C                       KERNELS (INTERNAL)
C                RFAC = USED TO PRESERVE THE TENTHS DIGIT WHEN NECESSARY
C                       (INTERNAL)
C            TDATA(J) = ARRAY TO HOLD THE ENSEMBLE VALUES (INTERNAL)
C              TSD(J) = ARRAY TO HOLD THE STANDARD DEVIATIONS (INTERNAL)
C                 LOC = CURRENT LOCATION OF THE PDF (INTERNAL)
C              FACTOR = THE CONSTANT MULTIPLIER FOR THE NORMAL DENSITY.
C                       FOR THIS BASIC DENSITY, THE NUMBER OF CASES IS  
C                       NOT RELEVANT. (INTERNAL)
C            TWOSIGSQ = THE DIVISION IN THE EXPONENT FOR THE NORMAL
C                       DENSITY (INTERNAL)
C                 TOT = SUMMATION OF THE PDF (INTERNAL)
C                TOT2 = HALF THE SUMMATION OF THE PDF (INTERNAL)
C                CMED = PERCENT MEDIAN OF THE PDF (INTERNAL)
C              TOTJM1 = PROBABILITY AT THE MEDIAN OF THE PDF
C                       (INTERNAL)
C                 X50 = XAXIS LOCATION OF THE MEAN OF THE PDF
C                       (INTERNAL)
C                XMED = XAXIS LOCATION OF THE MEDIAN OF THE PDF
C                       (INTERNAL)
C       CCALLSP(XXXX) = LIST OF STATIONS THAT HAVE A VALID SPREAD-
C                       SKILL RELATIONSHIP (INTERNAL)
C          XMIN(XXXX) = THE MINIMUM ENSEMBLE STANDARD DEVIATION USED
C                       FOR A STATION (INTERNAL)
C          XMAX(XXXX) = THE MAXIMUM ENSEMBLE STANDARD DEVIATION USED
C                       FOR A STATION (INTERNAL)
C           XB0(XXXX) = THE CONSTANT VALUE USED FOR THE SPREAD-
C                       SKILL RELATIONSHIP (INTERNAL)
C           XB1(XXXX) = THE SLOPE USED FOR THE SPREAD-SKILL
C                       RELATIONSHIP (INTERNAL)
C OMP_GET_NUM_THREADS = USED TO GET THE NUMBER OF PARALLEL THREADS
C                       BEING USED (INTERNAL)
C  OMP_GET_THREAD_NUM = RETURNS THE CURRENT PARALLEL THREAD NUMBER
C                       (INTERNAL)
C            NTHREADS = THE NUMBER OF PARALLEL THREADS (INTERNAL)
C 
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES USED 
C            TIMPR, PRSID1, RETVEC
C
      CHARACTER*8 CCALL(ND1)
      CHARACTER*8 CCALLD(ND5)
      CHARACTER*60 RACESS(5)
      CHARACTER*8 CCALLSP(ND1)
      INTEGER TID, OMP_GET_NUM_THREADS,NTHREADS, OMP_GET_THREAD_NUM
C
      DIMENSION ISDATA(ND1),SDATA(ND2)
      DIMENSION RDATA(ND2)
C        RDATA( ), TDATA ( ), AND TSD( ) ARE AUTOMATIC ARRAYS.
      DIMENSION XDATA(ND1,ND2),SDDATA(ND1,ND2)
      DIMENSION TDATA(ND2),TSD(ND2)
      DIMENSION ID(4,NVRBL),IDPARS(15,NVRBL),
     1          TRESHL(NVRBL),TRESHU(NVRBL),JD(4,NVRBL),ITAU(NVRBL),
     2          KER(NVRBL),ISD(NVRBL),SD(NVRBL),DS(NVRBL)
      DIMENSION ICALLD(L3264W,ND5),IPACK(ND5),IWORK(ND5),DATA(ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9)
      DIMENSION CORE(ND10)
      DIMENSION CDFTH(NCDFTH),XCDF(ND1,NCDFTH)
      DIMENSION XAXIS(ND11),PDF(ND11),CDF(ND11)
      DIMENSION KFILRA(5),LD(4),LDPARS(15),ISTOP(3)
      DIMENSION XMIN(3000),XMAX(3000),XB0(3000),XB1(3000)
C
      DATA JFIRST/0/
      SAVE JFIRST,NDATES
C        NDATE IS SAVED IN NDATES ON THE FIRST ENTRY SO THAT
C        DIAGNOSTIC 212 WON'T PRINT AFTER THE FIRST DAY.
C
      XTRANS=0
      KK=0
      KFOUND=0
      IF(JFIRST.EQ.0)THEN
         NDATES=NDATE
         JFIRST=1
      ENDIF
C
C        GET SINGLE VALUE ESTIMATES AND THE STANDARD DEVIATION FOR
C        EACH ENSEMBLE MEMBER (DENOTED BY DD).  THIS CAN BE A SINGLE
C        RUN WITH OR WITHOUT AN ACCOMPANYING STANDARD DEVIATION
C        PACKED RECORD.
C
D     CALL TIMPR(KFILDO,KFILDO,'START DISTF         ')
C
      IER=0
      IFIRST=0
      NNSAVE=9999
C        INITIALIZE NSAVE IN CASE ALL DATA RETRIEVES ARE SUCCESSFUL.
      M=1
C        M IS THE COLUMN IN XDATA( , ) TO RETRIEVE THE DATA.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C        ATTEMPT TO RETRIEVE THE SPREAD SKILL RELATIONSHIP FROM THE
C        ASCII FILE ON KFILAI. IF THE ID CANNOT BE LOCATED THE CODE
C        WILL PROCEED BUT USE THE SPREAD FACTOR TAKEN FROM THE ID
C        INPUT FILE.
C
      LD(1)=(ID(1,NN)/100)*100+MODRUN
      LD(2)=ID(2,NN)
      LD(3)=ID(3,NN)
      LD(4)=ID(4,NN)
C
      NCALLSP=0
      IERSP=99
      CALL RDSSK9(KFILDO,KFILAI,NDATE,LD,CCALLSP,XB0,XB1,
     1            XMIN,XMAX,ND5,NCALLSP,IERSP)
C
      IF(IERSP.NE.0) THEN
        WRITE(KFILDO,100) LD(1:4)
 100    FORMAT(/,'**** IN SUBROUTINE DISTF: DID NOT FIND SPREAD-',
     1          'SKILL REALATIONSHIP',/,'**** FOR ID',4(X,I9),/,
     2          '**** THE STANARD ERROR FROM THE REGRESSION EQ',
     3          ' WILL BE USED.')  
        ISTOP=ISTOP+1
      ENDIF
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      DO 200 N=NN,NVRBL
C        NVRBL IS THE NUMBER OF VALUES IN THE ID( , ) LIST.
C        NN IS THE LOCATION OF THE FIRST ONE NOT USED.
      MDATE=NDATE+ITAU(N)
C        I KNOW OF NO CURRENT USE FOR TAU NE 0, BUT IS CARRIED ALONG.
C
C        CHECK FOR KERNEL USED.  ONLY NORMAL IMPLEMENTED.
C
      IF(KER(NN).NE.1)THEN
         WRITE(KFILDO,107)KER(NN),(ID(J,NN),J=1,4)
 107     FORMAT(/,' ****KER( ) =',I4,' NE 1',
     1            ' FOR VARIABLE',
     2             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3            ' CHANGING IT TO 1.',/,
     4            '     ONLY THE NORMAL IS IMPLEMENTED.  PROCEEDING.')
         KER(NN)=1
         ISTOP(3)=ISTOP(3)+1
      ENDIF
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C        GET THE SINGLE VALUE FORECAST AND ITS ASSOCIATED
C        STANDARD DEVIATION FOR IDS THAT ARE THE SAME
C        EXCEPT FOR THE DD AND G.
C    
      IF(ID(1,NN)/100.EQ.ID(1,N)/100.AND.
     1   ID(2,NN).EQ.ID(2,N).AND.
     2   IDPARS(8,NN).EQ.IDPARS(8,N).AND.
     3   IDPARS(10,NN).EQ.IDPARS(10,N).AND.
     4   IDPARS(11,NN).EQ.IDPARS(11,N).AND.
     5   IDPARS(12,NN)-IDPARS(9,NN).EQ.IDPARS(12,N)-IDPARS(9,N).AND.
     6   ID(4,NN)/10.EQ.ID(4,N)/10)THEN
C
C           THE ID OF VARIABLE N AGREES WITH THAT OF THE BASE VARIABLE
C           NN, EXCEPT DD, R, TAU, AND G.  THE TEST ASSURES THAT THE
C           DATES AND PROJECTIONS ARE SUCH THAT THE FORECASTS VERIFY
C           AT THE SAME TIME.  NORMALLY, IDPARS(9,NN) WILL BE ZERO.
C
C           RETRIEVE THE SINGLE VALUE FORECASTS.
C
         LD(1)=ID(1,N)
         LD(2)=ID(2,N)
         LD(3)=ID(3,N)
         LD(4)=ID(4,N)
         CALL PRSID1(KFILDO,LD,LDPARS)
         ITIME=IDPARS(9,N)
C           ITIME IS USED IN GFETCH.  IT IS CALLED ITAU IN RETVEC. 
         CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,XDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,IER)
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,125)(LD(J),J=1,4),NDATE
  125       FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN DISTF',
     1             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
C
C              IF IER IS RETURNED NON-ZERO, THE DATA IN XDATA( ,M)
C              WILL BE SET TO MISSING, BUT THE PROCESS WILL CONTINUE.
C
         ENDIF
C
C           EVEN IF THE VARIABLE IS NOT RETRIEVED, THE STANDARD ERROR
C           RECORD IS TRIED SO THAT MSTORE( , ) CAN BE INITIALIZED 
C           CORRECTLY.
C
C           RETRIEVE THE STANDARD ERRORS.  THE STANDARD ERRORS HAVE
C           THE SAME ID EXCEPT FOR 200 IN THE LLLL PORTION OF WORD 2.
C
         LD(2)=ID(2,N)+002000000
         CALL PRSID1(KFILDO,LD,LDPARS)
         CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,SDDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,JER)
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C           NOTE THAT JER RATHER THAN IER IS USED IN THE CALL.
C
         IF(JER.NE.0)THEN
            WRITE(KFILDO,135)(LD(J),J=1,4),NDATE
  135       FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN DISTF',
     1                2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
C
C              IF IER IS RETURNED NON-ZERO, THE DATA IN XDATA( ,M)
C              WILL BE SET TO MISSING, BUT THE PROCESS WILL CONTINUE.
C
         ENDIF
C 
         IF(IER.EQ.0.AND.JER.EQ.0)THEN
            M=M+1
C           UNLESS BOTH THE SINGLE VALUE FORECAST AND THE STANDARD
C           ERROR CAN BE RETRIEVED, THE DATA ARE NOT SAVED AND THE
C           COLUMN NUMBER IS NOT UPDATED.  THIS ALLOWS THE USE
C           OF LESS THAN THE FULL SET OF EXPECTED ENSEMBLES.
         ENDIF
C
      ELSE
C
         IF(IFIRST.EQ.0)THEN
            NNSAVE=N
C              NNSAVE IS NOW THE FIRST VARIABLE IN THE ID( , ) LIST
C              NOT USED.  LATER, TRANSFER NNSAVE TO NN TO BE USED
C              ON NEXT ENTRY.
            IFIRST=1
         ENDIF
C
      ENDIF
C
 200  CONTINUE
C 
C        ALWAYS DROPS THROUGH HERE.
C
      M=M-1
C        THERE HAVE BEEN M RECORDS RETRIEVED.  EACH HAS THE SAME
C        ID'S EXCEPT THE DD'S AND POSSIBLY THE RR'S AND TAU'S.
C
      IF(M.EQ.0)THEN
C           THIS IS NORMAL WHEN ALL ENSEMBLE MEMBERS HAVE BEEN 
C           RETRIEVED.  HOWEVER, CALLING PROGRAM OUGHT TO NOT
C           BE CALLING IN THIS CASE.
         NN=9999
         GO TO 300
      ELSE
C
         IF(IP15.NE.0)THEN
            WRITE(IP15,202)M,(ID(J,NN),J=1,4),NDATE
 202        FORMAT(/' ',I3,' ENSEMBLE MEMBERS HAVE BEEN RETRIEVED',
     1                ' FOR VARIABLE',
     2                 2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
         ENDIF
C
      ENDIF
C
      IF(IP15.NE.0)THEN
C
         DO 206 K=1,NSTA
            WRITE(IP15,204)CCALL(K),NDATE,(XDATA(K,L),L=1,M)
 204        FORMAT(/' SINGLE VALUE ENSEMBLE FORECASTS FOR STATION ',A8,
     1              '  FOR DATE ',I12,/,('     ',15F8.2))
            WRITE(IP15,205) (SDDATA(K,L),L=1,M)
 205        FORMAT( ' STANDARD ERRORS OF EST',/,
     1            ('     ',15F8.2))
 206     CONTINUE
C
      ENDIF
C
C	LOOP THROUGH EACH STATION IN PARALLEL
C
!$OMP PARALLEL DO 
!$OMP& PRIVATE(K,L,I,MM,NPCDF,RDATA,SDATA,KERN,PDF,CDF)
!$OMP& PRIVATE(XAXIS,LD,LL,DIF,F,ISTOP,NSTART,IER,TID,J)
!$OMP& PRIVATE(RMAX,SMAX,RMIN,SMIN,FAC,FMAXVAL,FMINVAL)
!$OMP& PRIVATE(RFAC,TDATA,TSD,LOC,FACTOR,XLOW)
!$OMP& PRIVATE(TWOSIGSQ,TOT,TOT2,CMED,TOTJM1,P,X50,XMED)
!$OMP& PRIVATE(KK,KFOUND,XSUM,XSUM2,XSRAW,XMEAN,XMEMSP)
!$OMP& PRIVATE(XDX,XTRANS,AVGSD)
C
      DO 250 K=1,NSTA
C
      MM=0
      IER=0
C
      DO 210 L=1,M
         IF(XDATA(K,L).LT.9990..AND.SDDATA(K,L).LT.9990.)THEN
            MM=MM+1
            RDATA(MM)=XDATA(K,L)
            SDATA(MM)=SDDATA(K,L)
            IF(SDATA(MM).GT.12)SDATA(MM)=12.
         ENDIF
C      
 210  CONTINUE
C
C        AT THIS POINT, RDATA( ) AND SDATA( ) CONTAIN MM 
C        NON-MISSING FORECASTS.
C
      IF(MM.EQ.0)THEN
C
         IF(NDATE.EQ.NDATES.AND.IP15.NE.0)THEN
C              THIS DIAGNOSTIC WILL PRINT ON ONLY THE FIRST DAY.
            WRITE(IP15,212)CCALL(K),(ID(J,NN),J=1,4),NDATE
 212        FORMAT(/,' NO FORECASTS FOR STATION ',A8,
     1              ' FOR VARIABLE',
     2                2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3               ' FOR DATE',I12,'.  (PRINT ON DAY 1.)')
C
C              WHEN THERE ARE NO GOOD NON-MISSING FORECASTS
C              FOR STATION K, SET THE XCDF(K,L) VALUES MISSING
C              FOR ALL THRESHOLDS.
         ENDIF
C
         DO 213 L=1,NCDFTH
         XCDF(K,L)=9999.
 213     CONTINUE
C
         GO TO 250
C
      ELSEIF(MM.NE.M)THEN
         WRITE(KFILDO,214)MM,CCALL(K),(ID(J,NN),J=1,4),NDATE
 214     FORMAT(/,' ONLY',I4,' FORECASTS FOR STATION ',A8,
     1            ' FOR VARIABLE',
     2             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3            ' FOR DATE',I12)
      ENDIF
C
C        INITIALIZING KERN AND FAC FOR TENTHS OF A DEGREE 
      KERN=1
      FAC=1.
C
      IF(ISD(NN).EQ.3)THEN
C
C           COMPUTE FAC, THE SPREAD FACTOR TO USE IN KERNEL.
C
C           FIRST INITIALIZE MAX AND MIN VALUES.
C
         RMAX=RDATA(1)
         SMAX=SDATA(1)
         RMIN=RDATA(1)
         SMIN=SDATA(1)
C
C           FIND THE MAXIMA RMAX( ) AND SDMAX( ) AND THE IMA
C           R( ) AND SDMIN( ).
C
         DO 140 L=1,MM
C
         IF(RDATA(L).GT.RMAX)THEN
            RMAX=RDATA(L)
            SMAX=SDATA(L)
         ELSEIF(RDATA(L).LT.RMIN)THEN
            RMIN=RDATA(L)
            SMIN=SDATA(L)
         ENDIF
C
 140     CONTINUE
C
C           THE SPREAD ADJUSTMENT FAC IS A FACTOR OF SD.  WHEN SD = 0,
C           THE SPREAD IS NOT AFFECTED BY THE SPREAD OF THE MEANS.
C           WHEN SD = 1, THERE IS NO SPREAD ADJUSTMENT AT ALL.
C           SD BETWEEN 0 AND 1 GIVES SPREAD ADJUSTMENT AS A CONTINUOUS
C           RANGE.
C
      ENDIF
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      IF(SDATA(MM).GT.12.)THEN
C              THIS HARDWIRED 12 CAN BE CHANGED IF DESIRED.
C              SDATA(MM) IS THE LAST VALUE IN SDATA( ); IT IS
C              USED ONLY FOR SWITCHING, AND ALL VALUES IN
C              SDATA( ) ARE CLOSE TO THE SAME.
C              CHANGED M TO MM 12/2/07; THIS WOULD MAKE A
C              DIFFERENCE ONLY IN CASE OF MISSING DATA.
            KERN=2
      ENDIF
C
      IF(KERN.EQ.1)THEN
         RFAC=10.
C           DEVIATION IN SDATA( ) IN TENTHS OF UNITS FURNISHED ROUNDS
C           TO 0.  A DIAGNOSTIC WILL HAVE BEEN PRINTED IN KERNAL; THE
C           ONE BELOW WILL EXPLAIN WHICH VARIABLE AND STATION.
      ELSE
         RFAC=1.
      ENDIF  
C
C        NOW CREATE KERNEL
C
      FMAXVAL=-9999999
      FMINVAL=+9999999
C
C        CHECK SCALING FACTOR.
C
      IF(DS(NN).EQ.0.)THEN
         WRITE(KFILDO,103)J
 103     FORMAT(/' ****SCALING FACTOR IS INPUT AS ZERO.',
     1           '  ASSUME SCALING OF 1.  PROCEEDING.')
         FDS=1.
         IER=777
      ELSE
         FDS=DS(NN)
      ENDIF
C
C        PUT THE REAL NUMBERS IN DATA( ) INTO TDATA( ) ROUNDED
C        TO TENTHS OF UNITS.
C
      DO 105 J=1,MM
C        IF RFAC=10, IT IS EXPECTED THE DATA IN RDATA( ) ARE TO TENTHS OF
C        UNITS, AND NOTHING IS LOST HERE.  OTHERWISE, TENTHS
C        OF UNITS IS ALL THE PRECISION THAT IS KEPT.
C        IF RFAC=10, THE DATA( ) ARE MULTIPLIED BY 10, SO THE SD'S MUST BE ALSO.
C        THE SD'S ARE SCALED BY DS.
C
      IF(KERN.EQ.1)THEN
         TDATA(J)=NINT(RDATA(J)*RFAC)
         TSD(J)=NINT(FDS*SDATA(J)*RFAC)
      ELSE
         TDATA(J)=RDATA(J)*RFAC
         TSD(J)=FDS*SDATA(J)*RFAC
      ENDIF
C
      IF(TSD(J).LE.0)THEN
         IF(IP15.NE.0)THEN
         WRITE(KFILDO,104)J
 104     FORMAT(/' ****STANDARD DEVIATION OF THE',I4,'TH VALUE',
     1           ' IN TENTHS OF UNITS ROUNDS TO ZERO.',/,
     2           '     ASSUME 1 SCALED UNIT.  PROCEEDING.')
         ENDIF
         TSD(J)=1
         IER=777
      ENDIF
C
 105  CONTINUE
C
C        FIND MAXIMUM AND MINIMUM EXTENTS OF THE FINAL DENSITY.
C        THIS WILL BE THE SMALLEST AND LARGEST TDATA( ) VALUES
C        EACH EXTENDED TO THE LEFT AND RIGHT, RESPECTIVELY,
C        BY 3 TIMES ITS RESPECTIVE TSD( )
C
      DO 120 N=1,MM
C
      IF(TDATA(N)-3*TSD(N).LT.FMINVAL)THEN
         FMINVAL=TDATA(N)-3*TSD(N)
      ENDIF
C
      IF(TDATA(N)+3*TSD(N).GT.FMAXVAL)THEN
         FMAXVAL=TDATA(N)+3*TSD(N)
      ENDIF
C
 120  CONTINUE
C
C        SET THE X-AXIS VALUES.
C        XAXIS( ) IS THE AXIS IN TERMS OF THE INCOG DATA.  THE
C        DATA HAVE BEEN SCALED*10; SCALING MUST BE TAKEN OUT.  THIS
C        COVERS THE RANGE 3 SIGMA BELOW THE IMUM VALUE AND
C        3 SIGMA ABOVE THE MAXIMUM VALUE IN INCREMENTS OF TENTHS
C        OF UNITS OF THE ORIGINAL DATA.
C
      NPCDF=FMAXVAL-FMINVAL+1
C
      IF(NPCDF.GT.ND11)THEN
         WRITE(KFILDO,139)ND11,NPCDF
 139     FORMAT(/,' ****DIMENSION ND11 =',I8,' TOO SMALL TO',
     1            ' COMPUTE CDF( ) IN KERNEL.  INCREASE TO ',I8,
     2            ' OR MORE.  PROCEEDING.')
         DO 1395 L=1,NCDFTH
         XCDF(K,L)=9999.
 1395    CONTINUE
C
         ISTOP(3)=ISTOP(3)+1
         IER=778
C
         GO TO 250
      ENDIF
C
      FINC=(FMAXVAL-FMINVAL)/(NPCDF-1)-1
C
      IF(KERN.EQ.1)THEN
         DO 141 J=1,NPCDF
         IF(KERN.EQ.1)THEN
            XAXIS(J)=(FMINVAL+J-1)/RFAC
         ELSE
            XAXIS(J)=(FMINVAL+J-1)/RFAC
         ENDIF
C        THE X-AXIS WILL COVER 3 STANDARD DEVIATIONS IN TERMS OF
C        TENTHS OF UNITS, LABELED IN WHOLE UNITS, ON EITHER SIDE
C        OF THE MAX AND  VALUE IN DATA( ).
 141     CONTINUE
      ELSE
         XAXIS(1)=FMINVAL
         DO 1415 J=2,NPCDF
         XAXIS(J)=FMINVAL+J-1.+(J-1)*FINC
 1415    CONTINUE
      ENDIF   
C
C        ZERO THE PDF( ) AND CDF( ) ARRAYS.
C
      DO 142 J=1,NPCDF
      PDF(J)=0.
      CDF(J)=0.
 142  CONTINUE
C
C        COMPUTE THE KERNEL OVER THE RANGE MINUS 3 SIGMA
C        TO PLUS 3 SIGMA AROUND EACH VALUE IN TDATA( ).
C
      DO 160 N=1,MM
C
      FACTOR=1./(TSD(N)*SQRT(2.*3.14159))
C        FACTOR IS THE CONSTANT MULTIPLIER FOR THE NORMAL DENSITY.
C        FOR THIS BASIC DENSITY, THE NUMBER OF CASES IS NOT RELEVANT.
      TWOSIGSQ=2.*TSD(N)*TSD(N)
C        TWOSIG IS THE DIVISION IN THE EXPONENT FOR THE NORMAL
C        DENSITY.
C
C        CALCULATE THE KERNEL.
C
      DO 150 J=-NINT(3*TSD(N)),+NINT(3*TSD(N))
C
      LOC=NINT(TDATA(N)-FMINVAL+J+1)
      PDF(LOC)=PDF(LOC)+FACTOR*EXP(-(FLOAT(J*J))/TWOSIGSQ)
C
 150  CONTINUE
C
 160  CONTINUE
C
C
      KK=1
      KFOUND=0
      IF(IERSP.EQ.0) THEN
        DO WHILE(KK.LE.NCALLSP)
          IF(CCALLSP(KK).EQ.CCALL(K)) THEN
            KFOUND=1
            EXIT
          ENDIF
          KK=KK+1
        ENDDO
      ENDIF
C
      XMEAN=SUM(RDATA(1:MM))/(MM*1.)
      XSUM2=SUM(RDATA(1:MM)**2.)/(MM*1.)
      XMEMSP=(XSUM2-XMEAN**2.)**(0.5)
C
C         CALL LETTERS WERE MATCHED WITH A STATION ON THE SPREAD
C         SKILL FILE. USE THAT INFO TO SET THE VALUE OF FAC
C
C         COMPUTE THE STANDARD DEVIATION OF THE RAW PDF. THIS WILL
C         BE USED IN THE CALCULATION OF FAC.
C
        TOT=0.
        XSUM=0.
        XSUM2=0.
        DO J=1,NPCDF
          TOT=TOT+PDF(J)
        ENDDO
        DO J=1,NPCDF
          XSUM=XSUM+XAXIS(J)*PDF(J)/TOT 
          XSUM2=XSUM2+(XAXIS(J)**2.)*PDF(J)/TOT 
        ENDDO
C
C         XSRAW IS THE STDDEV OF THE RAW PDF AFTER KERNEL
C         DENSITY FITTING BUT BEFORE SPREAD ADJUSTMENT.
C
        XSRAW=(XSUM2-(XSUM**2.))**(0.5)
C
C
      IF(KFOUND.EQ.1)THEN

        XMEAN=SUM(RDATA(1:MM))/(MM*1.)
        XSUM2=SUM(RDATA(1:MM)**2.)/(MM*1.)
C
C         XMEMSP IS THE STDDEV OF THE EMSEMBLE MEMBERS
C        
        XMEMSP=(XSUM2-XMEAN**2.)**(0.5)
C
C         TRANSFORM BY TAKING SQRT
C
        XTRANS=(XMEMSP)**(0.5)
C
C         MAKE SURE XTRANS FALLS WITHIN THE VALID RANGE
C
        IF(XTRANS.LT.XMIN(KK))THEN
          XTRANS=XMIN(KK)
        ENDIF 
        IF(XTRANS.GT.XMAX(KK))THEN
          XTRANS=XMAX(KK)
        ENDIF 
C
C         APPLY SPREAD-SKILL 2.0
C
        FAC=(XB0(KK)+XB1(KK)*XTRANS)
        FAC=(.009+1.21*FAC)**2.
        FAC=FAC/XSRAW   
C
      ELSE
C
C       COULD NOT FIND THE STATION/ID COMBO IN THE SPREAD
C       SKILL FILE.  USE REGRESSION ESIMATED KERNEL WIDTH 
C
        AVGSD=SUM(SDATA(1:MM))/(MM*1.)
        FAC=AVGSD/XSRAW
C
      ENDIF
C
C        ADJUST THE DISTRIBUTION BY THE FACTOR FAC.  THIS IS DONE
C        BY MODIFYING THE VALUES IN XAXIS( ).  THIS WILL NOT OVERFLOW
C        ARRAYS UNLESS FAC IS POSITIVE, THEN IT MIGHT.
C
C
      IF(ABS(1.-FAC).GT..001)THEN
C        A FACTOR FAC OF UNITY OR NEARLY SO NEED NOT BE USED.
         TOT=0.
C
         DO 162,J=1,NPCDF
         TOT=TOT+PDF(J)
 162     CONTINUE
C
         TOT2=TOT/2.
         CMED=0.
         XMED=0.
         XLOW=9999.0
C
         DO 164 J=1,NPCDF
         CMED=CMED+PDF(J)
         IF(PDF(J).EQ.0.0.AND.PDF(J-1).NE.0.0)XLOW=XAXIS(J)
C
C
C
         IF(CMED.GE.TOT2.AND.PDF(J-1).GT.0.0)THEN
            CMED=CMED-PDF(J)/2.+.0001
C              FOR A SYMMETRICAL DISTRIBUTION (AS WOULD OCCUR WITH
C              TWO ENSEMBLE MEMBERS WITH THE SAME SD) WITH AN ODD
C              NUMBER OF POINTS ON THE SCALE, THE CENTER POINT
C              VALUE REPRESENTS BOTH HALVES.  THE SMALL ADDITIVE
C              FACTOR IS SO THE CALCULATED MIDDLE WILL STILL BE
C              BETWEEN THE CORRECT POINTS (IT MAY NOT BE NECESSARY).
C              THIS MAY NOT BE EXACTLY CORRECT FOR NON-SYMMETRICAL
C              DISTRIBUTIONS, BUT IS CLOSE ENOUGH.
            TOTJM1=CMED-PDF(J-1)
            IF(CMED.NE.TOTJM1)THEN
               P=(TOT2-TOTJM1)/(CMED-TOTJM1)
C              THE 50 PERCENT MAY NOT FALL EXACTLY ON AN EVEN J.
C              P IS THE FRACTION OF THE WAY THE 50 PERCENT VALUE
C              IS FROM J-1.
            ELSE
C              DROP THROUGH HERE IF THERE IS A GAP BETWEEN ENSEMBLE
C              MEMBERS AND THE PDF VALUE AT THE MEDIAN IS 0.0
               XMED=XAXIS(J)-(XAXIS(J)-XLOW)/2.
               GO TO 165
            ENDIF
            X50=J-1+P
            XMED=XAXIS(J-1)+(XAXIS(J)-XAXIS(J-1))*P
            GO TO 165
         ENDIF
C
 164     CONTINUE
C
 165     CONTINUE
C
C
         DO 167 J=1,NPCDF
         XAXIS(J)=XMED+(XAXIS(J)-XMED)*FAC
C           (XAXIS(J)-XMED) CAN BE PLUS OR MINUS AND DEPART FROM XMED.
C
 167     CONTINUE
C
      ENDIF
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C        NOW COMPUTE THE CDF( ) AND STANDARDIZE THE PDF( ) AND CDF( ).
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      CDF(1)=.0
C        THE AREA BEYOND 3 SIGMA IS IGNORED.
      TOT=0.
C
      DO 180 J=2,NPCDF
      CDF(J)=CDF(J-1)+(PDF(J-1)+PDF(J))/2.
      TOT=TOT+PDF(J)
 180  CONTINUE
C
C
C        NORMALIZE TO AREA = 1 FOR DENSITY.
C
      DO 190 J=1,NPCDF
C         REMOVED A SECOND +1 IN ABOVE 1/11/07.
      PDF(J)=PDF(J)/TOT
      CDF(J)=CDF(J)/TOT
 190  CONTINUE
C
C       CHECK THE FINAL STANDARD DEVIATION
C
      XSUM=0.
      XSUM2=0.
      DO J=1,NPCDF
        XSUM=XSUM+XAXIS(J)*PDF(J)
        XSUM2=XSUM2+(XAXIS(J)**(2.))*PDF(J)
      ENDDO
C
C       PUT THE FINAL STANDARD DEVIATION INTO THE FIRST
C       ELEMENT OF SDDATA
C
      IF(XSUM2.GT.(XSUM**2.))THEN
        SDDATA(K,1)=(XSUM2-XSUM**2.)**(.5)
C         SDDATA(K,1)=XMEMSP
      ELSE
        SDDATA(K,1)=SDATA(1)
C        SDDATA(K,1)=9999.
      ENDIF
C
      IF(IER.EQ.777)THEN
         WRITE(KFILDO,216)(ID(J,NN),J=1,4),CCALL(K)
 216     FORMAT('     VARIABLE ',4I11,' STATION ',A8)
      ELSEIF(IER.EQ.778)THEN
         WRITE(KFILDO,216)(ID(J,NN),J=1,4),CCALL(K)
C
         DO 2166 L=1,NCDFTH
         XCDF(K,L)=9999.
 2166    CONTINUE
C
         GO TO 250
      ENDIF 
C
      IF(KFILAO.NE.0)THEN
C
C           WRITE THE ASCII DATA.  FORM THE ID'S.
C
         LD(1)=ID(1,NN)
C
         IF(M.GT.1)THEN
            LD(1)=(LD(1)/100)*100+MODRUN
C              WHEN MORE THAN ONE ENSEMBLE IS INVOLVED, USE MODRUN.
C              OTHERWISE, USE THE DD OF THE MEMBER.
         ENDIF
C
         LD(2)=ID(2,NN)
C           THIS PUTS THE PROBABILITY THRESHOLD INTO LLLL OF WORD 2.
C           IT ASSUMES UUUU = 0, BUT RETAINS THE FIRST DIGIT, V.
         LD(3)=ID(3,NN)
         LD(4)=IDPARS(13,NN)*100+IDPARS(14,NN)*10
C           G IS STRIPPED OFF FOR OUTPUT.
C
         WRITE(KFILAO,217)CCALL(K),(LD(J),J=1,4),NDATE,NPCDF
 217     FORMAT(/,' ',A8,I12,2X,3I11.9,I11.3,I6)
C
C
         WRITE(KFILAO,219)(XAXIS(J),PDF(J),CDF(J),J=1,NPCDF)
 219     FORMAT(' ',3F12.6)
      ENDIF
C
C        FIND THE DATA VALUE IN XAXIS( ) CORRESPONDING TO THE
C        THRESHOLDS IN CDFTH( ) APPLIED TO CDF( ) AND PUT
C        THEM IN XCDF( , ).
C
      NSTART=2
C
      DO 230 L=1,NCDFTH
C
      DO 220 LL=NSTART,NPCDF
C
      IF(CDF(LL).GT.CDFTH(L))THEN
         DIF=CDF(LL)-CDF(LL-1)
C           
         IF(DIF.LE.0.)THEN
            XCDF(K,L)=XAXIS(LL)
            WRITE(KFILDO,2195)CCALL(K)
 2195       FORMAT(/' ****CDF( ) AT TWO POINTS ALONG THE',
     1              ' AXIS ARE EQUAL FOR STATION ',A8,
     2              '.  PROBABLY AN ERROR.  CONTINUING.')
            ISTOP(3)=ISTOP(3)+1
         ELSE
            F=(CDFTH(L)-CDF(LL-1))/DIF
            XCDF(K,L)=XAXIS(LL-1)+(XAXIS(LL)-XAXIS(LL-1))*F
C              PACKING WILL DO ROUNDING.
         ENDIF
C
         NSTART=LL
         GO TO 230
      ENDIF
C
 220  CONTINUE
C
 230  CONTINUE
C
      IF(IP15.NE.0)THEN
         WRITE(IP15,232)NCDFTH,(CDFTH(L),XCDF(K,L),L=1,NCDFTH)
 232     FORMAT(/,' VALUES CORRESPONDING TO ',I4,' THRESHOLDS.',/,
     1           (5(3X,2F8.2)))  
      ENDIF       
C 
 250  CONTINUE
!$OMP END PARALLEL DO
C
      NN=NNSAVE
C*** 300  WRITE(KFILDO,301)N,NN,M
C*** 301  FORMAT(/' AT 301 IN DISTF--N,NN,M',3i12)
  300 RETURN
      END   
