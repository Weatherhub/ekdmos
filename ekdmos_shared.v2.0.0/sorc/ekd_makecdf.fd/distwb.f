      SUBROUTINE DISTWB(KFILDO,KFIL10,KFILAO,KFILAI,IP12,IP15,
     1                 KFILRA,RACESS,NUMRA,
     2                 ID,IDPARS,JD,TRESHL,TRESHU,ITAU,NVRBL,
     3                 NDATE,CCALL,ISDATA,SDATA,ND1,NSTA,
     4                 XDATA,SDDATA,ND2,KER,ISD,SD,DS,NN,M,
     5                 ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     6                 LSTORE,ND9,LITEMS,CORE,ND10,
     7                 NBLOCK,NFETCH,MODRUN,
     8                 IS0,IS1,IS2,IS4,ND7,
     9                 XAXIS,PDF,CDF,ND11,NPCDF,CDFTH,XCDF,NCDFTH,
     A                 L3264B,L3264W,ISTOP,IER)
C
C        OCTOBER   2008   WAGNER  CREATED FROM DISTF
C        MARCH     2011   CERRUTI EDIT TO CORRECT CDF
C                                 ADD SS RELATIONSHIP INPUT VIA 
C                                 CALL TO RDSPSK
C        SEPTEMBER 2011   CERRUTI ADD MEAN WIND SHIFT BEFORE INITIAL PDF
C                                 SHIFT WIND BACK BY SAME AMOUNT BEFORE POW
C                                 ADD LINEAR ADJUSTMENT TO CDF FOR WIND < 3KTS 
C                                 CORRECTED XCDF CALCULATION TO INTERPOLATE TO
C                                 FIND CDFTH EXACTLY
C        JUNE      2012   CERRUTI REMOVE SPREAD SKILL
C                                 REMOVED KDE TO USE ONLY MEAN OF INPUT
C                                 CLEANED UP FOR TRANSITION TO OPERATIONS
C        JUNE      2012   WAGNER  ADDED ITABLE TO HOLD IDS.  SET KER TO 4
C                                 FOR OPERATIONS.
C        AUGUST    2012   WAGNER  ADDED IDPARS(15,N) TO THE PROBABILITY OF
C                                 WIND ID
C        FEBRUARY  2013	  WAGNER  CHANGED POW ID TO 2043181
C
C        PURPOSE
C            DISTWB IS CALLED FROM OPTY AND COMPUTES A WEIBULL DISTRIBUTION
C            FUNCTION FROM VARIOUS MODEL FORECAST DATA. EMPERICAL RESULTS 
C            SHOW THAT MINUSING A SINGLE WEIBULL KERNEL FOR GENERATION OF THE
C            OUTPUT CDF PRODUCES THE BEST RESULTS COMPARED TO GAUSSIAN
C            NON-ZERO KDE AND GAUSSIAN KDE AS INPUT FOR THE WEIBULL PARAMETERS.
C            THE WEIBULL CALCULATION FOLLOWS THAT OF A TWO PARMETER WEIBULL.
C   
C        DATA SET USE 
C            KFILDO    - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10    - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM
C                        ACCESS.  (INPUT-OUTPUT) 
C            KFILAO    - UNIT NUMBER OF ASCII OUTPUT FILE.  ZERO MEANS
C                        OUTPUT WILL NOT BE WRITTEN.  (OUTPUT)
C            IP12      - LIST OF STATIONS ON THE INPUT FILES.  (OUTPUT)
C            IP15      - LIST OF DATA IN DIST.  (OUTPUT)
C            KFILRA(J) - UNIT NUMBERS FOR EXTERNAL RANDOM ACCESS FILES
C                        (J=1,5).  (INPUT)
C 
C        VARIABLES 
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              KFILAO = UNIT NUMBER OF ASCII OUTPUT FILE.
C                       ZERO MEANS OUTPUT WILL NOT BE WRITTEN.  (INPUT)
C                IP12 = INDICATES WHETHER (>0) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE EXTERNAL RANDOM ACCESS FILES
C                       WILL BE LISTED TO UNIT IP12.  (INPUT)
C                IP15 = LIST OF DATA IN DIST.  (INPUT)
C           KFILRA(J) = THE UNIT NUMBERS FOR THE MOS-2000 EXTERNAL
C                       RANDOM ACCESS FILES (J=1,NUMRA)
C           RACESS(J) = THE FILE NAME FOR THE MOS-2000 EXTERNAL RANDOM
C                       ACCESS FILE (J=1,NUMRA).  (CHARACTER*60)
C               NUMRA = THE NUMBER OF VALUES IN KFILRA( ) AND RACESS( ).
C                       (INPUT)
C             ID(J,N) = THE VARIABLE ID (J=1,4) (N=1,NVRBL).  (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE
C                       VARIABLE ID CORRESPONDING TO ID( ) (J=1,15)
C                       (N=1,NVRBL).
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY
C                            1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK
C                            IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (ENSEMBLE SYSTEM INDICATOR).
C                       (INPUT)
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID (J=1,4)
C                       (N=1,NVRBL).  THIS IS THE SAME AS ID(J), EXCEPT
C                       THAT THE FOLLOWING PORTIONS ARE OMITTED:
C                       B = IDPARS(3) (INPUT)
C           TRESHL(N) = THE LOWER BINARY THRESHOLD ASSOCIATED WITH 
C                       IDPARS( ,N) (N=1,NVRBL).  (INPUT)
C           TRESHU(N) = THE UPPER BINARY THRESHOLD ASSOCIATED WITH
C                       IDPARS( ,N) (N=1,NVRBL).  (INPUT)
C             ITAU(N) = THE NUMBER OF HOURS AHEAD TO FIND A VARIABLE
C                       (N=1,NVRBL).  THIS DOES NOT APPLY TO ALL
C                       SUBROUTINES.  NO PRESENT USE; SHOULD BE ZERO.
C                       (INPUT)
C               NVRBL = THE NUMBER OF VARIABLES IN ID( , ), ETC.
C                       (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH VARIABLE IS NEEDED.
C                       (INPUT)
C            CCALL(K) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (K=1,NSTA).  ALL STATION DATA ARE
C                       KEYED TO THIS LIST.  (CHARACTER*8)  (INPUT)
C           ISDATA(K) = WORK ARRAY (K=1,ND1). (INTERNAL)
C            SDATA(K) = WORK ARRAY (K=1,ND1).  (INTERNAL)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT
C                       WITH.  (INPUT)
C                NSTA = NUMBER OF STATIONS OR LOCATIONS BEING DEALT
C                       WITH.  (INPUT)
C          XDATA(K,L) = THE ARRAY USED FOR VECTOR VALUES (K=1,ND1) 
C                       (L=1,ND2).  THE COLUMNS HOLD THE VALUES FOR
C                       THE M MEMBERS (SEE M BELOW).
C                       (INTERNAL/OUTPUT)
C         SDDATA(K,L) = USED FOR THE STANDARD ERRORS (K=1,ND1)
C                       (L=1,ND2).  THE COLUMNS HOLD THE SD'S FOR THE
C                       M MEMBERS (SEE M BELOW).  (INTERNAL/OUTPUT)
C         PRDATA(K,L) = USED FOR THE PROBABILITY OF WIND SPEED (K=1,ND1)
C                       (L=1,ND2).  THE COLUMNS HOLD THE PROBABILITIES
C                       FOR THE M MEMBERS (SEE M BELOW).  (INTERNAL)
C                 ND2 = MAXIMUM NUMBER OF ENSEMBLE MEMBERS.  (INPUT)
C              KER(N) = DESIGNATES THE KERNEL TO BE USED FOR VARIABLE N
C                       (N=1,ND4).
C                       1 = WEIBULL (INPUT)).
C              ISD(N) = DESIGNATES WHETHER THE KERNEL WIDTH FOR
C                       VARIABLE N (N=1,ND4) IS TO BE TAKEN FROM SD( )
C                       IN THE VARIABLE RECORD OR FROM A PACKED INPUT
C                       RECORD.
C                       0 = COMES FROM PACKED RECORD;
C                       1 = COMES FROM VARIABLE RECORD (INPUT)
C               SD(N) = A FACTOR TO USE IN THE SPREAD ADJUSTMENT FOR
C                       MULTIPLE ENSEMBLES FOR THIS VARIABLE N
C                       (N=1,ND4).  (INPUT)
C               DS(N) = SCALING FACTOR FOR THE STANDARD DEVIATION FOR
C                       THIS VARIABLE (N=1,ND4).  (INPUT)      
C                  NN = ON INPUT, THE FIRST VARIABLE IN THE ID LIST NOT
C                       ALREADY USED.  THIS IS THE VARIABLE TO PROCESS.
C                       ON OUTPUT, THE FIRST VARIABLE IN THE ID LIST NOT
C                       USED.  WHEN ALL VARIABLES HAVE BEEN PROCESSED,
C                       NN IS RETURNED = 9999.  (INPUT/OUTPUT)
C                   M = THE NUMBER OF MEMBERS IN DISTWB.
C                       (OUTPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN 
C                       INTEGER VARIABLE (L=1,L3264W) (K=1,ND1).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       NEEDED IN CONST FOR ARGUMENT TO RDTDLM.
C                       EQUIVALENCED TO CCALLD( ).
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5).  EQUIVALENCED
C                       TO ICALLD( , ).  (INTERNAL)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), WORK( ), DATA( ), AND
C                       CALLD( ), AND SECOND DIMENSION OF ICALLD( , ).
C                       (INPUT)
C         LSTORE(L,J) = THE ARRAY TO HOLD INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.  NOTE THAT WHEN A FIELD 
C                              CANNOT BE STORED IN CORE( ), IT IS PUT
C                              ON DISK.  IT MAY BE THAT A LATER FIELD 
C                              WILL FIT, AND IT IS PUT IN CORE( ).
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDLPACK, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --THE NUMBER IN THE LIST OF INPUT SOURCES
C                              THIS VARIABLE CAME FROM.
C                       L=11 --FOR U715, THIS WILL BE 7777, INDICATING
C                              THE VARIABLE IS ALWAYS STORED IN THE
C                              INTERNAL STORAGE FACILITY.
C                       L=12 --MINUS THE NUMBER OF HOURS THIS VARIABLE
C                              MUST BE KEPT.  LATER SET TO A DATE WHEN
C                              THIS VARIABLE CAN BE DISCARDED.
C                       (INPUT)
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , )
C                       FILLED.  (INPUT)
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA
C                       IDENTIFIED IN LSTORE( , ) (J=1,ND10).  WHEN
C                       CORE( ) IS FULL DATA ARE STORED ON DISK.
C                       (INPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.
C                       GFETCH KEEPS TRACK OF THIS AND RETURNS THE
C                       VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).
C                       (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).
C                       (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).
C                       (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4). 
C                       (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C            XAXIS(J) = THE DATA VALUES ALONG THE X-AXIS, EACH
C                       VALUE CORRESPONDING TO A VALUE IN PDF(J) AND
C                       CDF(J) (J=1,NPCDF).  (OUTPUT) 
C              PDF(J) = THE PDF WRITTEN TO UNIT KFILAO (J=1,NPCDF).
C                       (OUTPUT)
C              CDF(J) = THE CDF WRITTEN TO UNIT KFILAO (J=1,NPCDF).
C                       (OUTPUT) 
C                ND11 = THE MAXIMUM NUMBER OF VALUES IN XAXIS( ),
C                       PDF( ), AND CDF( ).  (INPUT)
C               NPCDF = THE NUMBER OF VALUES IN PDF( ), CDF( ), AND
C                       XAXIS( ).  (OUTPUT)
C            CDFTH(J) = THE THRESHOLDS, OR PROBABILITY LEVELS, FOR
C                       OUTPUTTING THE CDF VALUES (J=1,NCDFTH).
C                       (INPUT)
C           XCDF(K,J) = THE VALUES FOR STATION K (K=1,NSTA) OF THE CDF
C                       FOR EACH OF THE LEVELS IN CDFTH(J) (J=1,NCDFTH)
C                       (OUTPUT)
C              NCDFTH = NUMBER OF VALUES IN CDFTH( ) AND XCDF( ).
C                       (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  
C                       CALCULATED BY PARAMETER, BASED ON L3464B.
C                       (INPUT)
C            ISTOP(J) = FOR J=1, ISTOP IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT MAY BE FATAL.
C                       FOR J=2, ISTOP IS INCREMENTED BY 1 WHENEVER AN
C                       INPUT DATA RECORD IS NOT FOUND.
C                       FOR J=3, ISTOP IS INCREMENTED BY 1 WHENEVER AN
C                       AN UNUSUAL CIRCUMSTANCE OCCURS WHICH IS NOT FATAL.
C                       (INPUT/OUTPUT)
C                 IER = STATUS RETURN.
C                         0 = GOOD RETURN.
C                       102 = ID NOT FOUND IN ITABLE.
C                       777 = SD = 0 FOUND IN KERNEL.
C                       OTHER VALUES CAN COME FROM CALLED SUBROUTINES.
C                       (OUTPUT)
C               MDATE = NDATE UPDATED WITH ITAU( ).  NO REASON FOR
C                       ITAU( ) TO BE OTHER THAN ZERO.  NEEDED FOR 
C                       RETVEC.  (INTERNAL)
C            RDATA(J) = HOLDS THE SINGLE VALUE FORECASTS TO FURNISH
C                       TO KERNEL (J=1,ND1).  (AUTOMATIC)  (INTERNAL)
C                  MM = THE NUMBER OF VALUES IN RDATA( ) AND SDATA( ).
C                       THIS IS THE NUMBER OF ENSEMBLES BEING 
C                       PROCESSED.  (INTERNAL)
C                KERN = DETERMINES HOW THE PDF WILL BE ASSESSED
C 			1=TENTHS OF A DEGREE
C                       2=WHOLE DEGREES (INTERNAL)
C                 DIF = WIDTH OF THE BIN IN THE CDF (INTERNAL)
C              NSTART = STARTING POSITION OF THE CDF (INTERNAL)
C                 TID = ID ASSOCIATED WITH THE PARALLEL PROCESS
C			(INTERNAL)
C                RMAX = THE MAXIMUM VALUE OF RDATA() (INTERNAL)
C                RMIN = THE MINIMUM VALUE OF RDATA() (INTERNAL)
C                SMAX = THE MAXIMUM VALUE OF SDATA() (INTERNAL)
C                SMIN = THE MINIMUM VALUE OF SDATA() (INTERNAL)
C                 FAC = THE XAXIS IN XASIS( ) WILL BE MODIFIED BY
C                       THE FACTOR FAC.  THIS IS TO CORRECT FOR
C                       OVERDISPERSION.  IT COULD BE USED FOR
C                       UNDERDISPERSION IF NEEDED.  (INTERNAL)
C             FMAXVAL = MAXIMUM XAXIS VALUE USED WHEN CALCULATING THE
C			KERNELS (INTERNAL)
C             FMINVAL = MINIMUM XAXIS VALUE USED WHEN CALCULATING THE
C                       KERNELS (INTERNAL)
C                RFAC = USED TO PRESERVE THE TENTHS DIGIT WHEN NECESSARY
C			(INTERNAL)
C            TDATA(J) = ARRAY TO HOLD THE ENSEMBLE VALUES (INTERNAL)
C              TSD(J) = ARRAY TO HOLD THE STANDARD DEVIATIONS (INTERNAL)
C                 LOC = CURRENT LOCATION OF THE PDF (INTERNAL)
C              FACTOR = THE CONSTANT MULTIPLIER FOR THE NORMAL DENSITY.
C			FOR THIS BASIC DENSITY, THE NUMBER OF CASES IS  
C			NOT RELEVANT. (INTERNAL)
C            TWOSIGSQ = THE DIVISION IN THE EXPONENT FOR THE NORMAL
C			DENSITY (INTERNAL)
C		  TOT = SUMMATION OF THE PDF (INTERNAL)
C		 TOT2 = HALF THE SUMMATION OF THE PDF (INTERNAL)
C                CMED = PERCENT MEDIAN OF THE PDF (INTERNAL)
C              TOTJM1 = PROBABILITY AT THE MEDIAN OF THE PDF
C			(INTERNAL)
C                 X50 = XAXIS LOCATION OF THE MEAN OF THE PDF
C			(INTERNAL)
C                XMED = XAXIS LOCATION OF THE MEDIAN OF THE PDF
C                       (INTERNAL)
C             XSTDEV  = STANDARD DEVIATION VALUE USED TO CALCULATE WEIBULL
C                       PARAMETERS (INTERNAL)
C             AVGWBS  = AVERAGE OF MEMBER FORECASTS (TDATA) USED TO CALCULATE  
C                       WEIBULL PARAMETERS (INTERNAL)
C             FSLOPE  = SLOPE FROM (0,0) to (FIRST XAXIS VALUE > 3 KTS,XCDFTH)
C                       USED FOR LINEAR ADJUSTMENT OF SMALL (< 3KTS) WIND SPEEDS
C                       IN XCDF AFTER POW ADJUSTMENT. (INTERNAL)
C            IHOLDER  = ARRAY INDEX OF CDFTH USED TO DEFINE THE SECOND HALF OF
C                       FSLOPE (INTERNAL)
C               ADJWB = AMOUNT OF ADJUSTMENT (LEFTWARD SHIFT) TO THE WEIBULL
C                       THIS AMOUNT IS ADDED BACK TO THE XAXIS JUST BEFORE 
C                       POW ADJUSTMENT (INTERNAL)
C         ITABLE(4,N) = TABLE HOLDING THE FOLLOWING IDS:
C                       1 - THE ID READ FROM THE U715 PREDICTOR LIST
C                       2 - THE ID OF THE CONDITIONAL FORECAST TO BE READ
C                       3 - THE ID OF THE PROBABILITY FORECAST TO BE READ
C                       4 - THE FOURTH WORD OF THE PROBABILITY FORECAST
C                           (INTERNAL)
C                NDIM = ARRAY INDEX FOR ITABLE
C                JDIM = INDEX FOR CURRENT ID IN ITABLE 
C                       
C 
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES USED 
C            TIMPR, PRSID1, RETVEC,
C
      PARAMETER(LW=100)
      PARAMETER(NDIM=1)
      CHARACTER*8 CCALL(ND1)
      CHARACTER*8 CCALLD(ND5)
      CHARACTER*60 RACESS(5)
C
      DIMENSION ISDATA(ND1),SDATA(ND1),PDATA(ND1)
      DIMENSION RDATA(ND1)
C        RDATA( ) IS AN AUTOMATIC ARRAY.
      DIMENSION XDATA(ND1,ND2),SDDATA(ND1,ND2),PRDATA(ND1,ND2)
      DIMENSION TDATA(ND1),TSD(ND1)
      DIMENSION ID(4,NVRBL),IDPARS(15,NVRBL),
     1          TRESHL(NVRBL),TRESHU(NVRBL),JD(4,NVRBL),ITAU(NVRBL),
     2          KER(NVRBL),ISD(NVRBL),SD(NVRBL),DS(NVRBL)
      DIMENSION ICALLD(L3264W,ND5),IPACK(ND5),IWORK(ND5),DATA(ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9)
      DIMENSION CORE(ND10)
      DIMENSION CDFTH(NCDFTH),XCDF(ND1,NCDFTH),FCDF(ND1,NCDFTH)
      DIMENSION XAXIS(ND11),PDF(ND11),CDF(ND11),PDFJ(ND11)
      DIMENSION KFILRA(5),LD(4),LDPARS(15),ISTOP(3)
      DIMENSION WVALS(LW),GVALS(LW),ITABLE(4,NDIM)
      REAL WBSTDV,AVGWBS,TOTWBS,PWDATA,SUB,FSLOPE
C
      DATA JFIRST/0/
      DATA WVALS/1.0,0.9943,0.9888,0.9835,0.9784,0.9735,0.9687,0.9642,
     1 0.9597,0.9555,0.9514,0.9474,0.9436,0.9399,0.9364,0.9330,0.9298,
     2 0.9267,0.9237,0.9209,0.9182,0.9156,0.9131,0.9108,0.9085,0.9064,
     3 0.9044,0.9025,0.9007,0.8990,0.8975,0.8960,0.8946,0.8934,0.8922,
     4 0.8912,0.8902,0.8893,0.8885,0.8879,0.8873,0.8868,0.8864,0.8860,
     5 0.8858,0.8857,0.8856,0.8856,0.8857,0.8859,0.8862,0.8866,0.8870,
     6 0.8876,0.8882,0.8889,0.8896,0.8905,0.8914,0.8924,0.8935,0.8947,
     7 0.8959,0.8972,0.8986,0.9001,0.9017,0.9033,0.9050,0.9068,0.9086,
     8 0.9106,0.9126,0.9147,0.9168,0.9191,0.9214,0.9238,0.9262,0.9288,
     9 0.9314,0.9341,0.9368,0.9397,0.9426,0.9456,0.9487,0.9518,0.9551,
     A 0.9584,0.9618,0.9652,0.9688,0.9724,0.9761,0.9799,0.9837,0.9877,
     B 0.9917,0.9958/
       DATA GVALS/1.00,1.01,1.02,1.03,1.04,1.05,1.06,1.07,1.08,1.09,
     1 1.10,1.11,1.12,1.13,1.14,1.15,1.16,1.17,1.18,1.19, 
     2 1.20,1.21,1.22,1.23,1.24,1.25,1.26,1.27,1.28,1.29, 
     3 1.30,1.31,1.32,1.33,1.34,1.35,1.36,1.37,1.38,1.39, 
     4 1.40,1.41,1.42,1.43,1.44,1.45,1.46,1.47,1.48,1.49, 
     5 1.50,1.51,1.52,1.53,1.54,1.55,1.56,1.57,1.58,1.59, 
     6 1.60,1.61,1.62,1.63,1.64,1.65,1.66,1.67,1.68,1.69, 
     7 1.70,1.71,1.72,1.73,1.74,1.75,1.76,1.77,1.78,1.79, 
     8 1.80,1.81,1.82,1.83,1.84,1.85,1.86,1.87,1.88,1.89, 
     9 1.90,1.91,1.92,1.93,1.94,1.95,1.96,1.97,1.98,1.99/
C       DATA ITABLE/204325, 204316, 2043171, 295001000/ 
       DATA ITABLE/204325, 204316, 2043181, 295001000/ 
C 
      SAVE JFIRST,NDATES
C        NDATE IS SAVED IN NDATES ON THE FIRST ENTRY SO THAT
C        DIAGNOSTIC 212 WON'T PRINT AFTER THE FIRST DAY.
C
      IF(JFIRST.EQ.0)THEN
         NDATES=NDATE
         JFIRST=1
      ENDIF
C
C        GET SINGLE VALUE ESTIMATES AND THE STANDARD DEVIATION FOR
C        EACH ENSEMBLE MEMBER (DENOTED BY DD).  THIS CAN BE A SINGLE
C        RUN WITH OR WITHOUT AN ACCOMPANYING STANDARD DEVIATION
C        PACKED RECORD.
C
D     CALL TIMPR(KFILDO,KFILDO,'START DISTWB         ')
C
      IER=0
      IFIRST=0
      NNSAVE=9999
C        INITIALIZE NSAVE IN CASE ALL DATA RETRIEVES ARE SUCCESSFUL.
      M=1
C        M IS THE COLUMN IN XDATA( , ) TO RETRIEVE THE DATA.
C
      DO 150 N=NN,NVRBL
C           NVRBL IS THE NUMBER OF VALUES IN THE ID( , ) LIST.
C           NN IS THE LOCATION OF THE FIRST ONE NOT USED.
C
C           CHECK THE INPUT ID AGAINST THE ITABLE VALUES
C
         JDIM=0
         DO 105 JJ=1,NDIM
            IF(ITABLE(1,JJ).EQ.IDPARS(1,N)*1000+IDPARS(2,N))THEN
               JDIM=JJ
            ENDIF
 105     CONTINUE
C
         IF(JDIM.EQ.0)THEN
            WRITE(KFILDO,110)(ID(L,N),L=1,4)
 110        FORMAT(/,' ****DISTWB ENTERED FOR VARIABLE',
     1               2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.9,
     2               ' NOT ACCOMMODATED.')
            IER=102
            GO TO 300
         ENDIF
C
         MDATE=NDATE+ITAU(N)
C           I KNOW OF NO CURRENT USE FOR TAU NE 0, BUT IS CARRIED ALONG.
C***      WRITE(KFILDO,120)IER,IFIRST,NNSAVE,M,N,NN,NVRBL,ITAU(N),MDATE
C*** 120  FORMAT(/' AT 100--IER,IFIRST,NNSAVE,M,N,NN,NVRBL,ITAU(N),MDATE',
C***     1        8I6,I11)
C***      WRITE(KFILDO,121)(IDPARS(J,NN),J=1,15),(IDPARS(J,N),J=1,15)
C*** 121  FORMAT(/' IDPARS(J,NN),J=1,15),(IDPARS(J,N),J=1,15)',/,
C***     1        (15I7))
C

C           GET THE SINGLE VALUE FORECAST AND ITS ASSOCIATED
C           STANDARD DEVIATION FOR IDS THAT ARE THE SAME
C           EXCEPT FOR THE DD.
C    
         IF(ID(1,NN)/100.EQ.ID(1,N)/100.AND.
     1      ID(2,NN).EQ.ID(2,N).AND.
     2      IDPARS(8,NN).EQ.IDPARS(8,N).AND.
     3      IDPARS(10,NN).EQ.IDPARS(10,N).AND.
     4      IDPARS(11,NN).EQ.IDPARS(11,N).AND.
     5      IDPARS(12,NN)-IDPARS(9,NN).EQ.IDPARS(12,N)-IDPARS(9,N))THEN
C
C              THE ID OF VARIABLE N AGREES WITH THAT OF THE BASE VARIABLE
C              NN, EXCEPT DD, R, AND TAU.  THE TEST ASSURES THAT THE DATES
C              AND PROJECTIONS ARE SUCH THAT THE FORECASTS VERIFY AT THE
C              SAME TIME.  NORMALLY, IDPARS(9,NN) WILL BE ZERO.
C
C              RETRIEVE THE SINGLE VALUE FORECASTS.
C
            LD(1)=ITABLE(2,JDIM)*1000+IDPARS(4,N)
            LD(2)=ID(2,N)
            LD(3)=ID(3,N)
            LD(4)=ID(4,N)
            CALL PRSID1(KFILDO,LD,LDPARS)
            ITIME=IDPARS(9,N)
C              ITIME IS USED IN GFETCH.  IT IS CALLED ITAU IN RETVEC.         
            
            CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,XDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,IER)
C              JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C              IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C
            IF(IER.NE.0)THEN
               WRITE(KFILDO,125)(LD(J),J=1,4),NDATE
  125          FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN ',
     1             'DISTWB',
     2             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
C
            ENDIF
C
C              RETRIEVE THE STANDARD ERRORS.  THE STANDARD ERRORS (SE) HAVE
C              THE SAME ID EXCEPT FOR 200 IN THE LLLL PORTION OF WORD 2.
C
C              EVEN IF THE VARIABLE IS NOT RETRIEVED, THE SE RECORD
C              IS TRIED SO THAT MSTORE( , ) CAN BE INITIALIZED CORRECTLY.
C
            LD(2)=ID(2,N)+002000000
            CALL PRSID1(KFILDO,LD,LDPARS)
            CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,SDDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,JER)
C              JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C              IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C              NOTE THAT JER RATHER THAN IER IS USED IN THE CALL.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C              RETRIEVE THE PROBABILITY OF WIND SPEED
C
            LD(1)=ITABLE(3,JDIM)*100+IDPARS(4,N)
            LD(2)=ID(2,N)
            LD(4)=ITABLE(4,JDIM)+IDPARS(15,N)
            CALL PRSID1(KFILDO,LD,LDPARS)
            CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,PRDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,JER)
C              JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C              IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C              NOTE THAT JER RATHER THAN IER IS USED IN THE CALL.
C
            IF(JER.NE.0)THEN
               WRITE(KFILDO,135)(LD(J),J=1,4),NDATE
  135          FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN
     1          DISTW',
     2         2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
C
            ENDIF
C
            IF(IER.EQ.0.AND.JER.EQ.0)THEN
               M=M+1
C                 UNLESS BOTH THE SINGLE VALUE FORECAST AND THE STANDARD
C                 ERROR CAN BE RETRIEVED, THE DATA ARE NOT SAVED AND THE
C                 COLUMN NUMBER IS NOT UPDATED.  THIS ALLOWS THE USE
C                 OF LESS THAN THE FULL SET OF EXPECTED ENSEMBLES.
            ENDIF 
C
         ELSE
C
            IF(IFIRST.EQ.0)THEN
               NNSAVE=N
C                  NNSAVE IS NOW THE FIRST VARIABLE IN THE ID( , ) LIST
C                  NOT USED.  LATER, TRANSFER NNSAVE TO NN TO BE USED
C                  ON NEXT ENTRY.
               IFIRST=1
            ENDIF
C
         ENDIF
C
 150  CONTINUE
C 
C        ALWAYS DROPS THROUGH HERE.
C
      M=M-1
C        THERE HAVE BEEN M RECORDS RETRIEVED.  EACH HAS THE SAME
C        ID'S EXCEPT THE DD'S AND POSSIBLY THE RR'S AND TAU'S.
C
      IF(M.EQ.0)THEN
C           THIS IS AN ERROR AND INDICATES THAT NO MEMBERS HAVE
C           BEEN RETRIEVED.  EXIT.                                    
         NN=9999
         GO TO 300
      ELSE
C
         IF(IP15.NE.0)THEN
            WRITE(IP15,155)M,(ID(J,NN),J=1,4),NDATE
 155        FORMAT(/' ',I3,' ENSEMBLE MEMBERS HAVE BEEN RETRIEVED',
     1                ' FOR VARIABLE',
     2                 2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
         ENDIF
C
      ENDIF
C
      IF(IP15.NE.0)THEN
C
         DO 170 K=1,NSTA
         WRITE(IP15,160)CCALL(K),NDATE,(XDATA(K,L),L=1,M)
 160     FORMAT(/' SINGLE VALUE ENSEMBLE FORECASTS FOR STATION ',A8,
     1           '  FOR DATE ',I12,/,('     ',15F8.2))
         WRITE(IP15,165) (SDDATA(K,L),L=1,M)
 165     FORMAT( ' STANDARD ERRORS OF EST',/,
     1                              ('     ',15F8.2))
 170     CONTINUE
C
      ENDIF
C
C        CHECK FOR KERNEL USED.  ONLY WEIBULL IMPLEMENTED.
C
      IF(KER(NN).NE.4)THEN
         WRITE(KFILDO,175)KER(NN),(ID(J,NN),J=1,4)
 175     FORMAT(/,' ****KER( ) =',I4,' NE 1',
     1            ' FOR VARIABLE',
     2             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3            ' CHANGING IT TO 1.',/,
     4            '     ONLY THE WEIBULL IS IMPLEMENTED.  PROCEEDING.')
         KER(NN)=4
         ISTOP(3)=ISTOP(3)+1
      ENDIF
C
C	LOOP THROUGH EACH STATION IN PARALLEL
C
!$OMP PARALLEL DO 
!$OMP& PRIVATE(K,L,I,MM,NPCDF,RDATA,SDATA,KERN,PDF,CDF)
!$OMP& PRIVATE(XAXIS,LD,LL,DIF,F,ISTOP,NSTART,IER,TID,J)
!$OMP& PRIVATE(RMAX,SMAX,RMIN,SMIN,FAC,FMAXVAL,FMINVAL)
!$OMP& PRIVATE(RFAC,TDATA,TSD,LOC,FACTOR,PDATA,LOCZERO)
!$OMP& PRIVATE(TWOSIGSQ,TOT,TOT2,CMED,TOTJM1,P,X50,XMED)
!$OMP& PRIVATE(RALPHA,RBETA,RMEAN,SMEAN,RBETAD,IRBD,RBD)
!$OMP& PRIVATE(RGAM,RGFAC,GAMMA,WBSTDV,AVGWBS,TOTWBS)
!$OMP& PRIVATE(DATSUM,PWDATA,IHOLDER,FSLOPE,PDFJ,AVGST)
!$OMP& PRIVATE(XSTDEV,DATSUM2,ADJWB,PCTDIF,WNDVAL,MAXMEM)
!$OMP& PRIVATE(TERM1,TERM2,THEDIF)
      DO 250 K=1,NSTA
C
         MM=0
         AVGST=0.
C
         DO 200 L=1,M
            IF(XDATA(K,L).NE.9999.)THEN
               MM=MM+1
               RDATA(MM)=XDATA(K,L)
               IF(RDATA(MM).LT.0.)RDATA(MM)=0.0
               SDATA(MM)=SDDATA(K,L)
               PDATA(MM)=PRDATA(K,L)
               IF(PDATA(MM).LT.0.0) PDATA(MM)=0.0
               IF(PDATA(MM).GT.1.0) PDATA(MM)=1.0
               AVGST=AVGST+SDATA(MM)
            ENDIF
C      
 200     CONTINUE
        
         IF(MM.GT.0) THEN
            AVGST=AVGST/MM
         ELSE
            AVGST=0.
         ENDIF
C
C              AT THIS POINT, RDATA( ) AND SDATA( ) CONTAIN MM 
C              NON-MISSING FORECASTS.
C
         IF((MM.EQ.0).OR.(AVGST.EQ.0.))THEN 
C
            IF(NDATE.EQ.NDATES)THEN
C                 THIS DIAGNOSTIC WILL PRINT ON ONLY THE FIRST DAY.
               WRITE(KFILDO,212)CCALL(K),(ID(J,NN),J=1,4),NDATE
 212           FORMAT(/,' NO FORECASTS FOR STATION ',A8,
     1              ' FOR VARIABLE',
     2                2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3               ' FOR DATE',I12,'.  (PRINT ON DAY 1.)')
C
C                 WHEN THERE ARE NO GOOD NON-MISSING FORECASTS
C                 FOR STATION K, SET THE XCDF(K,L) VALUES MISSING
C                 FOR ALL THRESHOLDS.
            ENDIF
C
            DO 213 L=1,NCDFTH
               XCDF(K,L)=9999.
 213        CONTINUE
C
            GO TO 250
C
         ELSEIF(MM.NE.M)THEN
            WRITE(KFILDO,214)MM,CCALL(K),(ID(J,NN),J=1,4),NDATE
 214        FORMAT(/,' ONLY',I4,' FORECASTS FOR STATION ',A8,
     1            ' FOR VARIABLE',
     2             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3            ' FOR DATE',I12)
         ENDIF
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C           DEVIATION IN SDATA( ) IN TENTHS OF UNITS FURNISHED ROUNDS
C           TO 0.  A DIAGNOSTIC WILL HAVE BEEN PRINTED IN KERNEL; THE
C           ONE BELOW WILL EXPLAIN WHICH VARIABLE AND STATION.
C
C           RFAC GOVERNS WETHER TO USE TENTHS OF KNOTS (WHEN XSTDEV
C           LE 16.0) OR WHOLE KNOTS FOR CALCULATIONS.
C
         IF(AVGST.LT.16.) THEN
            RFAC=10.
         ELSE
            RFAC=1.
         ENDIF
C
         FMAXVAL=-9999999
         FMINVAL=+9999999
C
C           CHECK SCALING FACTOR.
C
         IF(DS(NN).EQ.0.)THEN
            WRITE(KFILDO,215)J
 215        FORMAT(/' ****SCALING FACTOR IS INPUT AS ZERO.',
     1           '  ASSUME SCALING OF 1.  PROCEEDING.')
            FDS=1.
            IER=777
         ELSE
            FDS=DS(NN)  
         ENDIF
C
C              PUT THE REAL NUMBERS IN DATA( ) INTO TDATA( ) ROUNDED
C              TO TENTHS OF UNITS.
C
         DO 217 J=1,M  
C              IF RFAC=10, IT IS EXPECTED THE DATA IN RDATA( ) ARE TO TENTHS OF
C              UNITS, AND NOTHING IS LOST HERE.  OTHERWISE, TENTHS
C              OF UNITS IS ALL THE PRECISION THAT IS KEPT.
C              IF RFAC=10, THE DATA( ) ARE MULTIPLIED BY 10, SO THE SD'S MUST BE ALSO.
C              THE SD'S ARE SCALED BY DS.
C
            TSD(J)=FDS*SDATA(J)*RFAC
            TDATA(J)=RDATA(J)*RFAC
C
            IF(TSD(J).LE.0)THEN
               WRITE(KFILDO,216)J
 216           FORMAT(/' ****STANDARD DEVIATION OF THE',I4,'TH VALUE',
     1           ' IN TENTHS OF UNITS ROUNDS TO ZERO.',/,
     2           '     ASSUME 1 SCALED UNIT.  PROCEEDING.')
               TSD(J)=1
               IER=777
            ENDIF
C
 217     CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C           CALCULATE THE STDEV VALUE FROM ALL ENS MEMBERS 
C
         TOTWBS=0.   
         AVGWBS=0.
         WBSTDV=0.
         DATSUM=0.
C
         DO 218 I=1,MM
C
C              SUM ALL ENS MEMBER VALUES
C
            TOTWBS=PDATA(I)+TOTWBS
            DATSUM=TDATA(I)+DATSUM
            DATSUM2=TSD(I)+DATSUM2
 218     CONTINUE
C
C           CALCULATE AVERAGE MEMBER VALUE
C
         AVGWBS=DATSUM/MM
         PWDATA=TOTWBS/MM
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C           SET VALUE FOR USE IN WEIBULL PARAMETER CALUCLATION
C
         XSTDEV=AVGST*RFAC
C
C           SET WIND SPEED EQUAL TO ENS AVERAGE, 
C           THEN ONLY LOOP OVER 1 MEMBER
C
C           RESET DATSUM TO USE AGAIN
         DATSUM=0.
C
         DO 219 I=1,MM
C              CALCULATE SQUARED DEVIATION SUMMATION          
            DATSUM=((TDATA(I)-AVGWBS)**2)+DATSUM
 219     CONTINUE
C
C           CALCULATE STDEV OF ENS MEMBER VALUES
         WBSTDV=SQRT(DATSUM/MM)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C           FIND MAXIMUM AND MINIMUM EXTENTS OF THE FINAL DENSITY.
C           THIS WILL BE THE SMALLEST AND LARGEST TDATA( ) VALUES
C           EACH EXTENDED TO THE LEFT AND RIGHT, RESPECTIVELY,
C           BY 3 TIMES ITS RESPECTIVE TSD( )
C
         FMINVAL=MAX(AVGWBS-4*XSTDEV,1.0)
C
         FMAXVAL=(AVGWBS+4*XSTDEV)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C           SET THE X-AXIS VALUES.
C           XAXIS( ) IS THE AXIS IN TERMS OF THE INCOG DATA.  THE
C           DATA HAVE BEEN SCALED*10; SCALING MUST BE TAKEN OUT.  THIS
C           COVERS THE RANGE 3 SIGMA BELOW THE IMUM VALUE AND
C           3 SIGMA ABOVE THE MAXIMUM VALUE IN INCREMENTS OF TENTHS
C           OF UNITS OF THE ORIGINAL DATA.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
         NPCDF=FMAXVAL-FMINVAL+1
C
         IF(NPCDF.GT.ND11)THEN
            WRITE(KFILDO,220)ND11,NPCDF
 220        FORMAT(/,' ****DIMENSION ND11 =',I8,' TOO SMALL TO',
     1            ' COMPUTE CDF( ) IN DISTWB.  INCREASE TO ',I8,
     2            ' OR MORE.  PROCEEDING.')
            IER=778
         ENDIF
C
         FINC=(FMAXVAL-FMINVAL)/(NPCDF-1)
         LOCZERO=9999
C

         DO 221 J=1,NPCDF+1
            XAXIS(J)=(FMINVAL+J-1)/RFAC
            IF(XAXIS(J).LE.0)XAXIS(J)=0.0
C              THE X-AXIS WILL COVER 3 STANDARD DEVIATIONS IN TERMS OF
C              TENTHS OF UNITS, LABELED IN WHOLE UNITS, ON EITHER SIDE
C              OF THE MAX AND  VALUE IN DATA( ).
 221     CONTINUE
C
C           ZERO THE PDF( ) AND CDF( ) ARRAYS.
C
         DO 222 J=1,NPCDF
            CDF(J)=0.
 222     CONTINUE

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C           COMPUTE THE KERNEL
C
C                 IF WIND SPEED VALUE IS ZERO, DON'T CALCULATE
C
C                 TEST FOR OFFSET... THIS METHOD WAS DERIVED 
C                 EMPIRICALLY THROUGH EXPERIMENTATION...     
C                 DIFFERENT CASES EXIST FOR DIFFERENT VALUES OF
C                 MAXMEM. 
C
C                 THE EXPERIMENTATION HAS SHOWN THAT MINUSING A 
C                 DIFFERENT RELATIONSHIP TO CALCULATE THE OFFSED
C                 VALUE GIVES THE BEST RESULTS WHEN:
C                   - OFFSET = AVGWBS-2.99 { AVGWBS > 6 KTS }
C                   - OFFSET = AVGWBS / 2  { AVGWBS < 6 KTS }
C                 WHICH ENSURES THAT THE WIND SPEED CANNOT BE NEGATIVE 
C                 WHILE MAINTAINING THE OFFSET APPROACH FOR ALL WIND
C                 SPEED VALUES.                        
C
               IF(AVGWBS.LE.(6.0*RFAC)) THEN                                     
                  WNDVAL=AVGWBS/2.                                      
                  ADJWB=AVGWBS/(2*RFAC)                                       
               ELSE                                                      
                  WNDVAL=AVGWBS-(2.99*RFAC)                                    
                  ADJWB=2.99                                             
               ENDIF                                                     
C                                                                
               XSTDEV=AVGST*RFAC 
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C         THE CALCULATIONS BELOW ARE FOR SETTING A TWO PARAMETER
C         WEIBULL CDF FOR GIVEN WIND SPEEDS. THE TWO 
C         PARAMETERS ARE 'ALPHA', THE 'SHAPE PARAMETER', AND
C         'BETA', THE 'SCALE PARAMETER'. 


      RALPHA=((XSTDEV/(WNDVAL))**(-1.086))
      IF(RALPHA.LE.0.)RALPHA=0.001
      RBETAD=(1+(1/RALPHA))
      IRBD=NINT(RBETAD*100)
      RBD=FLOAT(IRBD)/100
C
      RGAM=1
      RGFAC=RBD
      DO WHILE(RGFAC.GE.2.0)

         RGFAC=RGFAC-1
         RGAM=RGAM*RGFAC
      ENDDO
C
      GAMMA=1.0
      DO 223 JJ=1,LW
         IF(RGFAC.GE.GVALS(JJ))THEN
            GAMMA=WVALS(JJ)*RGAM
         ENDIF
 223  CONTINUE
      RBETA=(WNDVAL)/(GAMMA)
C
      IF(FMINVAL.LE.0)THEN
         FMINVAL=0.0
      ENDIF   
C

C           MAKE COUNTER TO PROPERLY ITERATE THROUGH XAXIS
C           INITIALIZE LOC; USED FOR SETTING PDF ARRAY MEMBER
C           (START AT ZERO SINCE INCREMENT IS MADE BEFORE FIRST VALUE IS SET)
            LOC=1
C
         DO 224 J=FMINVAL,FMAXVAL  
C
            CDF(LOC)=(1-(EXP(-1*(J/RBETA)**RALPHA)))
            LOC=LOC+1
C      
 224     CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C         READJUST CDF VALUES BY ADJWB CALCULATED BEFORE RALPHA
C
      DO 225 J=1,NPCDF
      	XAXIS(J)=XAXIS(J)+ADJWB
 225  CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C        DONE WITH CDF ADJUSTMENT
C        NOW INVERT THE CDF AND MULTIPLY IT BY THE PROBABILITY OF 
C        WIND SPEED.  THEN RE-NORMALIZE.
C
      TOT=0.
      IF(PWDATA.GT.0.0)THEN
         DO 226 J=1,NPCDF
            CDF(J)=(1-CDF(J))*PWDATA
            TOT=CDF(J)+TOT
 226     CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	    NOW DE-INVERT AND RENORMALIZE THE WIND SPEED
C
          DO 227 J=1,NPCDF
             IF(TOT.EQ.0)THEN
                CDF(J)=0.0
             ELSE
                 CDF(J)=1-CDF(J)
             ENDIF
 227      CONTINUE
C
          TOT=CDF(NPCDF)
      ELSE
C
C	      IF THE PROBABILITY OF WIND IS 0, THEN THE CDF SHOULD
C	      JUST BE A VERTICAL LINE AT 0.
C
         CDF(1)=0.0
         DO 228 J=2,NPCDF
            CDF(J)=1.0
            XAXIS(J)=0.0
 228     CONTINUE
      ENDIF
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      IF(IER.EQ.777)THEN
         WRITE(KFILDO,229)(ID(J,NN),J=1,4),CCALL(K)
 229     FORMAT('     VARIABLE ',4I11,' STATION ',A8)
      ELSEIF(IER.EQ.778)THEN
         WRITE(KFILDO,216)(ID(J,NN),J=1,4),CCALL(K)
C
         DO 230 L=1,NCDFTH
         XCDF(K,L)=9999.
 230     CONTINUE
C
C         GO TO 250
      ENDIF 
C
      IF(KFILAO.NE.0)THEN
C
C           WRITE THE ASCII DATA.  FORM THE ID'S.
C
         LD(1)=ID(1,NN)
C
         IF(M.GT.1)THEN
            LD(1)=(LD(1)/100)*100+MODRUN
C              WHEN MORE THAN ONE ENSEMBLE IS INVOLVED, USE DD = MODRUN.
C              OTHERWISE, USE THE DD OF THE MEMBER.
         ENDIF
C
         LD(2)=ID(2,NN)
C           THIS PUTS THE PROBABILITY THRESHOLD INTO LLLL OF WORD 2.
C           IT ASSUMES UUUU = 0, BUT RETAINS THE FIRST DIGIT, V.
         LD(3)=ID(3,NN)
         LD(4)=ID(4,NN)
C
         WRITE(KFILAO,231)CCALL(K),(LD(J),J=1,4),NDATE,NPCDF
 231     FORMAT(/,' ',A8,I12,2X,3I11.9,I11.3,I6)
C
D        WRITE(KFILAO,232)(XAXIS(J),J=1,NPCDF)
D232     FORMAT(' ',15F8.3)
D        WRITE(KFILAO,218)(PDF(J),J=1,NPCDF)
D        WRITE(KFILAO,218)(CDF(J),J=1,NPCDF)
C
C         WRITE(KFILAO,233)(XAXIS(J),PDF(J),CDF(J),J=1,NPCDF)
 233     FORMAT(' ',3F12.6)
      ENDIF
C
C        FIND THE DATA VALUE IN XAXIS( ) CORRESPONDING TO THE
C        THRESHOLDS IN CDFTH( ) APPLIED TO CDF( ) AND PUT
C        THEM IN XCDF( , ).
C
      NSTART=1
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C        SET THE XCDF VALUES FOR WRITING TO OUTPUT FILE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      DO 234 L=1,NCDFTH
C
      DO 235 LL=NSTART,NPCDF
C
C           INITIALIZE XCDF = 0 TO AVOID MISSING VALUES
C           IF SOME VALUES ARE MISSING, THIS IS AN ERROR
C           AND SHOULD NEVER HAPPEN
        XCDF(K,L)=0.
        IF((CDF(LL).GT.CDFTH(L)).AND.(LL.EQ.1)) THEN
           GO TO 234
        ENDIF     

        DIF=CDF(LL)-CDF(LL-1)
C    
        IF(DIF.EQ.0.)THEN
           XCDF(K,L)=XAXIS(LL)
           IF(XCDF(K,L).LT.0.0)XCDF(K,L)=0.0
C           WRITE(KFILDO,236)CCALL(K)
C 236        FORMAT(/' ****CDF( ) AT TWO POINTS ALONG THE',
C     1             ' AXIS ARE EQUAL FOR STATION ',A8,
C     2             '.  PROBABLY AN ERROR.  CONTINUING.')
C               ISTOP(3)=ISTOP(3)+1

       ELSE
         IF(CDF(LL).GT.CDFTH(L)) THEN
            F=(CDFTH(L)-CDF(LL))/DIF
            PCTDIF=((CDF(LL)-CDFTH(L))/(CDF(LL)-CDF(LL-1)))
            THEDIF=XAXIS(LL)-XAXIS(LL-1) 
            XCDF(K,L)=XAXIS(LL-1)+(THEDIF*PCTDIF)/RFAC
            NSTART=LL
            GO TO 234
            IF(LL.EQ.1.) THEN
               XCDF(K,L)=0.0
            ELSE
               GO TO 235
            ENDIF
C 
            IF(XCDF(K,L).LT.0.0)XCDF(K,L)=0.0
C
         ENDIF
C
      ENDIF
C
 235  CONTINUE
C
 234  CONTINUE

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      INITIALIZE IHOLDER AND FSLOPE VALUES
C
         IHOLDER=0
         FSLOPE=0.
       DO 237 L=1,NCDFTH
            IF(XCDF(K,L).LE.3.0) IHOLDER=IHOLDER+1
 237  CONTINUE
C
C        MUST OFFSET IHOLDER BY 1 TO CALCULATE LINE UP TO FIRST 'VALID' 
C        XCDF VALUE GT 3, ABOVE LOOP FINDS PLACE OF LAST VALUE LE 3.

      IHOLDER=IHOLDER+1
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C         DEFINE AN EQUATION TO DEFINE A LINE FROM THE ORIGIN
C         TO WHERE THE CDF IS EQUAL TO 3.0
C
       IF(IHOLDER.GT.10.) IHOLDER=11

	  IF(XCDF(K,IHOLDER).LT.3.) THEN
             FSLOPE=3.
	  ELSE
             FSLOPE=XCDF(K,IHOLDER)/CDFTH(IHOLDER)
          ENDIF
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C         RESET XCDF...
C
       DO 238 L=1,NCDFTH
	  IF(XCDF(K,L).LE.3.0) XCDF(K,L)=CDFTH(L)*FSLOPE 
          IF(XCDF(K,L).GT.200.0) THEN
             WRITE(KFILDO,239)CCALL(K),CDFTH(L),XCDF(K,L),NDATE
 239         FORMAT(/,' ****CDF VALUES EXCEED NORMAL RANGE.',/,
     1                 A8,1X,F4.2,1X,F12.2,I12)
          ENDIF 
 238  CONTINUE
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      RE-PRINT CDF OUTPUT
C
      IF(IP15.NE.0)THEN
         WRITE(IP15,240)NCDFTH,(CDFTH(L),XCDF(K,L),L=1,NCDFTH)
 240     FORMAT(/,' VALUES CORRESPONDING TO ',I4,' THRESHOLDS.',/,
     1           (5(3X,2F8.2)))  
      ENDIF       
C 
 250  CONTINUE
!$OMP END PARALLEL DO
C
      NN=NNSAVE
C*** 300  WRITE(KFILDO,301)N,NN,M
C*** 301  FORMAT(/' AT 301 IN DISTWB--N,NN,M',3i12)
  300 RETURN
      END   
