      SUBROUTINE SSR(KFILDO,KFIL10,IP12,IDPARS,JD,NDATE,
     1               KFILRA,RACESS,NUMRA,
     2               CCALL,ICALLD,CCALLD,SDATA,ISDATA,
     3               DIR,ND11,NSLAB,NSTA,ND1,
     4               IPACK,IWORK,ND5,
     5               LSTORE,ND9,LITEMS,CORE,ND10,
     6               LASTL,NBLOCK,LASTD,NSTORE,NFETCH,
     7               IS0,IS1,IS2,IS4,ND7,
     8               FD1,FD2,FD3,FD4,FD5,FD6,SWORK,ND2X3,
     9               ISTAV,L3264B,L3264W,MISTOT,IER)
C
C        MARCH    2000   ALLEN   TDL   MOS-2000 
C        AUGUST   2000   ALLEN   ADDED CALLS TO SMOOTHERS 4 & 5 FOR MRF 
C                                PTYPE WORK.  ALSO CORRECTED REAL EQUIVALENCES.
C        DECEMBER 2000   RUDACK  MODIFIED CODE TO COMPLY WITH MDL FORMAT
C                                SPECIFICATIONS
C        JANUARY  2003   WEISS   CHANGED ND5 TO ND2X3,UPDATED CALL TO 
C                                CONST, AND THE ADDITION OF ARGUMENTS
C                                NAME,STALAT,STALON,NGRID, TO CALL.
C        FEBRUARY 2003   WEISS   CALL TO CONST CHANGED TO CONST1.
C        APRIL    2003   COSGROVE  MADE CHANGES REQUESTED BY HRG.  ALSO
C                                CHANGED CALL TO CONST1 BACK TO CONST.
C        APRIL    2003   GLAHN   DIMENSIONS OF FD4( ), FD5( ), AND 
C                                FD6( ) CHANGED FROM ND1 TO ND2X3;
C                                ELIMINATED AUTOMATIC ARRAYS DATA(ND5)
C                                AND ICALL( , , ); ELIMINATED IER=103
C                                AFTER CALL TO CONST; FDATA( )
C                                DIMENSION ND2X3 CHANGED TO SDATA( ) 
C                                DIMENSIONED ND1; EDA FEW COSMETICS
C        MAY      2003   GLAHN   REARRANGED VARIABLES IN CALL AND ADDED
C                                SWORK( ); REARRANGED TYPE STATEMENTS
C        JUNE     2003   GLAHN   REARRANGED ARGUMENTS IN CALL; LOOPS
C                                CHANGED FROM J=1,ND2X3 TO J=1,NSTA;
C                                INITIALIZATION OF SDATA( ) REMOVED.
C        AUGUST   2003   GLAHN   ELIMINATED /**** IN FORMATS 126 AND 127
C        1         2         3         4         5         6         7 X
C
C        PURPOSE 
C            THIS SUBROUTINE COMPUTES A "SINGLE-STATION-REGRESSION (SSR)"
C            PREDICTOR TO BE USED IN PTYPE EQUATIONS.  IT IS A POOR-MAN'S
C            SUBSTITUTE FOR THE NGM LOGIT PREDICTORS.  A BASE MODEL FIELD
C            IS RETRIEVED, TRANSFORMED INTO A GRID BINARY IF DESIRED, SMOOTHED, 
C            AND INTERPOLATED TO STATIONS.  THEN, A FORMULA IS COMPUTED AT 
C            EACH STATION USING THE BASE MODEL FIELD AND TWO SSR 
C            COEFFICIENTS FROM THE CONSTANT FILE.  THE FORMULA IS A SIMPLE
C            Y=B1*X + B0, WHERE X IS THE BASE MODEL FIELD, AND B0 AND B1
C            ARE THE PREVIOUSLY DETERMINED CONSTANT COEFFICIENTS.  
C
C            THE FOLLOWING IDPARS(1) AND IDPARS(2) ARE ACCOMMODATED: 
C
C               001 700 - 1000-850 MB THICKNESS, GRID BINARY WITH A CUTOFF OF 1300
C               002 700 - 2-METER TEMPERATURE, GRID BINARY WITH A CUTOFF OF 275
C               002 710 - 850 MB TEMPERATURE, GRID BINARY WITH A CUTOFF OF 273
C               002 715 - 850 MB TEMPERATURE, CONTINUOUS
C
C            THE SSRS ARE RETURNED AS PERCENTS, AND THEIR VALUES ARE 
C            CONSTRAINED BETWEEN 0 AND 1.
C
C            PRESENTLY, THE USER CAN SPECIFY THE SMOOTHING THEY WANT DONE ON THE 
C            BASE FIELD IN THE ID OF THE VARIABLE. THE CUTOFF FOR THE GRID 
C            BINARY (IF ANY) IS HARDWIRED IN THE CODE.
C            
C        DATA SET USE
C              KFILDO = DEFAULT UNIT NUMBER FOR OUTPUT(PRINT) FILE.
C                       (OUTPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM
C                       ACCESS.(INPUT-OUTPUT)
C
C        VARIABLES
C              KFILDO = DEFAULT UNIT NUMBER FOR OUTPUT (PRINT) FILE
C                       (INPUT). 
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM 
C                       ACCESS (INPUT-OUTPUT).
C                IP12 = USED IN SUBROUTINE CONST
C           IDPARS(J) = THE PARSED, INDIVIDUAL COMPONENTS OF THE 
C                       PREDICTOR ID CORRESPONDING TO ID() (J=1,15).
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY
C                                      1 LAYER)
C                       J=7--LTLTLTLT (TOP OF LAYER)
C                       J=8--T (TRANSFORMATION)
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND 
C                                BACK IN TIME)
C                       J=10-OT (TIME APPLICATION)
C                       J=11-OH (TIME PERIOD IN HOURS)
C                       J=12-TAU (PROJECTION IN HOURS)
C                       J=13-I (INTERPOLATION TYPE)
C                       J=14-S (SMOOTHING INDICATOR)
C                       J=15-G (GRID INDICATOR)
C               JD(J) = THE BASIC INTEGER PREDICTOR ID (J=1,4).
C                       THIS IS THE SAME AS ID(J), EXCEPT THAT
C                       THE PORTIONS PERTAINING TO PROCESSING
C                       ARE OMITTED:
C                       B = IDPARS(3),
C                       T = IDPARS(8),
C                       I = IDPARS(13),
C                       S = IDPARS(14),
C                       G = IDPARS(15).
C                       JD() IS USED TO HELP IDENTIFY THE BASIC MODEL
C                       FIELDS AS READ FROM THE ARCHIVE. (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH PREDICTOR IS NEEDED.
C                       (INPUT)
C                ND11 = MAXIMUM NUMBER OF GRID COMBINATIONS THAT CAN
C                       BE DEALT WITH ON THIS RUN.  LAST DIMENSION 
C                       OF NGRIDC(,). (INPUT)
C               NSLAB = THE NUMBER OF THE SLAB IN DIR(, ,) AND
C                       IN NGRIDC(,) DEFINING THE CHARACTERISTICS
C                       OF THIS GRID. (OUTPUT)
C            IPACK(J) = WORK ARRAY (J=1,ND5). (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5). (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ) AND IWORK( ).
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE
C                       DATA STORED (L=1,12) (J=1,LITEMS).
C                       (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE() WHERE
C                              THE DATA START.  WHEN ON DISK,
C                              THIS IS MINUS THE RECORD NUMBER WHERE
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR(, ,L) AND
C                              IN NGRIDC(,L) DEFINING THE
C                              CHARACTERISTICS OF THIS GRID.
C                       L=11 --THE NUMBER OF THE PREDICTOR IN THE SORTED
C                              LIST IN ID(,N) (N=1,NPRED) FOR WHICH
C                              THIS VARIABLE IS NEEDED, WHEN IT IS
C                              NEEDED ONLY ONCE FROM LSTORE(,).
C                              WHEN IT IS NEEDED MORE THAN ONCE, THE 
C                              VALUE IS SET = 7777.
C                       L=12 --USED INITIALLY IN ESTABLISHING
C                              MSTORE(,). LATER USED AS A WAY OF
C                              DETERMINING WHETHER TO KEEP THIS
C                              VARIABLE.
C                 ND9 = THE SECOND DIMENSION OF LSTORE(,). (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE(,)
C                       THAT HAVE BEEN USED IN THIS RUN. (INPUT)
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA
C                       IDENTIFIED IN LSTORE(,) (J=1,ND10).
C                       WHEN CORE() IS FULL DATA ARE STORED ON DISK.
C                       (INPUT)
C                ND10 = DIMENSION OF CORE(). (INPUT)
C               LASTL = THE LAST LOCATION IN CORE( ) USED FOR MOS-2000 INTERNAL
C                       STORAGE.  INITIALIZED TO 0 ON FIRST ENTRY TO GSTORE.
C                       ALSO INITIALIZED IN U201 IN CASE GSTORE IS NOT ENTERED.
C                       (INPUT-OUTPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE. (INPUT)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK FOR MOS-2000
C                       INTERNAL STORAGE.  MUST BE CARRIED WHENEVER GSTORE
C                       IS TO BE CALLED.  (INPUT)
C              NSTORE = THE NUMBER OF TIMES GSTORE HAS BEEN ENTERED.  GSTORE
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  (OUTPUT)
C              NFETCH = INCREMENTED EACH TIME GFETCH IS ENTERED.
C                       IT IS A RUNNING COUNT FROM THE BEGINNING OF
C                       THE PROGRAM.  THIS COUNT IS MAINTAINED IN
C                       CASE THE USER NEEDS IT (DIAGNOSTICS, ETC.).
C                       (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).
C                       (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).
C                       (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).
C                       IS2(3) AND IS2(4) ARE USED BY THE CALLING
C                       PROGRAM AS THE GRID DIMENSIONS.
C                       (INTERNAL-OUTPUT)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).
C                       (INTERNAL)
C                 ND7 = DIMENSION OF IS0(),IS1(),IS2(), AND IS4().
C                       NOT ALL LOCATIONS ARE USED. (INPUT)
C               ND2X3 = DIMENSION OF SEVERAL VARIABLES.  THE SIZE OF
C                       THE GRID IS NOT KNOWN BEFORE FDTK AND FDDP
C                       ARE FETCHED.  ALL WORK ARRAYS ARE DIMENSIONED
C                       ND2X3                              (INPUT)
C               ISTAV = 1 SINCE THE DATA RETURNED ARE STATION DATA.
C                       (OUTPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING 
C                       USED (EITHER 32 OR 64). (INPUT)
C              MISTOT = TOTAL NUMBER OF TIMES A MISSING INDICATOR
C                       HAS BEEN ENCOUNTERED IN UNPACKING GRIDS.
C                       (INPUT-OUTPUT)
C              FD1(K) = CONTAINS GRID BINARY OF THE BASE MODEL FIELD. 
C                       (OUTPUT)
C              FD2(K) = WORK ARRAYS TO HOLD THE 1000 MB HEIGHTS (INTERNAL)
C              FD3(K) = WORK ARRAYS TO HOLD THE 850 MB HEIGHTS (INTERNAL)
C              FD4(K) = WORK ARRAYS TO HOLD BASE MODEL FIELD AFTER BEING
C                       INTERPOLATED TO STATIONS (INTERNAL)
C          FD5(ND2X3) = ARRAY TO HOLD COEFFICIENTS. (INTERNAL)
C          FD6(ND2X3) = ARRAY TO HOLD COEFFICIENTS. (INTERNAL)
C              KFILRA = UNIT NUMBER OF RANDOM ACCESS FILES.  (INPUT)
C              RACESS = NAME OF RANDOM ACCESS FILES.  (INPUT)
C               NUMRA = NUMBER OF RANDOM ACCESS FILES.  (INPUT)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT WITH.
C                       DIMENSION OF SEVERAL VARIABLES.  (INPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST, EXCEPT POSSIBLY 
C                       CCALLD( ) AND CCALLP( ).  (CHARACTER*8)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,NSTA).
C                       EQUIVALENCED TO CCALLD( ).  (INTERNAL)
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,NSTA).  
C           ISDATA(K) = WORK ARRAY (K=1,ND1).  (INTERNAL)
C            SDATA(K) = SSR DATA RETURNED FROM SUBROUTINE (K=1,NSTA).
C                       (OUTPUT)
C                NSTA = NUMBER OF STATIONS OR LOCATIONS BEING DEALT WITH.
C                       (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS, EITHER 1 OR 2.  (INPUT)
C           DIR(K,J,) = THE IX (J=1) AND JY (J=2) POSITIONS ON THE
C                       GRID FOR STATION K (K=1,NSTA).  (INPUT)  
C                 IER = STATUS RETURN
C                         0 = GOOD RETURN
C                       100 = GRID CHARACTERISTICS NOT THE SAME FOR
C                             850 AND 1000 MB HEIGHTS.
C                       103 = IDPARS(1) AND IDPARS(2) DO NOT INDICATE SSR
C                             OR THE FETCH FOR THE COEFFICIENT FAILED.
C                       WHEN IER NE 0, DATA ARE RETURNED AS MISSING.
C                       (INTERNAL-OUTPUT)
C
C        ADDITIONAL VARIABLES
C
C                   J = LOOP CONTROL VARIABLE
C               MISSP = PRIMARY MISSING VALUE INDICATOR.  RETURNED AS
C                       0 WHEN DATA ARE NOT PACKED. (INTERNAL)
C               MISSS = SECONDARY MISSING VALUE INDICATOR.  RETURNED AS
C                       0 WHEN DATA ARE NOT PACKED.  (INTERNAL)
C               NPACK = 2 FOR TDL GRIB PACKED DATA; 1 FOR NOT PACKED
C                       THIS IS RETURNED FROM GFETCH. (INTERNAL)
C              NTIMES = THE NUMBER OF TIMES, INCLUDING THIS ONE,
C                       THAT THE RECORD HAS BEEN FETCHED.  THIS IS 
C                       STORED IN LSTORE(9,). (INTERNAL)
C              NWORDS = NUMBER OF WORDS RETURNED IN DATA().  THIS 
C                       IS RETURNED FROM GFETCH (INTERNAL)
C               IFLAG = FLAG SET TO INDICATE WHICH OF THE FOUR SSRS IS
C                       BEING PROCESSED. (INTERNAL)
C              THRESH = CUTOFF USED IF THE SSR IS BASED ON A GRID BINARY. 
C                       (INTERNAL)
C                  MD = ARRAY TO HOLD THE IDS OF VARIABLES TO BE FETCHED.
C                       (INTERNAL)
C                  LD = ARRAY TO HOLD THE IDS OF VARIABLES TO BE FETCHED.
C                       (INTERNAL)
C           MDPARS(J) = ARRAYS TO HOLD ID OF VARIABLES TO BE FETCHED (J=1,15). 
C                       (INTERNAL)
C           LDPARS(J) = ARRAYS TO HOLD ID OF VARIABLES TO BE FETCHED (J=1,15).
C                       (INTERNAL)
C        1         2         3         4         5         6         7 X
C
C        NONSYSTEM SUBROUTINES USED
C            GFETCH, INTRPB, PRSID1, CONST, SMTH5, SMTH9, SMTH25, SMTH2X,
C            SMTH3X
C
      CHARACTER*8 CCALL(ND1,6),CCALLD(ND1) 
      CHARACTER*60 RACESS(NUMRA) 
C
      INTEGER IDPARS(15),JD(4)
      INTEGER ICALLD(L3264W,ND1),ISDATA(ND1)
      INTEGER IPACK(ND5),IWORK(ND5)
      INTEGER IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      INTEGER LSTORE(12,ND9)
      INTEGER KFILRA(NUMRA)
      INTEGER MD(4),LD(4),LD1(4),MDPARS(15),MD1(4),MDPARS1(15)
      INTEGER IER,ISTAV,KFILDO,KFIL10,L3264B,LITEMS,
     1        MISTOT,NBLOCK,ND2X3,ND1,ND5,ND7,ND9,ND10,ND11,
     2        NDATE,NFETCH,NSLAB,NSLAB1,IFLAG,IP12,
     3        MISSP,MISSS,NPACK,NTIMES,NWORDS,NX,NY,J,
     4        NUMRA,NSTA,LASTL,LASTD,NSTORE
C
      REAL SDATA(ND1)
      REAL FD1(ND2X3),FD2(ND2X3),FD3(ND2X3),
     1     FD4(ND2X3),FD5(ND2X3),FD6(ND2X3),SWORK(ND2X3)
      REAL CORE(ND10)
      REAL DIR(ND1,2,ND11)
      REAL THRESH
C
      IER=0
      ISTAV=1
C
C        TEST THE ID TO SEE WHICH OF THE FOUR SSR'S THE USER
C        IS LOOKING FOR.  SET THE FLAG TO THE NUMBER, AND SET THE
C        ID FOR THE BASE FIELD AND CUTOFF FOR THE GRID BINARY IF 
C        THERE IS ONE. 
C
      IF((IDPARS(1).EQ.001).AND.(IDPARS(2).EQ.700))THEN
	IFLAG=1
	THRESH=1300
C      
      ELSE IF((IDPARS(1).EQ.002).AND.(IDPARS(2).EQ.700))THEN
	IFLAG=2
	LD(1)=002001 * 1000 + IDPARS(4)
	LD(2)=2
	LD(3)=IDPARS(9)*1000000 + IDPARS(12)
	LD(4)=0
	THRESH=275
C
      ELSE IF((IDPARS(1).EQ.002).AND.(IDPARS(2).EQ.710))THEN
	IFLAG=3
	LD(1)=002000 * 1000 + IDPARS(4)
	LD(2)=850
	LD(3)=IDPARS(9)*1000000 + IDPARS(12)
	LD(4)=0
	THRESH=273
C
      ELSE IF((IDPARS(1).EQ.002).AND.(IDPARS(2).EQ.715))THEN
	IFLAG=4
	LD(1)=002000 * 1000 + IDPARS(4)
	LD(2)=850
	LD(3)=IDPARS(9)*1000000 + IDPARS(12)
	LD(4)=0
C
      ELSE
       WRITE(12,101)(JD(J),J=1,4)
 101   FORMAT(/,' ****IDPARS(1) AND IDPARS(2) DO NOT INDICATE SSR',
     1          ' PREDICTOR. ',I9.9,2I10.9,I4.3,
     2          ' NOT COMPUTED IN SSR. ')
       IER = 103
       GO TO 800
      ENDIF     
C
C	 FOR ALL THE SSRS OTHER THAN THE 1000-850 MB THICKNESS ONE,
C        USE GFETCH TO GET THE BASE FIELD.  THE 1000-850 MB THICKNESS
C        MUST BE DONE SEPARATELY BECAUSE THE THICKNESS MUST BE COMPUTED
C        REGARDLESS OF WHICH SSR THE USER WANTS, BY THE END OF THIS
C        IF TEST, THE BASE FIELD WILL BE STORED IN FD1.
C
      IF(IFLAG.GT.1)THEN
C       
C           CALL GFETCH TO GET THE BASE FIELD.  THE VALUES FOR LD WERE
C           SET ABOVE.
C
	 CALL GFETCH(KFILDO,KFIL10,LD,7777,LSTORE,ND9,LITEMS,
     1               IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,FD1,ND2X3,
     2               NWORDS,NPACK,NDATE,NTIMES,CORE,ND10,
     3               NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,
     4               1,IER)
         IF(MISSP.NE.0)MISTOT=MISTOT+1 
         IF(IER.NE.0) GOTO 800
C
	 NX=IS2(3)
	 NY=IS2(4)
C
      ELSE
C
C          FOR THE 1000-850 MB SSR, YOU MUST GFETCH BOTH THE 850 MB HEIGHT
C          AND THE 1000 MB HEIGHT AND COMPUTE THE THICKNESS.
C
C          GET THE 1000 MB HEIGHT.
C  
        LD(1)=001000000+IDPARS(4)
        LD(2)=000001000
        LD(3)=IDPARS(9)*1000000+IDPARS(12)  
        LD(4)=0 
C
C          CALL GFETCH TO GET THE 1000 MB HEIGHT 
C
        CALL GFETCH(KFILDO,KFIL10,LD,7777,LSTORE,ND9,LITEMS,
     1              IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,FD2,ND2X3,
     2              NWORDS,NPACK,NDATE,NTIMES,CORE,ND10,
     3              NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,
     4              1,IER)
C
        IF(MISSP.NE.0)MISTOT=MISTOT+1 
        IF(IER.NE.0) GOTO 800
C
	NX=IS2(3)
	NY=IS2(4)
C
C          GET THE 850 MB HEIGHT. 
C  
        LD1(1)=001000000+IDPARS(4)
        LD1(2)=000000850
        LD1(3)=IDPARS(9)*1000000+IDPARS(12)  
        LD1(4)=0 
C
C          CALL GFETCH TO GET THE 850 MB HEIGHT
C
        CALL GFETCH(KFILDO,KFIL10,LD1,7777,LSTORE,ND9,LITEMS,
     1              IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,FD3,ND2X3,
     2              NWORDS,NPACK,NDATE,NTIMES,CORE,ND10,
     3              NBLOCK,NFETCH,NSLAB1,MISSP,MISSS,L3264B,
     4              1,IER)
        IF(MISSP.NE.0)MISTOT=MISTOT+1 
        IF(IER.NE.0) GOTO 800
	NX1=IS2(3)
	NY1=IS2(4)
C
	IF(NSLAB1.NE.NSLAB.OR.NX1.NE.NX.OR.NY1.NE.NY)THEN
	  WRITE(KFILDO,200)NSLAB1,NSLAB
 200	  FORMAT(/,' ****THE CHARACTERISTICS OF THE 1000 MB GRID',
     1		 ' ARE DIFFERENT FROM THE 850 MB GRID',I3,2X,I3)
           IER=100
	   GOTO 800
        ENDIF
C
C          NOW COMPUTE THE 1000-850 MB HEIGHT.
C
        DO I=1,NX*NY
	 FD1(I)=FD3(I)-FD2(I)
       	ENDDO	
C
      ENDIF
C
C        THE REST OF THE ALGORITHM IS PERFORMED FOR ALL FOUR SSRS,
C        WITH THE EXCEPTION OF MAKING THE BASE FOR SSR4 INTO A 
C        BINARY.
C
C        MAKE THE BASE FIELD INTO A GRID BINARY FOR SSRS 1, 2 & 3.
C
      IF(IFLAG.NE.4)THEN	
C
       DO I=1,NX*NY
C
        IF(FD1(I).GE.THRESH)THEN
         FD1(I)=1.0
        ELSE
         FD1(I)=0.
        ENDIF
C
       ENDDO
C
      ENDIF
C
C        SMOOTH BASE FIELD GRID BINARIES IF DESIRED.
C        THE USER SPECIFIES THE SMOOTHING THEY WANT IN THE SSR ID.
C
      IF(IDPARS(14).EQ.1)CALL SMTH5(KFILDO,FD1,SWORK,NX,NY)
      IF(IDPARS(14).EQ.2)CALL SMTH9(KFILDO,FD1,SWORK,NX,NY)
      IF(IDPARS(14).EQ.3)CALL SMTH25(KFILDO,FD1,SWORK,NX,NY)
      IF(IDPARS(14).EQ.4)CALL SMTH2X(KFILDO,FD1,SWORK,NX,NY)
      IF(IDPARS(14).EQ.5)CALL SMTH3X(KFILDO,FD1,SWORK,NX,NY)
C
C        INTERPOLATE BASE FIELD GRIB BINARIES TO STATIONS.
C
      CALL INTRPB(KFILDO,FD1,NX,NY,DIR(1,1,NSLAB),ND1,NSTA,FD4) 
C
C        FETCH THE B1 COEFFICIENT FROM THE CONSTANT FILE.  SET THE
C        FIRST WORD OF THE CONSTANT DEPENDING ON WHICH SSR YOU ARE
C        COMPUTING.
C
      IF(IFLAG.EQ.1) MD(1)=461701000
      IF(IFLAG.EQ.2) MD(1)=462701000
      IF(IFLAG.EQ.3) MD(1)=462711000
      IF(IFLAG.EQ.4) MD(1)=462716000
C
      MD(2)=010190000
      MD(3)=000000000
      MD(4)=000000000   
C
      CALL PRSID1(KFILDO,MD,MDPARS)
C
      CALL CONST(KFILDO,KFIL10,IP12,
     1           MD,MDPARS,JD,NDATE,
     2           KFILRA,RACESS,NUMRA,
     3           CCALL,ICALLD,CCALLD,
     4           ISDATA,FD5,ND1,NSTA,
     5           IPACK,IWORK,FD2,ND2X3,
     6           LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     7           NBLOCK,LASTD,NSTORE,NFETCH,
     8           IS0,IS1,IS2,IS4,ND7,
     9           ISTAV,L3264B,L3264W,IER)
C
      IF(IER.NE.0)THEN
	WRITE(KFILDO,126)IER
  126    FORMAT('     FETCHING B1 COEFFICIENT FETCH FAILED IN SSR',
     1          ' IN CONST AT 126, IER =',I4)
C          THIS DIAGNOSTIC WILL FOLLOW ONE IN CONST.
	GOTO 800
      ENDIF
C
C        FETCH THE B0 COEFFICIENT FROM THE CONSTANT FILE.
C        SET THE FIRST WORD OF THE ID DEPENDING ON WHICH
C        SSR YOU ARE COMPUTING.
C
      IF(IFLAG.EQ.1) MD1(1)=461700000 
      IF(IFLAG.EQ.2) MD1(1)=462700000 
      IF(IFLAG.EQ.3) MD1(1)=462710000 
      IF(IFLAG.EQ.4) MD1(1)=462715000 
C
      MD1(2)=010190000
      MD1(3)=000000000
      MD1(4)=000000000   
C
      CALL PRSID1(KFILDO,MD1,MDPARS1)
C
      CALL CONST(KFILDO,KFIL10,IP12,
     1           MD1,MDPARS1,JD,NDATE,
     2           KFILRA,RACESS,NUMRA,
     3           CCALL,ICALLD,CCALLD,
     4           ISDATA,FD6,ND1,NSTA,
     5           IPACK,IWORK,FD2,ND2X3,
     6           LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     7           NBLOCK,LASTD,NSTORE,NFETCH,
     8           IS0,IS1,IS2,IS4,ND7,
     9           ISTAV,L3264B,L3264W,IER)
      IF(IER.NE.0)THEN
	WRITE(KFILDO,127)IER
  127    FORMAT('     FETCHING B0 COEFFICIENT FETCH FAILED IN SSR',
     1          ' IN CONST AT 127, IER =',I4)
C          THIS DIAGNOSTIC WILL FOLLOW ONE IN CONST.
	GOTO 800
      ENDIF
C
C        COMPUTE THE SSR USING THE FORMULA
C        SSR=B1*BASE FIELD +B0.
C
      DO J=1,NSTA  
C
       IF((NINT(FD4(J)).EQ.9999).OR.(NINT(FD5(J)).EQ.9999).
     1     OR.(NINT(FD6(J)).EQ.9999))THEN
        SDATA(J)=9999.
       ELSE
        SDATA(J)=FD4(J)*FD5(J)+FD6(J)
	IF(SDATA(J).GT.1.)SDATA(J)=1.
	IF(SDATA(J).LT.0)SDATA(J)=0.
       ENDIF
C
      ENDDO
C
      GO TO 900
C 
C        SET OUTPUT FIELD TO MISSING WHEN AN ERROR HAS OCCURRED.
C
  800 DO J=1,ND1
      SDATA(J)=9999.
      ENDDO
C
  900 RETURN
      END
