      SUBROUTINE ZRPRED_OLD(KFILDO,KFIL10,IDPARS,JD,NDATE,NGRIDC,ND11,
     1    NSLAB,IPACK,IWORK,DATA,ND5,LSTORE,ND9,LITEMS,CORE,ND10,NBLOCK,
     2   NFETCH,IS0,IS1,IS2,IS4,ND7,
     3   ND2X3,ISTAV,L3264B,MISTOT,IER)
C
C
C        MAY    1999    ALLEN    TDL    MOS-2000
C
C        PURPOSE:  THIS SUBROUTINE PRODUCES A PREDICTOR THAT INDICATES
C                  WHETHER THE VERTICAL WETBULB TEMPERATURE PROFILE, IN 
C                  CONJUNCTION WITH THE SURFACE TEMPERATURE, IS
C                  CONDUCIVE TO THE OCCURANCE OF FREEZING RAIN.
C                  THIS SUBROUTINE ALLOWS FOR THREE DIFFERENT VERTICAL
C                  PROFILES IN THE WETBULB DATA, NAMELY:
C                      003151 - GFS PROFILE PRIOR TO 10/1/98, 3-HR PCP, WETBULB
C                      003155 - GFS PROFILE PRIOR TO 10/1/98, 12-HR PCP, 2-M TEMP
C                       THE FOLLOWING THREE IDS HAVE BEEN DISABLED IN THIS _OLD VERSION   
C                        003152 - ETA (NOT CURRENTLY WORKING)
C                        003153 - GFS PROFILE AFTER 10/1/98, 3-HR PCP, WETBULB
C                        003154 - GFS PROFILE PRIOR TO 10/1/98, 12-HR PCP, WETBULB
C
C                  NOTE:  THIS ROUTINE DOES NOT WORK FOR THE NGM.
C         
C        HISTORY:   
C        99-05   	ALLEN	THIS SUBROUTINE IS NEW TO U201.
C        00-07-24	ALLEN	CHANGED TO BE ABLE TO GET PRECIP
C                               AMOUNTS FOR MRF,NGM, AND ETA.  ALSO
C                               ADDED CHECKS THAT THE USER IS LOOKING
C                               FOR THE RIGHT TIME FOR EACH MODEL (I.E
C                               AVN ON 3-HRS, MRF ON 12-HRS.  CURRENTLY
C                               THIS ROUTINE DOES NOT WORK FOR THE
C                               NGM OR THE ETA
C        00-08-03       ALLEN   TOOK OUT ALL REFERENCES TO THE NGM.  
C                               CHANGED MRF TO CALL FOR 2-M TEMP
C                               RATHER THAN 2-M WETBULB CAUSE IT'S NOT
C                               AVAILABLE IN THE REANALYSIS DATA.  IF WE
C                               DECIDE NOT TO USE THE REANALYSIS DATA FOR
C                               MRF PTYPE, WE WILL CHANGE IT BACK TO 2M
C                               WETBULB.
C        02-08-01    COSGROVE   WHEN WE SWITCHED TO THE GFS WORLD, THERE WAS
C                               NO LONGER 12-HR PRECIP FOR THE MRF.  HAD TO
C                               CHANGE ROUTINE TO LOOK FOR 12-HR PCP IN THE
C                               MODEL FILE, BUT IF IT IS NOT FOUND, THEN CALL
C                               TPCP12 TO COMPUTE IT
C        02-10-30       WEISS   CHANGED ND5 TO ND2X3. 
C        03-03-18    COSGROVE   ANOTHER CHANGE FOR THE GFS TRANSITION.  WE 
C                               PREVIOUSLY USED THE MODEL NUMBER TO DISTINGUISH
C                               BETWEEN THE AVN (USE 3-HR PCP) AND THE MRF (USE
C                               12-HR PCP).  NOW THAT ALL GFS IS MODEL #8, 
C                               MODIFIED ROUTINE TO ADD MORE IDS (154, 155) AND
C                               USE FFF TO DETERMINE PCP AMT AND TEMP, NOT DD.
C        03-07-16    COSGROVE   MADE THIS VERSION ZRPRED_OLD.  THERE IS AN ERROR IN
C                               THIS VERSION.  DISABLED FFF = 152,153,154 BECAUSE 
C                               THEY WERE NEVER USED IN OPERATIONS.  THIS VERSION
C                               WILL ONLY BE USED IN OPERATIONS TO COMPUTE 003151
C                               AND 003155 UNTIL PTYPE EQNS ARE REDEVELOPED.
C        03-09-25    COSGROVE   FIXED INDEX AT STATEMENT 800.
C        04-01-05    COSGROVE   MODIFIED CALLS TO WETBULBT TO MATCH NEW VERSION
C
C        DATA SET USE
C              KFILDO = DEFAULT UNIT NUMBER FOR OUTPUT(PRINT) FILE.
C                       (OUTPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM
C                       ACCESS.(INPUT-OUTPUT)
C
C        VARIABLES
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA
C                       IDENTIFIED IN LSTORE(,) (J=1,ND10).
C                       WHEN CORE() IS FULL DATA ARE STORED ON DISK.
C                       (INPUT)
C             DATA( ) = THE ZRPREDICTOR, CALCULATED FROM THE VERTICAL
C                       WETBULB TEMPERATURE PROFILE AND THE SURFACE 
C                       TEMPERATURE. (OUTPUT)
C                   I = LOOP CONTROL VARIABLE
C           IDPARS(J) = THE PARSED, INDIVIDUAL COMPONENTS OF THE 
C                       PREDICTOR ID CORRESPONDING TO ID() (J=1,15).
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY
C                                      1 LAYER)
C                       J=7--LTLTLTLT (TOP OF LAYER)
C                       J=8--T (TRANSFORMATION)
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND 
C                                BACK IN TIME)
C                       J=10-OT (TIME APPLICATION)
C                       J=11-OH (TIME PERIOD IN HOURS)
C                       J=12-TAU (PROJECTION IN HOURS)
C                       J=13-I (INTERPOLATION TYPE)
C                       J=14-S (SMOOTHING INDICATOR)
C                       J=15-G (GRID INDICATOR)
C                 IER = STATUS RETURN
C                         0 = GOOD RETURN
C                       100 = THE TWO GRIDS NEEDED ARE NOT THE SAME SIZE
C                       101 = GRID SIZE IS TOO BIG FOR ???(), WHOSE 
C                             DIMENSION IS ND5.
C                       103 = IDPARS(1) AND IDPARS(2) DO NOT INDICATE
C                             ZRPRED.
C                       200 = THE USER WAS TRYING TO USE AND NDATE
C                             FOR WHICH PCP AMT DATA WAS NOT AVAILABLE.
C                       SEE GFETCH FOR OTHER VALUES.
C                       WHEN IER NE 0, DATA ARE RETURNED AS MISSING.
C                       (INTERNAL-OUTPUT)
C            IPACK(J) = WORK ARRAY (J=1,ND2X3). (INTERNAL)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).
C                       (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).
C                       (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).
C                       IS2(3) AND IS2(4) ARE USED BY THE CALLING
C                       PROGRAM AS THE GRID DIMENSIONS.
C                       (INTERNAL-OUTPUT)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).
C                       (INTERNAL)
C                 ISO = 1 FOR ISOBARIC, 2 FOR ISOHYETAL SURFACE,
C                       3 FOR SIGMA SURFACE(INTERNAL)
C               ISTAV = 0 SINCE THE DATA RETURNED ARE GRID DATA.
C                       (OUTPUT)
C            IWORK(J) = WORK ARRAY (J=1,ND2X3). (INTERNAL)
C                   J = LOOP CONTROL VARIABLE
C               JD(J) = THE BASIC INTEGER PREDICTOR ID (J=1,4).
C                       THIS IS THE SAME AS ID(J), EXCEPT THAT
C                       THE PORTIONS PERTAINING TO PROCESSING
C                       ARE OMITTED:
C                       B = IDPARS(3),
C                       T = IDPARS(8),
C                       I = IDPARS(13),
C                       S = IDPARS(14),
C                       G = IDPARS(15), AND
C                       THRESH.
C                       ID() IS USED TO HELP IDENTIFY THE BASIC MODEL
C                       FIELDS AS READ FROM THE ARCHIVE. (INPUT)
C              KFILDO = DEFAULT UNIT NUMBER FOR OUTPUT (PRINT) FILE.
C                       (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING 
C                       USED (EITHER 32 OR 64). (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE(,)
C                       THAT HAVE BEEN USED IN THIS RUN. (INPUT)
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE
C                       DATA STORED (L=1,12) (J=1,LITEMS).
C                       (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE() WHERE
C                              THE DATA START.  WHEN ON DISK,
C                              THIS IS MINUS THE RECORD NUMBER WHERE
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR(, ,L) AND
C                              IN NGRIDC(,L) DEFINING THE
C                              CHARACTERISTICS OF THIS GRID.
C                       L=11 --THE NUMBER OF THE PREDICTOR IN THE SORTED
C                              LIST IN ID(,N) (N=1,NPRED) FOR WHICH
C                              THIS VARIABLE IS NEEDED, WHEN IT IS
C                              NEEDED ONLY ONCE FROM LSTORE(,).
C                              WHEN IT IS NEEDED MORE THAN ONCE, THE 
C                              VALUE IS SET = 7777.
C                       L=12 --USED INITIALLY IN ESTABLISHING
C                              MOSTORE(,). LATER USED AS A WAY OF
C                              DETERMINING WHETHER TO KEEP THIS
C                              VARIABLE.
C            MDPARS() = PARSED ID USED IN SUBROUTINE PRSID1 FOR
C                       SUBROUTINE WETBULBT
C               MISSP = PRIMARY MISSING VALUE INDICATOR.  RETURNED AS
C                       0 WHEN DATA ARE NOT PACKED. (INTERNAL)
C               MISSS = SECONDARY MISSING VALUE INDICATOR.  RETURNED AS
C                       0 WHEN DATA ARE NOT PACKED.  (INTERNAL)
C              MISTOT = TOTAL NUMBER OF TIMES A MISSING INDICATOR
C                       HAS BEEN ENCOUNTERED IN UNPACKING GRIDS.
C                       (INPUT-OUTPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE. (INPUT)
C               ND2X3 = DIMENSION OF SEVERAL VARIABLES.  
C                       ALL WORK ARRAYS ARE DIMENSIONED ND2X3. (INPUT)
C                 ND5 = FORMER DIMENSION OF IPACK(), AND IWORK()  ND5
C                       MUST BE EQUAL TO ND2X3.  ALL DATA ARRAYS
C                       ARE DIMENSIONED ND5.            (INPUT)
C                       NOTE: ABOVE STATEMENT IS NULL AND VOID.
C                 ND7 = DIMENSION OF IS0(),IS1(),IS2(), AND IS4().
C                       NOT ALL LOCATIONS ARE USED. (INPUT)
C                 ND9 = THE SECOND DIMENSION OF LSTORE(,). (INPUT)
C                ND10 = DIMENSION OF CORE(). (INPUT)
C                ND11 = MAXIMUM NUMBER OF GRID COMBINATIONS THAT CAN
C                       BE DEALT WITH ON THIS RUN.  LAST DIMENSION 
C                       OF NGRIDC(,). (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH PREDICTOR IS NEEDED.
C                       (INPUT)
C              NFETCH = INCREMENTED EACH TIME GFETCH IS ENTERED.
C                       IT IS A RUNNING COUNT FROM THE BEGINNING OF
C                       THE PROGRAM.  THIS COUNT IS MAINTAINED IN
C                       CASE THE USER NEEDS IT(DIAGNOSTICS, ETC.).
C                       (OUTPUT)
C         NGRIDC(L,M) = HOLDS THE GRID CHARACTERISTICS (L=1,6) FOR
C                       EACH GRID COMBINATION (M=1,NGRID).
C                       L=1--MAP PROJECTION NUMBER (3=LAMBERT, 5=
C                            POLAR STEREOGRAPHIC).
C                       L=2--GRID LENGTH IN METERS.
C                       L=3--LATITUDE AT WHICH THE GRID LENGTH IS
C                            CORRECT *1000.
C                       L=4--GRID ORIENTATION IN DEGREES * 1000.
C                       L=5--LATITUDE OF LL CORNER IN DEGREES *1000.
C                       L=6--LONGITUDE OF LL CORNER IN DEGREES
C                            *1000.
C               NPACK = 2 FOR TDL GRIB PACKED DATA; 1 FOR NOT PACKED
C                       THIS IS RETURNED FROM GFETCH. (INTERNAL)
C               NSLAB = THE NUMBER OF THE SLAB IN DIR(, ,) AND
C                       IN NGRIDC(,) DEFINING THE CHARACTERISTICS
C                       OF THIS GRID. (OUTPUT)
C              NTIMES = THE NUMBER OF TIMES, INCLUDING THIS ONE,
C                       THAT THE RECORD HAS BEEN FETCHED.  THIS IS 
C                       STORED IN LSTORE(9,). (INTERNAL)
C              NWORDS = NUMBER OF WORDS RETURNED IN DATA().  THIS 
C                       IS RETURNED FROM GFETCH (INTERNAL)
C
C     NON-SYSTEM SUBROUTINES USED
C         GFETCH,PRSID1,WETBULBT,TPCP3,TPCP12
C
      IMPLICIT NONE
C     
      INTEGER ICCC,IFFF,LX,LY,NSLAB1,MD(4),MD1(4),MD2(4)
      INTEGER CONTINUE(ND2X3),SFCFOUND(ND2X3),INVERTW(ND2X3)
      INTEGER POP(ND2X3),INVERTC(ND2X3),LEVEL(11) 
      INTEGER LSTORE(12,ND9),NGRIDC(6,ND11)
      INTEGER IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      INTEGER IPACK(ND2X3),IWORK(ND2X3)
      INTEGER IDPARS(15),MDPARS(15)
      INTEGER JD(4),NUMLEV
      INTEGER I,K,IER,ISO,ISTAV,J,KFILDO,KFIL10,L3264B,LITEMS,
     1        MISSP,MISSS,MISTOT,
     2        NBLOCK,ND2X3,ND5,ND7,ND9,ND10,ND11,
     3        NDATE,NFETCH,NPACK,NSLAB,
     4        NTIMES,NWORDS
      REAL CORE(ND10),DATA(ND2X3),TEMP(ND2X3),TEMP1(ND2X3),
     1     TEMP2(ND2X3)
      REAL FDSP(ND2X3),FDWB(ND2X3),FDPOP(ND2X3),TCOLD(ND2X3)
      REAL TWARM(ND2X3),TSFC(ND2X3),TBELOW(ND2X3),TCRIT1,TCRIT2
      REAL TEMP3(ND2X3),TEMP4(ND2X3),FD1(ND2X3),FD2(ND2X3),FD3(ND2X3)
      REAL SFCTMP(ND2X3)
C
      DATA ICCC/3/,IFFF/110/,TCRIT1/276./,TCRIT2/273./
C
C        INITIALIZE ALL THE VARIABLES INCLUDING THE WORK ARRAYS AND 
C        THE FINAL PRODUCT
      IER  =0
      ISTAV=0
      ISO = 1
      DO I=1,ND2X3
      CONTINUE(I)=1
      SFCFOUND(I)=0
      SFCTMP(I)=0.
      INVERTW(I)=0
      INVERTC(I)=0
      TCOLD(I)=9999.
      TWARM(I)=-9999.
      TSFC(I)=9999.
      TBELOW(I)=9999.
      POP(I)=0
      DATA(I)=9999.
      ENDDO
C
C        MAKE SURE THE REQUESTED PREDICTOR IS THE ZRPRED PREDICTOR.
C        7/03 - ONLY ALLOW THIS _OLD VERSION TO COMPUTE 151 AND 155
C
       IF((IDPARS(1).NE.003).OR.((IDPARS(2).NE.
     &  151).AND.(IDPARS(2).NE.155)))THEN
	IER=103
	WRITE(KFILDO,100)(JD(J),J=1,4),IER
 100    FORMAT(/'****IDPARS(1) AND IDPARS(2) DO NOT INDICATE',
     &  ' ZRPRED_OLD.  PREDICTOR ',I9.9,I10.9,I10.9,I4.3,' NOT ',
     &  'ACCOMMODATED IN ZRPRED_OLD.  IER = ',I3)
	GO TO 800
      ENDIF
C
C        NOW CHECK TO SEE WHICH VERTICAL PROFILE IS REQUESTED FOR THIS
C        VARIABLE AND SET THE LEVEL AND COUNTING INDEX ACCORDINGLY
C        ALSO, CHECK THAT THE USER IS ASKING FOR AN APPROPRIATE NDATE 
C        FOR THAT MODEL
C
C        CHECK TO SEE WHICH VERTICAL PROFILE WAS REQUESTED
C
C        GFS PRIOR TO 10/1/98 
       IF((IDPARS(2).EQ.151).OR.(IDPARS(2).EQ.154).OR.
     &     (IDPARS(2).EQ.155))THEN
	  LEVEL(1)=1000
	  LEVEL(2)=925
	  LEVEL(3)=850
	  LEVEL(4)=700
	  LEVEL(5)=500
	  NUMLEV=5
	  IF((IDPARS(2).EQ.154).OR.(IDPARS(2).EQ.155))THEN
           IF(MOD(MOD(NDATE,100),12).NE.0)THEN
            WRITE(KFILDO,120)NDATE
 120        FORMAT(/'****NDATE, ',I10,' FOR ZRPRED MUST',
     &            ' BE 00Z,OR 12Z.')
	    IER=200
	    GO TO 800
           ENDIF
          ELSEIF(IDPARS(2).EQ.151)THEN
	   IF(MOD(MOD(NDATE,100),3).NE.0)THEN
	    WRITE(KFILDO,130)NDATE
 130        FORMAT(/'****NDATE, ',I10,', FOR ZRPRED MUST',
     &             ' BE A MULTIPLE OF 3.')
	    IER=200
	    GO TO 800
           ENDIF
          ENDIF
	
C	 ETA VERTICAL PROFILE
       ELSE IF(IDPARS(2).EQ.152)THEN
	  LEVEL(1)=1000
	  LEVEL(2)=950
	  LEVEL(3)=900
	  LEVEL(4)=850
	  LEVEL(5)=800
	  LEVEL(6)=750
	  LEVEL(7)=700
	  LEVEL(8)=600
	  LEVEL(9)=500
	  NUMLEV=9
           IF(MOD(MOD(NDATE,100),6).NE.0)THEN
	    WRITE(KFILDO,140)NDATE
 140        FORMAT(/'****NDATE, ',I10,', FOR ETA ZRPRED MUST',
     &            ' BE 00Z,06Z,12Z,OR 18Z.')
	    IER=200
	    GO TO 800
           ENDIF

C        GFS VERTICAL PROFILE AFTER 10/1/98
       ELSE IF(IDPARS(2).EQ.153)THEN
	  LEVEL(1)=1000
	  LEVEL(2)=975
	  LEVEL(3)=950
	  LEVEL(4)=925
	  LEVEL(5)=900
	  LEVEL(6)=850
	  LEVEL(7)=800
	  LEVEL(8)=750
	  LEVEL(9)=700
	  LEVEL(10)=600
	  LEVEL(11)=500
	  NUMLEV=11
           IF(MOD(MOD(NDATE,100),3).NE.0)THEN
            WRITE(KFILDO,150)NDATE
 150        FORMAT(/'****NDATE, ',I10,', FOR ZRPRED MUST',
     &             ' BE A MULTIPLE OF 3.')
            IER=200
	    GO TO 800
	   ENDIF

	ENDIF
C
C        FIRST CHECK THE TEMPERATURE AT EACH GRIDPOINT TO SEE
C        IF IT IS BELOW OUR VALUE FOR FREEZING.  IF IT IS NOT, THERE CAN
C        NOT BE FROZEN PCP AND YOU SHOULD SKIP THE REST OF THE ALGORITHM
C        FOR THAT POINT AND SET THE VALUE OF ZRPRED TO 9999.  FOR THE 
C        ORIGINAL MRF DEVELOPMENT, WE USED REANALYSIS DATA, SO WE COULD NOT
C        USE A 2-M WETBULB.  SO FFF=155 USES A 2-M TEMP INSTEAD
C
C        FOR MOST, GET 2M WETBULB
C
      IF(IDPARS(2).NE.155)THEN
C        CREATE ID FOR 2M WETBULB
C
      MD(1)= ICCC * 1000000 + 111 * 1000 + IDPARS(4)
      MD(2)= 2
      MD(3)= IDPARS(9) * 1000000 + IDPARS(12)
      MD(4)= 0
C
C        CALL WETBULBT TO GET THE 2M WETBULB TEMPERATURE
C
      CALL PRSID1(KFILDO,MD,MDPARS)
      CALL WETBULBT(KFILDO,KFIL10,MDPARS,MD,NDATE,NGRIDC,ND11,
     &            NSLAB,IPACK,IWORK,FDWB,ND5,LSTORE,ND9,LITEMS,
     &            CORE,ND10,NBLOCK,NFETCH,IS0,IS1,IS2,IS4,ND7,
     &            TEMP,TEMP1,TEMP2,TEMP3,TEMP4,ND2X3,ISTAV,L3264B,
     &            MISTOT,IER)
C
C       FOR THE ORIGINAL MRF, GET THE 2M TEMPERATURE USING GFETCH
C
      ELSEIF(IDPARS(2).EQ.155)THEN
      MD(1)= 2 * 1000000 + 1 * 1000 + IDPARS(4)
      MD(2) = 2
      MD(3) = IDPARS(9) * 1000000 + IDPARS(12)
      MD(4) = 0

      CALL GFETCH(KFILDO,KFIL10,MD,7777,LSTORE,ND9,LITEMS,IS0,
     &            IS1,IS2,IS4,ND7,IPACK,IWORK,FDWB,ND2X3,NWORDS,
     &            NPACK,NDATE,NTIMES,CORE,ND10,NBLOCK,NFETCH,
     &            NSLAB,MISSP,MISSS,L3264B,1,IER)
      ENDIF

      IF(IER.NE.0)GOTO 800
C
C       RECORD THE GRID DIMENSIONS TO USE FOR VERIFICATION IN LATER
C       CALLS TO WETBULBT
C
       LX = IS2(3)
       LY = IS2(4)
       NSLAB1 = NSLAB
C
C        GO THROUGH THE GRID AND CHECK IF THE SURFACE TEMPERATURE IS 
C        BELOW THE "FREEZING THRESHOLD".  IF NOT, SET THE CONTINUE FLAG
C        TO 0 FOR NO.  ALSO CALCULATE A VALUE FOR SFCTMP.  A TEMPERATURE
C        LESS THAN 273 YIELDS A VALUE OF SFCTMP=1, A TEMPERATURE GREATER
C        THAN 276 YIELDS 0, AND A TEMPERATURE BETWEEN 273 AND 276
C        GIVES A SLIDING VALUE FROM 0 TO 1.
C
      DO I=1,LX*LY
	IF(FDWB(I).GT.276.)THEN
	  CONTINUE(I)=0
        ENDIF
	IF(FDWB(I).GE.TCRIT1)FDWB(I)=TCRIT1
	IF(FDWB(I).LE.TCRIT2)FDWB(I)=TCRIT2
	SFCTMP(I)=1. - ((FDWB(I)-TCRIT2)/(TCRIT1-TCRIT2))
      ENDDO
C
C
C         GET THE SURFACE PRESSURE FOR EACH OF THE GRIDPOINTS
C
C         SET UP THE MD ARRAY FOR SURFACE PRESSURE
C
       MD1(1)=1*1000000 +100 * 1000 + IDPARS(4)
       MD1(2)=0
       MD1(3)=IDPARS(9)*1000000 +IDPARS(12)
       MD1(4)=0
C
C         CALL GFETCH TO GET THE SURFACE PRESSURE
C
      CALL GFETCH(KFILDO,KFIL10,MD1,7777,LSTORE,ND9,LITEMS,IS0,
     &            IS1,IS2,IS4,ND7,IPACK,IWORK,FDSP,ND2X3,NWORDS,
     &            NPACK,NDATE,NTIMES,CORE,ND10,NBLOCK,NFETCH,
     &            NSLAB,MISSP,MISSS,L3264B,1,IER)
      IF(MISSP.NE.0)MISTOT=MISTOT+1
      IF(IER.NE.0) GOTO 800
C
C         CHECK THE GRID DIMENSIONS
C
      IF((NSLAB.NE.NSLAB1).OR.(IS2(3).NE.LX).OR.(IS2(4).NE.LY))THEN
       WRITE(KFILDO,200)NSLAB1,NSLAB
 200   FORMAT(/,' ****THE GRID CHARACTERISTICS OF THE SURFACE PRESSURE',
     &        ' ARE DIFFERENT.',I3,2X,I3)
       IER=100
       GOTO 800
      ENDIF
C        
C
C         GET THE APPROPRIATE PRECIP AMOUNT FOR THE MODEL REQUESTED.  
C         FOR THE "AVN VERSION" USE THE 3-HR, FOR THE ETA USE THE 6-HR,
C         AND FOR THE "MRF VERSION" USE THE 12-HR.  IF IT IS NON-ZERO, SET THE  
C         POP FLAG TO 1.  NOTE:  IN FALL 2002, THERE CEASED TO BE 12-HR
C         MRF PCP SO ROUTINE WAS CHANGED TO COMPUTE A 12 FROM TWO 6S IF
C         A 12 CAN NOT BE FOUND
C
	SELECT CASE(IDPARS(2))
C        
C         SET UP MD1(1) TO HOLD THAT MODEL'S PRECIP AMT, OR
C         IN THE CASE OF THE "AVN VERSION", CALL TPCP3 INSTEAD 
C         OF GFETCH
C
C         ETA
C
	 CASE(152)
	  MD1(1)= 3 * 1000000 + 210 * 1000 + IDPARS(4)
C  
C         GFS WITH 3-HR AVAILABLE   
C
	 CASE(151,153)
C         SET UP THE MD ARRAY FOR 3 HR PRECIP AMT 
C
       MD1(1)=3*1000000 +205 * 1000 + IDPARS(4)
       MD1(2)=0
       MD1(3)=IDPARS(9)*1000000 +IDPARS(12)
       MD1(4)=0
C
C         CALL TPCP3 TO GET THE 3-HR PRECIP 
C
      CALL PRSID1(KFILDO,MD1,MDPARS)
      CALL TPCP3(KFILDO,KFIL10,MDPARS,MD1,NDATE,
     &            NGRIDC,ND11,NSLAB,IPACK,IWORK,
     &            FDPOP,ND5,LSTORE,ND9,LITEMS,CORE,ND10,
     &            NBLOCK,NFETCH,IS0,IS1,IS2,IS4,ND7,FD1,
     &            ND2X3,ISTAV,L3264B,MISTOT,
     &            IER)
      GO TO 205
C
C         GFS BEYOND 84 HOURS, OR ORIGINAL MRF (USE 12-HR)
C
      CASE(154,155)
       MD1(1)= 3 * 1000000 + 220 * 1000 + IDPARS(4)
      END SELECT

       MD1(2) = 0
       MD1(3) = IDPARS(9) * 1000000 + IDPARS(12)
       MD1(4) = 0
C
C        CALL GFETCH TO GET THE PCP AMOUNT
C
       CALL GFETCH(KFILDO,KFIL10,MD1,7777,LSTORE,ND9,LITEMS,IS0,
     &             IS1,IS2,IS4,ND7,IPACK,IWORK,FDPOP,ND2X3,NWORDS,
     &             NPACK,NDATE,NTIMES,CORE,ND10,NBLOCK,NFETCH,
     &             NSLAB,MISSP,MISSS,L3264B,1,IER)
       IF(MISSP.NE.0)MISTOT=MISTOT+1

C         JCM--CHANGED .OR. TO .AND. BELOW 
       IF((IER.NE.0).AND.(IER.NE.47)) GOTO 800
       IF(IER.EQ.47)THEN
C
C         CALL TPCP12 TO COMPUTE THE 12-H FROM 2 6-H AMOUNTS
C
      CALL PRSID1(KFILDO,MD1,MDPARS)
      CALL TPCP12(KFILDO,KFIL10,MDPARS,MD1,NDATE,
     &            NGRIDC,ND11,NSLAB,IPACK,IWORK,
     &            FDPOP,ND5,LSTORE,ND9,LITEMS,CORE,ND10,
     &            NBLOCK,NFETCH,IS0,IS1,IS2,IS4,ND7,FD1,
     &            FD2,FD3,ND2X3,ISTAV,L3264B,MISTOT,
     &            IER)
       ENDIF
C
 205   IF(IER.NE.0) GOTO 800
C
C         CHECK THE GRID DIMENSIONS
C
      IF((NSLAB.NE.NSLAB1).OR.(IS2(3).NE.LX).OR.(IS2(4).NE.LY))THEN
       WRITE(KFILDO,210)NSLAB1,NSLAB
 210   FORMAT(/,' ****THE GRID CHARACTERISTICS OF THE PRECIP AMT',
     &        ' ARE DIFFERENT.',I3,2X,I3)
       IER=100
       GOTO 800
      ENDIF
C
       DO I=1,LX*LY
	 IF(FDPOP(I).GT.0.)THEN
	   POP(I)=1
         ENDIF
       ENDDO
C
C        NOW GO THROUGH THE UPPER LEVELS ONE LEVEL AT A TIME.  AT EACH ONE
C        DECIDE WHAT REGION OF THE SOUNDING THE POINT IS IN AND ACT ACCORDINGLY
C
      DO K=1,NUMLEV
C
C        CREATE AN ID FOR THE WETBULB TEMPERATURE AT THAT LEVEL
C
	IDPARS(7)=LEVEL(K)
	MD2(1)= ICCC * 1000000 + IFFF * 1000 + IDPARS(4)
	MD2(2)= IDPARS(7)
	MD2(3) = IDPARS(9)*1000000 +IDPARS(12)
	MD2(4) = 0

	CALL PRSID1(KFILDO,MD2,MDPARS)
        CALL WETBULBT(KFILDO,KFIL10,MDPARS,MD2,NDATE,NGRIDC,ND11,
     &            NSLAB,IPACK,IWORK,FDWB,ND5,LSTORE,ND9,LITEMS,
     &            CORE,ND10,NBLOCK,NFETCH,IS0,IS1,IS2,IS4,ND7,
     &            TEMP,TEMP1,TEMP2,TEMP3,TEMP4,ND2X3,ISTAV,L3264B,
     &            MISTOT,IER)
      IF(IER.NE.0)GOTO 800
C
C        CHECK THE GRID DIMENSIONS AGAINST THE ORIGINAL ONES.
C
      IF((NSLAB.NE.NSLAB1).OR.(IS2(3).NE.LX).OR.(IS2(4).NE.LY))THEN
	WRITE(KFILDO,300)NSLAB1,NSLAB,LEVEL(K)
 300    FORMAT(/,'****THE CHARACTERISTICS OF THE GRIDS ARE DIFFERENT.',
     &         I3,2X,I3,' GRID = ',I4)
	IER = 100
	GOTO 800
      ENDIF
C
C        GO THROUGH THE GRID ONE POINT AT A TIME.  FIRST CHECK TO
C        SEE IF THE SURFACE WAS BELOW 'FREEZING' WHEREBY YOU WOULD
C        CONTINUE PROCESSING THAT POINT. OTHERWISE, LOOP TO THE NEXT 
C        GRIDPOINT
C
      DO I=1,LX*LY
	IF(CONTINUE(I).EQ.0) GO TO 199
C
C        THE NEXT STEP IS TO CHECK WHETHER THIS PRESSURE LEVEL IS ABOVE THE
C        SURFACE.  ONCE A PRESSURE LEVEL IS LOWER THAN THE SURFACE PRESSURE
C        AT THE GRID POINT, SFCFOUND WILL BE SET TO 1
C
	IF(SFCFOUND(I).EQ.0)THEN
	  IF(K.LE.(FDSP(I)/100.))THEN
	    SFCFOUND(I)=1
          ELSE
	    GO TO 199
          ENDIF
        ENDIF
C
C        NOW DETERMINE IN WHICH REGION THIS POINT LIES IN THE VERTICAL PROFILE
C        AND SET THE PROPER INDICIES ACCORDINGLY.
C
C        REGION 1 - TEMPERATURE DECREASES WITH HEIGHT
C
	IF((FDWB(I).LE.TBELOW(I)).AND.(INVERTW(I).EQ.0))THEN
	  TBELOW(I)=FDWB(I)
C   
C        REGION 2 - TEMPERATURE INCREASES WITH HEIGHT
C
	ELSE IF(FDWB(I).GT.TBELOW(I))THEN
	  IF(INVERTW(I).EQ.0)THEN
	    TCOLD(I)=TBELOW(I)
	    INVERTW(I)=1
	    TWARM(I)=FDWB(I)
	    TBELOW(I)=FDWB(I)
          ELSEIF(INVERTW(I).EQ.1)THEN
	    TWARM(I)=FDWB(I)
	    TBELOW(I)=FDWB(I)
          ENDIF
C
C        REGION 3 - TEMPERATURE DECREASES WITH HEIGHT ABOVE
C                   AN INVERSION LAYER.
C
	ELSE IF((FDWB(I).LT.TBELOW(I)).AND.(INVERTW(I).EQ.1))THEN
	  IF(INVERTC(I).EQ.0)THEN
	    TWARM(I)=TBELOW(I)
	    INVERTC(I)=1
	    TBELOW(I)=FDWB(I)
          ELSE
	    TBELOW(I)=FDWB(I)
          ENDIF
        ENDIF
 199    CONTINUE
      ENDDO
      ENDDO
C
C        NOW CALCULATE THE VALUE FOR DATA.  IF THE SURFACE WAS COLD
C        AND THE FREEZING PRECIP VERTICAL PROFILE EXISTS, ASSIGN A VALUE
C        FROM >0 TO 1 DEPENDING ON THE SURFACE TEMPERATURE.  FURTHERMORE,
C        IF CONDITIONS ARE RIGHT FOR FREEZING PRECIPITATION AND THE 
C        MODEL IS CALLING FOR PRECIPITATION (POP=1), ADD THAT VALUE
C        TO DATA.
C
       DO I=1,LX*LY
	 IF((CONTINUE(I).EQ.1).AND.(INVERTW(I).EQ.1).AND.
     &	   (TCOLD(I).LT.273).AND.(TWARM(I).GE.270)
     &     )THEN
	    DATA(I)=SFCTMP(I)*INVERTW(I)+POP(I)
         ELSE
	    DATA(I)=0.
         ENDIF
       ENDDO
       GO TO 900
C
C      IF THERE WAS A PROBLEM IN GFETCH OR WETBULBT IT WOULD COME HERE TO
C      SET DATA TO MISSING
 800   DO I=1,ND2X3
         DATA(I)=9999.
       ENDDO
 900  RETURN
      END

