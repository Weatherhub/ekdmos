      SUBROUTINE RDSTGD(KFILDO,IP4,IP5,KFILD,IDUP,CCALL,
     1                  NAME,NELEV,IWBAN,STALAT,STALON,ITIMEZ,
     2                  IFOUND,NGP,ND1,KGP,NSTA,ND5,IER)
C 
C        SEPTEMBER 2003   GLAHN   TDL   MOS-2000
C        OCTOBER   2003   GLAHN   COMMENT CHANGE FOR ND5
C        OCTOBER   2003   GLAHN   DIAGNOSTIC MODIFIED; LASTGT=NSTA+1
C                                 CHANGED TO LASTGT=JREAD+1 IN TWO
C                                 PLACES IN DO 140 LOOP
C        OCTOBER   2003   GLAHN   DIAGNOSTIC "INTERNAL WRITE" CORRECTED
C                                 OT "INTERNAL READ" IN 4 PLACES
C        NOVEMBER  2003   GLAHN   DIAGNOSTIC CHANGED TO /D AT 122
C
C        PURPOSE 
C            TO READ A GRIDPOINT LIST AND ASSOCIATED INFORMATION FROM A
C            GRIDPOINT DIRECTORY IN ONE OR MORE GROUPS AND RETURN THE
C            LIST IN THE ORDER READ BY GROUP.  THE GRIDPOINT LIST
C            IS PUT INTO CCALL( ).  THE LIST (8 CHARACTER IDS)
C            CAN BE ON THE DEFAULT INPUT FILE, OR CAN BE ON A SEPARATE
C            FILE, BUT THE LIST CANNOT BE ON THE SAME FILE AS
C            THE DIRECTORY.  THE CALL TO RDC IS SET TO READ UP TO 
C            NT = 7 VALUES PER RECORD ACCORDING TO THE FORMAT 
C            (7(A8,1X)); HOWEVER, THE RECORD NEED NOT HAVE THAT MANY 
C            VALUES.  THIS ROUTINE IS USED FOR READING A COMPLETE LIST
C            COMPOSED OF ONE OR MORE GROUPS.  READING STOPS WHEN AN
C            EMPTY SET IN ENCOUNTERED.  DUPLICATE GRIDPOINTS ARE  
C            ALLOWED.  A DIRECTORY IS READ AND THE LIST
C            MATCHED WITH THE DIRECTORY ENTRIES.  WHEN FOUND, THE
C            ENTRIES IN NAME( ), NELEV( ), STALAT( ), AND STALON( )
C            ARE FILLED.  NAME( ) AND NELEV( ) MAY BE BLANK FOR THESE
C            GRIDPOINT VALUES, BUT THE DIRECTORY FORMAT IS THE
C            SAME AS FOR STATION CALL LETTERS.
C
C            NOTE:  RDSTGD IS FOR IDS OF A GRIDDED NATURE AND CCALL( )
C                   IS FILLED INSTEAD OF CCALL( ,L), (L=1,6) AS
C                   RDSTGN DOES.  CCALL( ) WILL BE CCALL(1,1) IN THE
C                   CALLING PROGRAMS TO MAINTAIN CONSISTENCY WITH 
C                   OTHER MOS-200 PROGRAMS.
C
C                   FOR EFFICIENCY WHEN DUPLICATES CAN BE PRESENT OR
C                   THE LIST READ INTO CCALL( ) IS NOT IN CLOSE ORDER
C                   TO THE DIRECTORY, A BINARY SEARCH IS DONE.  TO DO
C                   SO, IT IS ASSUMED THE DIRECTORY IS IN NUMERICAL
C                   ORDER.  SINCE THE DATA ARE CHARACTER, THEY HAVE 
C                   TO BE CONVERTED TO INTEGER.
C
C        DATA SET USE 
C            KFILDO   - DEFAULT UNIT NUMBER FOR OUTPUT (PRINT) FILE.
C                       (OUTPUT) 
C            IP4      - UNIT NUMBER FOR OUTPUT OF GRIDPOINT VALUES.
C                       (OUTPUT)
C            IP5      - UNIT NUMBER FOR OUTPUT OF DIRECTORY INFORMATION
C                       (OUTPUT) 
C            KFILD(J) - UNIT NUMBER FROM WHICH TO READ GRIDPOINT LIST
C                       (J=1) AND GRIDPOINT DIRECTORY (J=2).  IT IS 
C                       ASSUMED FILES HAVE BEEN OPENED.  (INPUT) 
C 
C        VARIABLES 
C              KFILDO = DEFAULT UNIT NUMBER FOR OUTPUT (PRINT) FILE.
C                       (INPUT) 
C                 IP4 = INDICATES WHETHER (>0) OR NOT (=0) THE GRIDPOINT 
C                       LIST WILL BE WRITTEN TO UNIT IP4.  IF THERE ARE
C                       INPUT ERRORS, THE GRIDPOINT LIST WILL BE WRITTEN
C                       TO THE DEFAULT OUTPUT FILE UNIT KFILDO AS WELL 
C                       AS TO UNIT IP4.  (INPUT)
C                 IP5 = INDICATES WHETHER (>0) OR NOT (=0) THE GRIDPOINT 
C                       DIRECTORY INFORMATION WILL BE WRITTEN TO UNIT
C                       IP5.  IF THERE ARE INPUT ERRORS, THE GRIDPOINT
C                       LIST WILL BE WRITTEN TO THE DEFAULT OUTPUT FILE
C                       UNIT KFILDO AS WELL AS TO UNIT IP5.  (INPUT) 
C            KFILD(J) = UNIT NUMBER FROM WHICH TO READ GRIDPOINT LIST
C                       (J=1) AND GRIDPOINT DIRECTORY (J=2).  IT IS 
C                       ASSUMED FILES HAVE BEEN OPENED.  (INPUT) 
C                IDUP = 2 WHEN DUPES ARE ALLOWED;  THIS SHOULD BE
C                         THE VALUE WHEN RDSTGD IS ENTERED.
C                       (INPUT)
C            CCALL(K) = 8-CHARACTER GRIDPOINTS FOR GRID DEVELOPMENT TO
C                       PROVIDE OUTPUT FOR (K=1,NSTA).  (CHARACTER*8)
C                       (OUTPUT)
C             NAME(K) = NAMES OF GRIDPOINTS (K=1,NSTA)  (CHARACTER*20)
C                       (OUTPUT)
C            NELEV(K) = ELEVATION OF GRIDPOINTS (K=1,NSTA).  (OUTPUT)
C            IWBAN(K) = WBAN NUMBERS RETURNED FROM DIRECTORY (K=1,NSTA).
C                       FOR GRIDPOINTS, THIS WILL LIKELY BE BLANK, BUT
C                       RESERVES THE POSSIBILITY FOR OTHER INFORMATION 
C                       IN THAT PLACE IN THE DIRECTORY.  (OUTPUT) 
C           STALAT(K) = LATITUDE OF GRIDPOINTS (K=1,NSTA).  (OUTPUT)
C           STALON(K) = LONGITUDE OF GRIDPOINTS (K=1,NSTA).  (OUTPUT)
C           ITIMEZ(K) = THE TIME ZONE INDICATOR FROM THE STATION 
C                       DIRECTORY (K=1,NSTA)  (OUTPUT)
C           IFOUND(K) = USED TO KEEP TRACK OF THE GRIDPOINTS FOUND IN
C                       THE DIRECTORY (K=1,NSTA).  (INTERNAL) 
C                       0 = NOT YET FOUND.
C                       1 = FOUND.
C                       (INTERNAL)
C              NGP(J) = SIZE OF KGP GROUPS OF GRIDPOINTS (J=1,KGP), MAX
C                       OF ND1.  (OUTPUT)
C                 ND1 = SIZE OF ARRAYS CCALL( ), NAME( ),
C                       NELEV( ), IGLIST( ), STALAT( ), STALON( )
C                       IFOUND( ), AND NGP( ).  THIS IS THE MAXIMUM
C                       NUMBER OF GRIDPOINTS IN THE LIST TO BE RETURNED.
C                       (INPUT)
C                 KGP = THE NUMBER OF VALUES RETURNED IN NGP( ).
C                       (OUTPUT) 
C                NSTA = THE TOTAL NUMBER OF GRIDPOINTS RETURNED IN
C                       CCALL( ) AND OTHER OUTPUT ARRAYS.  (OUTPUT)
C                 ND5 = DIMENSION OF ALLOCATED ARRAYS.  THIS SHOULD 
C                       BE SUFFICIENT FOR THE DIRECTORY.  (INPUT)
C                 IER = STATUS RETURN.  (OUTPUT)
C                        0  = GOOD RETURN.
C                        20 = ERROR OR EOF READING KFILD(1) IN RDC.
C                             (ABORTS)
C                        21 = TOO MANY GRIDPOINTS FOR CCALL(ND1) IN RDC.
C                             (ABORTS)
C                        33 = ERROR ON UNIT KFILD(2) WHEN READING THE
C                             DIRECTORY.  (ABORTS)
C                        34 = TOO MANY GROUPS IN LIST (ABORTS).
C                        35 = ONE OR MORE STATIONS NOT FOUND IN THE
C                             DIRECTORY (NORMAL RETURN)
C                       190 = IDUP NOT EQ 2.  (ABORTS) 
C            CTEMP( ) = TEMPORARY ARRAY THAT MUST BE OF AT LEAST SIZE
C                       NT.  (CHARACTER*8)  (INTERNAL) 
C                  NT = NUMBER OF WORDS PER RECORD INDICATED IN FORMAT.
C                       SET BY PARAMETER, BECAUSE IS IS A DIMENSION.  
C                       (INTERNAL)
C              CCALLT = TO READ GRIDPOINT VALUES INTO FROM DIRECTORY.
C                       (CHARACTER*8) (INTERNAL)
C            NAMET(J) = TO READ NAME INTO FROM DIRECTORY (J=1,ND5).
C                       (CHARACTER*20)  (INTERNAL)
C           NELEVT(J) = TO READ ELEVATION INTO FROM DIRECTORY (J=1,ND5).
C                       (INTERNAL)
C           IWBANT(J) = TO READ WBAN NUMBER INTO FROM DIRECTORY 
C                       (J=1,ND5).  (INTERNAL)
C              SIGNLA = SIGN OF THE LATITUDE AS READ FROM THE DIRECTORY.
C                       WILL BE "N" FOR NORTH LATITUDE OR "S" FOR SOUTH
C                       LATITUDE.  WHEN "S", THE LATITUDE WILL BE STORED
C                       AS NEGATIVE.  (CHARACTER*1)  (INTERNAL)
C           XLATDD(J) = LATITUDE IN DEGREES (J=1,ND5).  (INTERNAL)
C              SIGNLO = SIGN OF THE LONGITUDE AS READ FROM THE
C                       DIRECTORY.  WILL BE "E" FOR EAST LONGITUDE OR
C                       "W" FOR WEST LONGITUDE.  WHEN "E", THE LONGITUDE
C                       IS ADJUSTED SO THAT ALL VALUES ARE WEST.
C                       (CHARACTER*1)  (INTERNAL)
C           XLONDD(J) = LONGITUDE IN DEGREES (J=1,ND5).  (INTERNAL)
C               NSTA1 = THE NUMBER OF GRIDPOINTS READ IN A GROUP,
C                       RETURNED FROM RDC.  (INTERNAL)
C              BLANK8 = 8 BLANKS.  (CHARACTER*8)  (INTERNAL)
C               BLANK = 20 BLANKS.  (CHARACTER*20)  (INTERNAL)
C               JREAD = COUNTS THE NUMBER OF DIRECTORY ENTRIES READ.
C                       (INTERNAL)
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES CALLED 
C            RDC. 
C
      PARAMETER (NT=7)
C
      CHARACTER*1 SIGNLA,SIGNLO
      CHARACTER*8 CCALL(ND1),CTEMP(NT),BLANK8,CCALLT
      CHARACTER*20 NAME(ND1),NAMET,BLANK
C
      DIMENSION NELEV(ND1),IWBAN(ND1),STALAT(ND1),STALON(ND1),
     1          ITIMEZ(ND1),IFOUND(ND1),NGP(ND1)
      DIMENSION IGLIST(ND1)
C        IGLIST( ) IS AN AUTOMATIC ARRAY.
      DIMENSION KFILD(2)
C
      ALLOCATABLE IGCALL(:),NAMET(:),NELEVT(:),IWBANT(:),
     1            XLATDD(:),XLONDD(:),ITIMEZT(:),IDUPKT(:)

      DATA BLANK8/' '/
      DATA BLANK/' '/
C
D     CALL TIMPR(KFILDO,KFILDO,'START RDSTGD        ')
C
      IER=0
      KGP=1
      NSTA=0
C
C        CHECK FOR VALUE OF IDUP; IT SHOULD BE 2)
C
      IF(IDUP.NE.2)THEN
         WRITE(KFILDO,102)IDUP
 102     FORMAT(/' ****ERROR IN RDSTGD.  IDUP =', I4,'; SHOULD BE 2.')
         IER=190
         GO TO 160
      ENDIF
C 
C
C        INITIALIZE ARRAYS.
C
      DO 103 K=1,ND1
      CCALL(K)=BLANK8
      IFOUND(K)=0
      NGP(K)=0
 103  CONTINUE
C
C        KFILD(1) CANNOT EQUAL KFILD(2).
C
      IF(KFILD(1).EQ.KFILD(2))THEN
         WRITE(KFILDO,104)KFILD(1)
 104     FORMAT(/,' ****KFILD(1) AND KFILD(2) ARE BOTH =',I3,
     1           '.  CHANGE ONE OR THE OTHER.')
      ENDIF
C
C        READ GRIDPOINT LIST FROM UNIT NUMBER KFILD(1).
C     
 105  CALL RDC(KFILDO,IP4,KFILD(1),CCALL(NSTA+1),ND1-NSTA,CTEMP,NT,
     1         '(7(A8,1X))',NSTA1,'99999999',IER)
C        NT = 7 WITH FMT = '(7(A8,1X))' MEANS THAT UP TO 7 VALUES WILL
C        BE READ PER RECORD.  FEWER CAN BE PRESENT.  IF THE LAST
C        VALUE IS NOT COMPLETE, IT WILL BE BLANK FILLED ON THE RIGHT.
C        IER FROM RDC WILL BE OVERWRITTEN IF THERE ARE DUPLICATE
C        GRIDPOINTS IN THE LIST, OR IF A GRIDPOINT CANNOT BE FOUND
C        IN THE DIRECTORY. WHEN IER NE 0, A DIAGNOSTIC WILL
C        HAVE BEEN WRITTEN BY RDC.
C
      IF(IER.NE.0.AND.NSTA1.NE.0)THEN
C
         IF(KGP.EQ.1)THEN
            WRITE(KFILDO,110)NSTA1,KGP,(CCALL(K),K=NSTA+1,NSTA+NSTA1)
 110        FORMAT(/,' ',I7,' GRIDPOINTS INPUT FOR GROUP NO.',I7/
     1            (8X,13(1X,A8)))
         ELSE
            WRITE(KFILDO,111)NSTA1,KGP,(CCALL(K),K=NSTA+1,NSTA+NSTA1)
 111        FORMAT(' ',I7,' GRIDPOINTS INPUT FOR GROUP NO.',I7/
     1            (8X,13(1X,A8)))
         ENDIF
C
      ENDIF
C
      IF(NSTA1.EQ.0)GO TO 120
C        AN EMPTY SET TERMINATES READING.
      IF(IP4.EQ.0)GO TO 115
      IF(IP4.EQ.KFILDO.AND.IER.NE.0.AND.NSTA1.NE.0)GO TO 115
C        GRIDPOINT LIST MAY BE WRITTEN TWICE WHEN THERE ARE ERRORS
C        DETECTED, ONCE TO THE DEFAULT OUTPUT FILE AND ONCE TO UNIT
C        IP4.
C
      IF(KGP.EQ.1)THEN
         WRITE(IP4,110)NSTA1,KGP,(CCALL(K),K=NSTA+1,NSTA+NSTA1)
      ELSE
         WRITE(IP4,111)NSTA1,KGP,(CCALL(K),K=NSTA+1,NSTA+NSTA1)
      ENDIF
C
 115  IF(KGP.LE.ND1)GO TO 117
      WRITE(KFILDO,116)ND1
 116  FORMAT(/,' ****TOO MANY GROUPS IN RDSTGD FOR DIMENSION ND1 =',I7)
      IER=34
      KGP=KGP-1
      GO TO 160
C
 117  NGP(KGP)=NSTA1
      NSTA=NSTA+NSTA1
      IF(IER.NE.0)GO TO 160
C        WHEN IER NE 0 FROM RDC, NO USE OF ENTERING RDC AGAIN.
      KGP=KGP+1
      GO TO 105
C
C        MUST DECREASE KGP, BECAUSE IT IS THE VALUE OF THE NEXT
C        ENTRY INTO NGP( ).
C
 120  KGP=KGP-1
C
D     CALL TIMPR(KFILDO,KFILDO,'AFTER READING LIST  ')
C
C        AT THIS POINT, CCALL( ) HAS BEEN FILLED.  NOW READ
C        DIRECTORY ENTRIES AND MATCH WITH LIST IN CCALL( ).
C
      REWIND(UNIT=KFILD(2))
C        IT WOULD BE UNUSUAL FOR THE DIRECTORY TO BE READ
C        MORE THAN ONCE.  IF RDSTGD WERE ENTERED MORE
C        THAN ONCE, THE DIRECTORY FILE SHOULD BE AT ITS
C        BEGINNING.  THE FILE IS NOT CLOSED AT THE END
C        OF RDSTGD TO ALLOW FOR THAT POSSIBILITY.
C
C        CONVERT THE LIST FROM CHARACTER TO INTEGER WITH AN 
C        INTERNAL READ.  USE ARRAY IGLIST( ).
C
      DO 1213 K=1,NSTA
      READ(CCALL(K),1212,END=1215,ERR=1217,IOSTAT=IOS)IGLIST(K)
 1212 FORMAT(I8)
 1213 CONTINUE
C
      GO TO 122
C
 1215 WRITE(KFILDO,1216)IOS
 1216 FORMAT(/,' ****ERROR ON INTERNAL READ IN RDSTGD.',
     1         '  IOSTAT =',I5,'.  STOP AT 1216')
      STOP 1216
C
 1217 WRITE(KFILDO,1218)IOS
 1218 FORMAT(/,' ****UNEXPECTED END OF FILE ON INTERNAL READ',
     1         ' IN RDSTGD.  IOSTAT =',I5,'.  STOP AT 1218')
      STOP 1218
C
 122  CONTINUE
C        ABOVE STATEMENT IN CASE /D BELOW IS IMPLEMENTED.
D1220 WRITE(KFILDO,1221)NSTA,(IGLIST(K),K=1,NSTA)
D1221 FORMAT(/' ',I7,' INTEGER GRIDPOINT VALUES'/(7X,10I10.8))
C
      ALLOCATE (IGCALL(ND5),NAMET(ND5),NELEVT(ND5),IWBANT(ND5),
     1          XLATDD(ND5),XLONDD(ND5),ITIMEZT(ND5),IDUPKT(ND5),
     2          STAT=IOS)
D     WRITE(KFILDO,1225)
D1225 FORMAT(/' ALLOCATING ARRAYS IN RDSTGD.')     
C
      IF(IOS.EQ.1)THEN
         WRITE(KFILDO,1226)
 1226    FORMAT(/' ****ALLOCATION OF ARRAYS FAILED IN RDSTGD',
     1           ' AT 1226.  ARRAYS ALREADY ALLOCATED.')
         STOP 126
C
      ELSEIF(IOS.EQ.2)THEN
         WRITE(KFILDO,1227)
 1227    FORMAT(/' ****ALLOCATION OF ARRAYS FAILED IN RDSTGD',
     1           ' AT 1227.  ARRAYS NOT ALLOCATED.')
         STOP 127
      ENDIF
C
C        INITIALIZE IDUPKT( ) TO ZERO.
C
      DO 1228 K=1,ND5
      IDUPKT(K)=0
 1228 CONTINUE
C
D     WRITE(KFILDO,128)
D128  FORMAT(/' READING DIRECTORY')
C
      JREAD=0
C
      DO 130 K=1,ND5
      CCALLT=BLANK8
      NAMET(1:20)=BLANK
      READ(KFILD(2),1229,IOSTAT=IOS,ERR=123,END=134)CCALLT,
     1     NAMET(K)(1:17),NAMET(K)(19:20),IWBANT(K),
     2     NELEVT(K),SIGNLA,XLATDD(K),SIGNLO,XLONDD(K),ITIMEZT(K)
 1229 FORMAT(A8,10X,A17,4X,A2,1X,I6,1X,I5,1X,A1,F7.4,1X,A1,
     1       F8.4,1X,I3)
      JREAD=JREAD+1
      IF(SIGNLA.EQ.'S')XLATDD(K)=-XLATDD(K)
C        ABOVE STATEMENT MAKES SOUTH LATITUDE NEGATIVE.
      IF(SIGNLO.EQ.'E')XLONDD(K)=360.-XLONDD(K)     
C        ABOVE STATEMENT MAKES ALL LONGITUDES WEST, RANGE 0-360.
      GO TO 125
C
C        ERROR READING DIRECTORY.
C
 123  WRITE(KFILDO,124)IOS
      IF(IP4.NE.0.AND.IP4.NE.KFILDO)WRITE(IP4,124)IOS
      IF(IP5.NE.0.AND.IP5.NE.KFILDO.AND.IP4.NE.IP5)WRITE(IP5,124)IOS
 124  FORMAT(/,' ****ERROR READING GRIDPOINT DIRECTORY IN RDSTGD.',
     1         '  IOSTAT =',I5)
      IER=33
      GO TO 160
C
C        A RECORD FROM THE DIRECTORY HAS BEEN READ.  CONVERT THE 
C        ASCII GRIDPOINT NUMBERS INTO INTEGER.
C
 125  READ(CCALLT,1251,END=1252,ERR=1254,IOSTAT=IOS)IGCALL(K)
 1251 FORMAT(I8)
C
      GO TO 130
C
 1252 WRITE(KFILDO,1253)IOS
 1253 FORMAT(/,' ****ERROR ON INTERNAL READ CCALLT TO IGCALL',
     1         ' IN RDSTGD.  IOSTAT =',I5,'.  STOP AT 1253')
      STOP 1253
C
 1254 WRITE(KFILDO,1255)IOS
 1255 FORMAT(/,' ****UNEXPECTED END OF FILE ON INTERNAL READ',
     1         ' CCALLT TO IGCALL IN RDSTGD.  IOSTAT =',I5,
     2         '.  STOP AT 1255')
      STOP 1255
C
 130  CONTINUE
C
 134  WRITE(KFILDO,135)JREAD
 135  FORMAT(/' ',I7,' RECORDS READ FROM THE GRIDPOINT DIRECTORY.')
C
C        THE DIRECTORY HAS BEEN READ AND THE INTEGER GRIDPOINT VALUES
C        RESIDE IN IGCALL( ).  NOW SEARCH THE DIRECTORY FOR EACH VALUE
C        OF THE GRIDPOINT LIST IN IGCALL( ).  IF THE VALUE CAN 
C        BE FOUND, VALUES FROM THE DIRECTORY ARE PLACED IN THE
C        APPROPRIATE ARRAYS.  IF AN VALUE CANNOT BE FOUND,
C        GRIDPOINTS WILL RETAIN THEIR PLACE IN THE LIST BUT WILL
C        HAVE NO AUXILIARY INFORMATION (E.G., LATITUDES AND LONGITUDES).
C        THIS PROCESS ALLOWS DUPLICATES IN THE LIST.
C
D     CALL TIMPR(KFILDO,KFILDO,'SEARCH STARTED      ')
C
      M=1
C        START THE SEARCH AT THE BEGINNING IN CASE THE FIRST VALUE 
C        IS THE FIRST ONE IN THE DIRECTORY.  THIS MAY HAPPEN OFTEN.
      KOUNTM=0
C        KOUNT COUNTS MISSING DIRECTORY ENTRIES.
      KOUNTD=0
C        KOUND COUNTS DUPLICATE STATIONS (GRIDPOINTS) IN LIST.
C
      DO 140 K=1,NSTA
      LASTGT=JREAD+1
C        LASTGT REPRESENTS ONE PAST THE POINT IN THE LIST WHERE
C        THE SEARCH CAN STOP WHEN THE ITEM IN LIST IS GT THE ITEM
C        IN THE DIRECTORY BEING TESTED.
      LASTLT=0
C        LASTLT REPRESENTS ONE PREVIOUS TO THE POINT IN THE LIST
C        WHERE THE SEARCH CAN START WHEN THE ITEM IN LIST IS LT THE
C        ITEM IN THE DIRECTORY BEING TESTED.
      IDIF=9999
C        INITIALIZE IDIF TO NON ZERO TO START EACH SEARCH.
 137  CONTINUE
D     WRITE(KFILDO,138)K,IDIF,M,LASTGT,LASTLT
D138  FORMAT(' AT 138 IN RDSTGD--K,IDIF,M,LASTGT,LASTLT',5I7)
C
      IF(IDIF.EQ.0)THEN
C           GRIDPOINT IN LIST NOT FOUND IN THE DIRECTORY.
         KOUNTM=KOUNTM+1
         NAME(K)=BLANK
         NELEV(K)=0
         STALAT(K)=0.
         STALON(K)=0.
C           OTHER READERS SET LATITUDES AND LONGITUDES FOR MISSING
C           STATIONS TO 0.  THAT IS DONE HERE TO BE CONSISTENT.
C           SEEMS 9999 MIGHT BE BETTER.
         IWBAN(K)=0
         ITIMEZ(K)=0
         GO TO 140
      ENDIF
C
C        WHEN THE ABOVE IS TRUE, M HAS NOT CHANGED FROM THE PREVIOUS
C        TEST.  THIS IS FAILURE MODE.
C
      IF(IGLIST(K).EQ.IGCALL(M))THEN
C
C           USE THE DIRECTORY VALUES.
C
         NAMET(M)(18:18)=' '
C           IT SEEMS THE ABOVE IS NECESSARY TO KEEP NULLS OUT OF 
C           PRINT!  THE NAME FIELDS ARE NORMALLY BLANK, BUT THIS
C           RESERVES THE POSSIBILITY OF PUTTING SOMETHING THERE.
         NAME(K)=NAMET(M)
         NELEV(K)=NELEVT(M)
         STALAT(K)=XLATDD(M)
         STALON(K)=XLONDD(M)
         IWBAN(K)=IWBANT(M)
         ITIMEZ(K)=ITIMEZT(M)
         IFOUND(K)=1
C
         IF(IDUPKT(M).EQ.0)THEN
            IDUPKT(M)=1
         ELSE
            IDUPKT(M)=IDUPKT(M)+1
            KOUNTD=KOUNTD+1
         ENDIF
C
         M=M+1
C           THIS STARTS THE SEARCH AT THE NEXT ENTRY IN THE DIRECTORY.
C           THIS HELPS WHEN THE LIST IN IGCALL)( ) HAS SOME NUMERICAL
C           ORDER TO IT AND MANY POINTS ARE CONSECUTIVE.
         LASTGT=JREAD+1
         LASTLT=1
         GO TO 140
C
      ELSEIF(IGLIST(K).GT.IGCALL(M))THEN
         MSAVE=M
         IDIF=(ABS(LASTGT-M)+1)/2
         M=M+IDIF
         LASTLT=MSAVE+1
C
      ELSE
         MSAVE=M
         IDIF=(ABS(LASTLT-M)+1)/2
         M=M-IDIF
         LASTGT=MSAVE-1
      ENDIF
      
      GO TO 137
C      
 140  CONTINUE             
C
D     WRITE(KFILDO,141)(IFOUND(K),IGLIST(K),NELEV(K),
D    1                  STALAT(K),STALON(K),ITIMEZ(K),K=1,NSTA)
D141  FORMAT(/' IN RDSTGD AT 141--IFOUND,IGLIST,NELEV,',
D    1        'STALAT,STALON,ITIMEZ'/(3I7,2F10.4,I4))
C
      DEALLOCATE(IGCALL,NAMET,NELEVT,
     1           IWBANT,XLATDD,XLONDD,ITIMEZT,IDUPKT,STAT=IOS)
      IF(IOS.NE.0)THEN
         WRITE(KFILDO,142)
 142     FORMAT(/' ****DEALLOCATION FAILED IN RDSTGD,',
     1           ' REASON UNKNOWN.  STOP AT 142.')
         STOP 142
      ENDIF     
C
D     CALL TIMPR(KFILDO,KFILDO,'SEARCH COMPLETED    ')
C
C        NOTIFY USER OF MISSING DIRECTORY ENTRIES OR DUPLICATES.
C
      IF(KOUNTM.EQ.0)THEN
         WRITE(KFILDO,145)
 145     FORMAT('     THERE ARE NO GRIDPOINTS IN THE LIST THAT ARE',
     1          ' NOT IN THE DIRECTORY.')
      ELSE
         WRITE(KFILDO,146)KOUNTM
 146     FORMAT(' ****THERE ARE',I7,' GRIDPOINTS',
     1          ' NOT IN THE DIRECTORY.')
         IER=35
      ENDIF
C
      IF(KOUNTD.EQ.0)THEN
         WRITE(KFILDO,147)
 147     FORMAT('     THERE ARE NO DUPLICATE GRIDPOINTS',
     1          ' IN THE STATION LIST.')
      ELSE
         WRITE(KFILDO,148)KOUNTD
 148     FORMAT('     THERE ARE',I7,' DUPLICATE GRIDPOINTS',
     1          ' IN THE LIST.  NOT COUNTED AS AN ERROR.')
      ENDIF
C
C        WRITE GRIDPOINT LISTS TO KFILDO WHEN THERE HAS BEEN AN 
C        ERROR AND TO IP5 AS DESIRED.  WRITING IS BY GROUP UNLESS
C        SINGLE GRIDPOINTS ARE BEING DEALT WITH, IN
C        WHICH CASE KGP = NSTA.  NOTE THAT ONLY ONE GROUP
C        OF TWO GRIDPOINTS WILL CAUSE LISTING BY GROUP.
C
      ISTART=0
C
      DO 158 M=1,KGP
C
      DO 157 J=ISTART+1,ISTART+NGP(M)
C
      IF(IFOUND(J).EQ.0)THEN
         WRITE(KFILDO,150)CCALL(J)
 150     FORMAT(' ',4X,A8,' NOT FOUND IN DIRECTORY.')
      ENDIF
C
      IF(IP5.NE.0)THEN
C
C           WRITE SINGLE HEADER FOR SINGLE GRIDPOINT LIST.
C
         IF(KGP.EQ.NSTA.AND.M.EQ.1.AND.J.EQ.1)THEN
            WRITE(IP5,152)NSTA
 152        FORMAT(/,' ',I7,
     1        ' GRIDPOINTS AND DIRECTORY INFORMATION (IF NOT',
     2        ' LISTED BY GROUP, IMPLIES ONE GRIDPOINT PER GROUP)'/
     3        '               GRIDPOINT     NAME           ',
     4        '     LAT     LON   ELEV')
C
C           WRITE HEADER FOR EACH GROUP OF GRIDPOINTS.
C
         ELSEIF(KGP.NE.NSTA.AND.J.EQ.ISTART+1)THEN
            WRITE(IP5,153)NGP(M)
 153        FORMAT(/,' ',I7,
     1        ' GRIDPOINTS AND DIRECTORY INFORMATION'/
     2        '               GRIDPOINT     NAME           ',
     3        '     LAT     LON   ELEV')
C
         ENDIF
C
         IF(J.EQ.ISTART+1.AND.KGP.NE.NSTA)THEN
            WRITE(IP5,154)M,CCALL(J),NAME(J),
     1        STALAT(J),STALON(J),NELEV(J)
 154        FORMAT(' GROUP',I7,3X,A8,1X,A20,2F8.2,I6)
         ELSE
            WRITE(IP5,155)CCALL(J),NAME(J),
     1           STALAT(J),STALON(J),NELEV(J)
 155        FORMAT(' ',15X,A8,1X,A20,2F8.2,I6)
         ENDIF
C
      ENDIF
C
 157  CONTINUE
C
      ISTART=ISTART+NGP(M)
 158  CONTINUE
C
D     CALL TIMPR(KFILDO,KFILDO,'END RDSTGD          ')
C
 160  RETURN
      END
