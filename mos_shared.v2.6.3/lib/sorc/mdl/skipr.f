      SUBROUTINE SKIPR(KFILDO,KFILIO,KSKIP,NTOTBY,NTOTRC,L3264B,IER)
C
C        MARCH   1995   GLAHN   TDL   MOS-2000
C        OCTOBER 1996   GLAHN   ADDED IER = 143, ELIMINATED STOPS
C        APRIL   2000   DALLAVALLE   MODIFIED FORMAT STATEMENTS TO
C                                    CONFORM TO FORTRAN 90 
C                                    STANDARDS ON THE IBM SP
C
C        PURPOSE
C           TO SKIP RECORDS ON A TDLPACK FILE UNTIL A PARTICULAR
C           DATE/TIME HAS BEEN PASSED.  SKIPR APPLIES TO GRIDPOINT
C           DATA; SKIPWR APPLIES TO VECTOR DATA WITH A DIRECTORY.
C   
C        DATA SET USE
C            KFILDO    - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFILIO    - UNIT NUMBER OF FILE FOR SKIPPING.  (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFILIO = UNIT NUMBER OF FILE FOR SKIPPING.  (INPUT)
C               KSKIP = WHEN NONZERO, INDICATES THAT THE OUTPUT FILE
C                       IS TO BE MOVED FORWARD UNTIL ALL DATA FOR
C                       DATE KSKIP HAVE BEEN SKIPPED.  KSKIP IS INPUT
C                       AS YYYYMMDDHH.  (INPUT)
C              NTOTBY = THE TOTAL NUMBER OF BYTES SKIPPED ON THE FILE.
C                       IT IS INITIALIZED, AND THE BYTES ARE COUNTED
C                       WHEN SKIPPING RECORDS.  (OUTPUT)
C              NTOTRC = THE TOTAL NUMBER OF RECORDS SKIPPED ON THE FILE.
C                       IT IS INITIALIZED, AND THE RECORDS ARE COUNTED 
C                       WHEN SKIPPING RECORDS.  (OUTPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING USED.
C                       (INPUT)
C                 IER = STATUS RETURN.
C                       0 = GOOD RETURN.
C                       143 = ERROR WHEN SKIPPING RECORDS.
C                       OTHER RETURNS FROM UNPKBG.
C                       (OUTPUT)
C              NBYTES = NUMBER OF BYTES IN PACKED PORTION OF RECORD.
C                       (INTERNAL)
C               IDATE = DATE/TIME OF RECORD READ.  (INTERNAL)
C            IPACK(J) = WORK ARRAY (J=1,5).  (INTERNAL)
C
C        NONSYSTEM SUBROUINES USED 
C            UNPKBG
C
      DIMENSION IPACK(5)
C
D     WRITE(KFILDO,100)L3264B
D100  FORMAT(/' **** ENTERING SKIPR, L3264B ='I12)
      IER=0
      NTOTBY=0
C        NTOTBY IS THE TOTAL NUMBER OF BYTES ON THIS FILE.
      NTOTRC=0
C        NTOTRC IS THE TOTAL NUMBER OF RECORDS ON THIS FILE.
      NTRASH=0
      IF(KSKIP.EQ.0)GO TO 300
C
C     SKIPPING INDICATED.  FILE HAS ALREADY BEEN OPENED.  
C
 110  IF(L3264B.EQ.32)THEN
         READ(KFILIO,IOSTAT=IOS,ERR=130,END=140)NTRASH,NBYTES,
     1               (IPACK(J),J=1,5)
D        WRITE(KFILDO,111)NBYTES
D111     FORMAT(/' **** READING ON 32-BIT MACHINE, NBYTES ='I10)
         IDATE=IPACK(5)
C        IPACK(5) HOLDS THE DATE/TIME OF THE RECORD FOR A 32-BIT MACHINE.
      ELSE
         READ(KFILIO,IOSTAT=IOS,ERR=130,END=140)NBYTES,
     1               (IPACK(J),J=1,3)
         LOC=3
         IPOS=1
         CALL UNPKBG(KFILDO,IPACK,5,LOC,IPOS,IDATE,32,IER,*112)
C        THE LEFT HALF OF IPACK(3) HOLDS THE DATE/TIME OF THE RECORD
C        FOR A 64-BIT MACHINE.
      ENDIF
C
      GO TO 120
C 
 112  WRITE(KFILDO,113)
 113  FORMAT(/' ****ERROR IN UNPKBG IN SKIPR AT 112.')
      GO TO 300
C
 120  CONTINUE
D     WRITE(KFILDO,115)L3264B,IDATE,KSKIP
D115  FORMAT(/' L3264B, IDATE, KSKIP ='3I12)     
      IF(IDATE.GT.KSKIP)THEN
         BACKSPACE KFILIO
         GO TO 150
      ELSE
         NTOTBY=NTOTBY+NBYTES+8
C           NTOTBY IS THE TOTAL NUMBER OF BYTES ON THIS FILE.
C           NBYTES IS THE PACKED PART OF THE MESSAGE ONLY.
         NTOTRC=NTOTRC+1
         GO TO 110
      ENDIF  
C
C        ERROR READING FILE WHEN SKIPPING RECORDS.
C
 130  WRITE(KFILDO,131)KSKIP,IOS
 131  FORMAT(/,' ****ERROR IN SKIPR AT 130 WHEN SKIPPING RECORDS',
     1         ' ON FILE WHILE LOOKING FOR DATE KSKIP =',I12,'.',/,
     2         '     IOSTAT =',I5,'.')
      IER=143
      GO TO 300
C
C        END OF FILE ENCOUNTERED WHEN SKIPPING RECORDS.  THIS MAY BE OK.
C        THAT IS, THE DATE TO BE SKIPPED MAY BE THE LAST ONE ON THE FILE.
C
 140  IF(NTOTRC.NE.0)WRITE(KFILDO,141)KSKIP,IOS,NTOTRC,NTOTBY
 141  FORMAT(/,' ****END OF FILE FOUND IN SKIPR WHEN SKIPPING',
     1         ' RECORDS ON OUTPUT FILE WHILE',
     2         ' SEARCHING FOR DATE KSKIP =',I12,',',/,
     3         '     IOSTAT =',I5,'.  PROCEEDING.',/,
     4         '     NUMBER OF RECORDS SKIPPED =  ',I15,/,
     5         '     NUMBER OF BYTES IN RECORDS = ',I15)
      BACKSPACE KFILIO
C        IN ORDER TO WRITE, MUST BACKSPACE OVER THE EOF.
C        NORMALLY, SKIPR WOULD BE USED BEFORE WRITING TO A FILE.
C        IF IT WERE TO BE USED BEFORE READING A FILE, THE POINTER
C        ON RETURN SHOULD ALSO BE BEFORE THE EOF SO THAT IF A READ
C        WERE ATTEMPTED, THE EOF WOULD BE FOUND.
      GO TO 300
C
C        SKIPPING DONE.
C
 150  WRITE(KFILDO,151)KSKIP,NTOTRC,NTOTBY
 151  FORMAT(/,' RECORDS PREVIOUS TO DATE',I12,
     1         ' SKIPPED ON OUTPUT FILE.',/,
     2         '     NUMBER OF RECORDS SKIPPED =  ',I15,/,
     3         '     NUMBER OF BYTES IN RECORDS = ',I15)
C        NOTE THAT CONTROL DOES NOT COME TO 150 WHEN KSKIP = 0.
 300  RETURN
      END
