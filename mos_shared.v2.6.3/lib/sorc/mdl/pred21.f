      SUBROUTINE PRED21(KFILDO,KFIL10,KFILIO,NFIRST,
     1                  ID,IDPARS,THRESH,JD,JP,IFIND,ISTAV,ITIME,ISCALD,
     2                  SMULT,SADD,ORIGIN,CINT,IPLAIN,PLAIN,UNITS,NPRED,
     3                  NDATE,KFILRA,RACESS,NUMRA,
     4                  ICALL,CCALL,ICALLD,CCALLD,NAME,NSTA,NGRID,DIR,
     5                  NGRIDC,ISDATA,SDATA,SDATA1,L1DATA,
     6                  NELEV,STALAT,STALON,ITIMEZ,ND1,ND11,
     7                  IPACK,IWORK,DATA,ND5,MINPK,
     8                  LSTORE,MSTORE,ND9,LITEMS,MITEMS,CORE,ND10,LASTL,
     9                  NBLOCK,LASTD,NSTORE,NFETCH,
     A                  IS0,IS1,IS2,IS4,ND7,
     B                  FD1,FD2,FD3,FD4,FD5,FD6,FD7,
     C                  FDA,FDVERT,FDTIME,FDSINS,FDMS,ND2X3,
     D                  IP12,IP13,IP14,IP15,IP16,
     E                  NTOTBY,NTOTRC,
     F                  L3264B,L3264W,MISTOT,ISTOP,IER)
C
C        FEBRUARY  1995   GLAHN   TDL   MOS-2000
C        AUGUST    1996   GLAHN   ADDED MISSS AND MISTOT
C        NOVEMBER  1996   GLAHN   ADDED KFILRA, RACESS, NUMRA
C        JANUARY   1997   GLAHN   ADDED DEFINITION OF UNDEFINED NSIZE
C        JANUARY   1997   GLAHN   REMOVED REFERENCE TO TAPE LENGTH, ETC.
C        JUNE      1997   GLAHN   ADDED VECTOR DATA INPUT CAPABILITY
C        SEPTEMBER 1997   GLAHN   SET IFIND(N) = 1 WHEN VARIABLE REUSED
C        NOVEMBER  1997   GLAHN   NAME OF PREDX2 CHANGED TO PACKV 
C                                 AND XMISSP, XMISSS ADDED TO CALL 
C        DECEMBER  1997   GLAHN   PLAIN ADDED TO CALL TO PACKV
C        JANUARY   1998   GLAHN   ADDED SUBSTITUTE STATIONS IN CCALL( , )
C        JANUARY   1998   GLAHN   REMOVED MISALL--TOO DANGEROUS;
C                                 TEST FOR IER AFTER GRIDB ADDED
C        MAY       1998   GLAHN   ADDED ITIMEZ( );
C                                 USE OF IER = -1 FROM OPTION
C        NOVEMBER  1998   GLAHN   CHANGED DIMENSIONS OF CCALLD( )
C                                 AND ICALLD( , ) FROM ND1 TO ND5
C        NOVEMBER  1998   GLAHN   ADDED MSTORE, MITEMS TO CALL,
C                                 VARIABLES ADDED TO MSTORE WHEN
C                                 NOT FOUND IN OPTION; WRITES
C                                 DATA WHEN IDPARS(1,N) NE 999
C        DECEMBER  1998   GLAHN   ADDED ISTOP(2); INSERTED MAXRR
C        DECEMBER  1998   GLAHN   IER = 120 AND = -2 FROM OPTION TREATED
C        DECEMBER  1998   GLAHN   IFIND( ) SET = 0 INITIALLY AT DO 400
C        DECEMBER  1998   GLAHN   STATEMENT 1344 CHANGED TO 1374;
C                                 MINOR CHANGE BELOW 1351; ISTAV( )
C                                 SET = 0 WHEN IER = -2 FROM OPTION
C                                 CHECK ON IDPARS(3,N-1) ADDED 
C                                 ABOVE GO TO 220; ADDED NGOMIS;
C                                 MSTORE(7, ) = MAXRR
C        JANUARY   1999   GLAHN   CHANGES TO ACCOMMODATE MISSING DATA
C                                 AT START OF RUN; ELIMINATED MAXRR
C        APRIL     1999   GLAHN   PRINTING OF GRIDPOINT VALUES MODIFIED
C        APRIL     1999   GLAHN   ADDED SMTH2X AND SMTH3X
C        JULY      1999   GLAHN   ADDED NWORDS TO CALL TO PACKV
C        AUGUST    1999   GLAHN   ADDED IP12 TO CALL AND CALL TO OPTION
C        SEPTEMBER 1999   GLAHN   ADDED +7777 TO  MSTORE(5, ) AFTER 1345
C        SEPTEMBER 2000   GLAHN   CORRECTED SPELLING
C        DECEMBER  2000   GLAHN   MODIFIED DIAGNOSTIC AT 119 AND 139
C        FEBRUARY  2002   GLAHN   CHANGED ND12 TO NUMRA IN ONE COMMENT
C        MAY       2002   GLAHN   ADDED NGRID AND NAME( ) TO CALL TO
C                                 OPTION; MODIFIED TO DEAL WITH LARGE
C                                 CONSTANT FILES
C        JUNE      2002   GLAHN   ADDED IDPARS(13) = 4 CAPABILITY
C        JULY      2002   GLAHN   ADDED STORING OF TERRAIN CONSTANT
C                                 CCC=409 IN INTERNAL STORAGE
C        JUNE      2003   GLAHN   CHANGED DIMENSION OF UNITS( ) FROM
C                                 ND1 TO NPRED AND COMMENTS TO AGREE
C        JUNE      2003   GLAHN   MODIFIED COMMENTS TO REFLECT IFIND 
C                                 CAN = 2; ADDED CHECK FOR INTERPOLATION
C                                 VALUE FOR CONSTANTS AT FORMAT 228;
C                                 ADDED LFIND
C        JULY      2003   GLAHN   ADDED INTRPD; GO TO 360 CHANGED TO
C                                 GO TO 390 BELOW 312
C        AUGUST    2003   GLAHN   CHANGED 360 TO 380 BELOW 312 (WAS 360)
C        SEPTEMBER 2003   GLAHN   EXEMPTED 2XX, 5XX, AND 6XX IN 
C                                 ADDITION TO THE PREVIOUS 3XX FROM
C                                 BINARY PROCESSING AT 230; CHANGED
C                                 ND5 TO ND2X3 IN CALLS TO GFETCH
C        SEPTEMBER 2003   GLAHN   CORRECTED ND3X3 IN CALL TO GFETCH
C        OCTOBER   2003   GLAHN   CODE MODS IN 3 PLACES TO CHECK FOR
C                                 DD = 0 IN ADDITION TO CCC = 409
C        APRIL     2003   GLAHN   INSERTED CHANGE BELOW 230 TO NOT 
C                                 FURTHER PROCESS VECTOR DATA WHEN
C                                 IDPARS(10, ) = 9
C
C        PURPOSE
C           TO OBTAIN FOR U201 ALL VARIABLES IDENTIFIED IN ID( , ),
C           IDPARS( , ), AND THRESH( ) FOR "DAY 1".  "BASIC" 
C           VARIABLES (THE VARIABLES SANS "PROCESSING" INFORMATION)
C           ARE IN JD( , ), RESPECTIVELY.  AVAILABLE VARIABLES ARE
C           INDICATED IN LSTORE( , ).  VARIABLES MAY BE OBTAINED 
C           FROM CORE( ) OR FROM DISK AS INDICATED IN LSTORE( , ),
C           OR THEY CAN BE COMPUTED THROUGH CALLING THE SUBROUTINE
C           OPTION.  THE VARIABLES ARE COMPUTED AND WRITTEN TO THE
C           OUTPUT FILE.  PRED21 IS ENTERED (ONLY) FOR THE FIRST
C           DATE/TIME.  CUMULATIVE FROM BELOW OR DISCRETE
C           BINARIES ARE NOT SUPPORTED.  GRIDPOINT AND VECTOR DATA
C           MUST BE HANDLED SOMEWHAT DIFFERENTLY.  FOR GRIDPOINT
C           DATA, THE BASIC ID IN JD( ) IS USED AND ALL PROCESSING
C           OPERATORS (B, T, I, S) APPLY.  FOR VECTOR DATA, IT IS
C           EXPECTED THAT THE PROCESSING WILL BE DONE IN OPTION,
C           EXCEPT THAT VECTOR DATA OUT OF OPTION CAN HAVE THE
C           TRANSFORMATION AND BINARY OPERATORS (T, B) APPLY.
C           SINCE IT IS NOT KNOWN UPON ENTRY WHETHER THE ID( )
C           APPLIES TO VECTOR OR GRIDPOINT DATA, GFETCH IS 
C           ENTERED FIRST WITH JD( ), THEN IF THE DATA ARE NOT
C           FOUND, GFETCH IS ENTERED AGAIN WITH ID( ).  IT THE
C           DATA ARE FOUND WITH JD( ), PROCESSING OCCURS;
C           OTHERWISE, IT DOES NOT.
C
C           IT IS A DIFFICULT CIRCUMSTANCE WHEN ALL DATA FOR 
C           DAY 1 ARE NOT AVAILABLE.  IN THAT CASE, WHEN OPTION
C           CANNOT IDENTIFY THE VARIABLE, IT IS ASSUMED THAT
C           IT IS NOT A COMPUTED VARIABLE BUT ONE THAT SHOULD
C           BE AVAILABLE FROM INPUT, BUT NOT FOR DAY 1.  SO,
C           ENTRIES ARE MADE DIRECTLY IN MSTORE( , ), WHICH
C           IS NORMALLY FILLED IN LMSTR2.  THE MAXIMUM RR
C           IN IDPARS(9, ) HAS TO BE APPLIED. 
C   
C        DATA SET USE
C            KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10 - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                     (INPUT-OUTPUT) 
C            KFILIO - UNIT NUMBER OF INTERPOLATED OUTPUT FILE.  (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              KFILIO = UNIT NUMBER OF INTERPOLATED OUTPUT FILE.  (INPUT)
C              NFIRST = 1 FOR FIRST DAY, 2 FOR SECOND, 3 OTHERWISE.  
C                       FOR PRED21, NFIRST WILL ALWAYS BE 1.  (INPUT)  
C             ID(J,N) = THE INTEGER VARIABLE ID'S (J=1,4) (N=1,NPRED).
C                       (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE VARIABLE
C                       ID CORRESPONDING TO ID( ) (J=1,15) (N=1,NPRED).
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C           THRESH(N) = THE BINARY THRESHOLD ASSOCIATED WITH IDPARS( ,N)
C                       (N=1,NPRED).  (INPUT)
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID (J=1,4) (N=1,NPRED).
C                       THIS IS THE SAME AS ID(J,N), EXCEPT THAT THE PORTIONS
C                       PERTAINING TO PROCESSING ARE OMITTED:
C                       B = IDPARS(3, ),
C                       T = IDPARS(8, ),
C                       I = IDPARS(13, ),
C                       S = IDPARS(14, ),
C                       G = IDPARS(15, ), AND
C                       THRESH( ).
C                       JD( , ) IS USED TO IDENTIFY THE BASIC MODEL FIELDS
C                       AS READ FROM THE ARCHIVE.  (INPUT)
C             JP(J,N) = JP( ,N) INDICATES WHETHER (>0) OR NOT (=0) VARIABLE N
C                       WILL BE OUTPUT FOR VIEWING (N=1,NPRED).
C                       J=1--GRIDPOINT VALUES,
C                       J=2--GRIDPRINT WITH CONTOURS, AND
C                       J=3--INTERPOLATED VALUES.
C                       THIS ALLOWS INDIVIDUAL VARIABLE CONTROL ON THE PRINT
C                       PARAMETERS IP12, IP13, AND IP14.  (INPUT)
C            IFIND(N) = 1 = WHEN THE VARIABLE CAN BE FOUND DIRECTLY
C                           FROM GFETCH (DOESN'T HAVE TO GO THRU OPTION).
C                       2 = WHEN ID( , ) HAS BEEN FOUND IN OPTION, BUT
C                           GOOD DATA WERE NOT RETURNED.  THEREFORE, IT 
C                           IS UNKNOWN WHERE THE DATA ARE TO COME FROM.
C                       0 = WHEN ID( , ) HAS BEEN FOUND IN OPTION AND
C                           THE DATA WILL BE COMPUTED THERE.
C                       (OUTPUT)
C            ISTAV(N) = INDICATES FOR EACH VARIABLE (N=1,NPRED) WHETHER 
C                       DATA ARE CURRENTLY VECTOR (=1) OR GRIDPOINT (=0).
C                       WHEN STILL UNDETERMINED, SET = 2.
C                       (INTERNAL/OUTPUT)
C            ITIME(N) = FOR EACH VARIABLE (N=1,NPRED) INDICATES
C                       WHETHER (=1) OR NOT (=0) THE RR IS TO BE USED 
C                       BY GFETCH WHEN FETCHING DATA.  (OUTPUT)
C           ISCALD(N) = THE DECIMAL SCALING CONSTANT TO USE WHEN PACKING THE 
C                       INTERPOLATED DATA (N=1,ND4).  THE BINARY SCALING
C                       CONSTANT IS USED AS ZERO.  (INPUT)
C            SMULT(N) = THE MULTIPLICATIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C             SADD(N) = THE ADDITIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C           ORIGIN(N) = THE CONTOUR ORIGIN, APPLIES TO THE UNITS IN UNITS(N)
C                       (N=1,ND4).  (INPUT)
C             CINT(N) = THE CONTOUR INTERVAL, APPLIES TO THE UNITS IN
C                       UNITS(N) (N=1,ND4).  (INPUT)
C       IPLAIN(L,J,N) = 32 CHARACTERS (L=1,L3264W) (J=1,4) OF PLAIN LANGUAGE
C                       DESCRIPTION OF VARIABLES (N=1,ND4).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       EQUIVALENCED TO PLAIN( ).  (INPUT)
C            PLAIN(N) = THE PLAIN LANGUAGE DESCRIPTION OF THE VARIABLES
C                       (N=1,ND4).  EQUIVALENCED TO IPLAIN( , ).
C                       (CHARACTER*32)  (INPUT)
C            UNITS(N) = THE UNITS OF THE DATA THAT APPLY AFTER MULTIPLYING
C                       BY SMULT(N) AND ADDING SADD(N) (N=1,NPRED).
C                       (CHARACTER*12)
C               NPRED = THE NUMBER OF VARIABLES NEEDED AND IDENTIFIED IN 
C                       ID( , ), ETC.  ALSO TREATED AS THE DIMENSION OF THE
C                       VARIABLES ID( , ), ETC.  THIS NAME IS A HOLDOVER,
C                       AS IS THE NAME OF THE ROUTINE ITSELF, TO WHEN 
C                       U201 WAS WRITTEN ONLY FOR PREDICTORS.  (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH VARIABLES ARE TO BE
C                       FURNISHED ON THIS CALL TO PRED21.  (INPUT)
C           KFILRA(J) = HOLDS THE UNIT NUMBERS FOR ACCESSING THE MOS-2000
C                       EXTERNAL RANDOM ACCESS FILES (J=1,NUMRA).  (INPUT)
C           RACESS(J) = THE FILE NAMES CORRESPONDING TO KFILRA(J) (J=1,NUMRA).
C                       (CHARACTER*60)  (INPUT)
C               NUMRA = THE NUMBER OF UNIT NUMBERS AND NAMES IN KFILRA( )
C                       AND RACESS( ).  (INPUT)
C        ICALL(L,K,J) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,NSTA) (J=1,6).
C                       EQUIVALENCED TO CCALL( , )  (INPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST, EXCEPT POSSIBLY 
C                       CCALLD( ).  EQUIVALENCED TO ICALL( , , ).
C                       (CHARACTER*8)  (INPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,ND5).
C                       EQUIVALENCED TO CCALLD( ).  (INPUT)
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5).  EQUIVALENCED 
C                       TO ICALLD( , ).  (CHARACTER*8)  (INTERNAL)
C             NAME(K) = NAMES OF STATIONS (K=1,NSTA).  USED FOR PRINTOUT
C                       ONLY.  (CHARACTER*20)  (INPUT)
C                NSTA = THE NUMBER OF STATIONS IN ICALL( , , ) AND CCALL( , ).
C                       (INPUT)
C               NGRID = THE NUMBER OF GRID COMBINATIONS IN DIR( , , ),
C                       MAXIMUM OF ND11.  (NOT ACTUALLY USED.)  (INPUT)
C          DIR(K,J,M) = THE IX (J=1) AND JY (J=2) POSITIONS ON THE GRID
C                       FOR THE COMBINATION OF GRID CHARACTERISTICS M
C                       (M=1,NGRID) AND STATION K (K=1,NSTA) IN NGRIDC( ,M).
C                       (INPUT)
C         NGRIDC(L,M) = HOLDS THE GRID CHARACTERISTICS (L=1,6) FOR EACH GRID
C                       COMBINATION (M=1,NGRID).
C                       L=1--MAP PROJECTION NUMBER (3=LAMBERT, 5=POLAR
C                            STEREOGRAPHIC). 
C                       L=2--GRID LENGTH IN MILLIMETERS,
C                       L=3--LATITUDE AT WHICH GRID LENGTH IS CORRECT *10000,
C                       L=4--GRID ORIENTATION IN DEGREES *10000,
C                       L=5--LATITUDE OF LL CORNER IN DEGREES *10000,
C                       L=6--LONGITUDE OF LL CORNER IN DEGREES *10000.
C           ISDATA(K) = USED IN PACK1D (K=1,NSTA).  (INTERNAL)
C            SDATA(K) = INTERPOLATED DATA FOR WRITING (K=1,NSTA).
C                       (INTERNAL)
C           SDATA1(K) = WORK ARRAY RESERVED FOR USE IN L2D2 (K=1,NSTA).
C                       (INTERNAL)
C           L1DATA(K) = THE ARRAY RESERVED FOR USE BY LINEARIZATION
C                       ROUTINES (K=1,NSTA).  (INTERNAL)  
C            NELEV(K) = ELEVATION OF STATIONS (K=1,NSTA).  (INPUT)
C           STALAT(K) = LATITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           STALON(K) = LONGITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           ITIMEZ(K) = TIME ZONE INDICATOR.  THE NUMBER OF HOURS
C                       THE STATION IS DIFFERENT FROM UTC (K=1,NSTA).
C                       (INPUT)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT WITH.
C                       (INPUT)
C                ND11 = MAXIMUM NUMBER OF GRID COMBINATIONS THAT CAN BE
C                       DEALT WITH ON THIS RUN.  LAST DIMENSION OF
C                       NGRIDC( , ) AND DIR( , , ).  (INPUT)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = ARRAY TO FURNISH TO SUBROUTINE GFETCH AND OPTION
C                       TO HOLD RETURNED DATA (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).
C                       MUST BE GE GRID SIZE, MAX IN RUN OF ND2X3.
C                       (INPUT)
C               MINPK = MINIMUM GROUP SIZE WHEN PACKING THE INTERPOLATED
C                       VALUES.  (INPUT)
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR( , ,L) AND
C                              IN NGRIDC( ,L) DEFINING THE CHARACTERISTICS
C                              OF THIS GRID.
C                       L=11 --THE NUMBER OF THE FIRST VARIABLE IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NPRED) FOR WHICH THIS
C                              VARIABLE IS NEEDED, WHEN IT DOES NOT NEED
C                              TO BE STORED AFTER DAY 1.  WHEN THE VARIABLE
C                              MUST BE STORED (TO BE ACCESSED THROUGH OPTION)
C                              FOR ALL DAYS, ID(11,N) IS 7777 + THE NUMBER
C                              OF THE FIRST VARIABLE IN THE SORTED LIST
C                              FOR WHICH THIS VARIABLE IS NEEDED.
C                       L=12 --USED INITIALLY IN ESTABLISHING MSTORE( , ).
C                              LATER USED AS A WAY OF DETERMINING WHETHER
C                              TO KEEP THIS VARIABLE.
C         MSTORE(L,J) = THE ARRAY HOLDING THE VARIABLES NEEDED AS INPUT, AFTER
C                       DAY 1, AND ASSOCIATED INFORMATION (L=1,7) (J=1,MITEMS).
C                       J=1,4 --THE 4 ID'S OF THE DATA.
C                       J=5   --THE VALUE TAKEN FROM LSTORE(11, ) WHICH
C                               INDICATES WHETHER OR NOT TO STORE THE
C                               VARIABLE AND THE FIRST PREDICTOR TO USE IT FOR.
C                       J=6   --THE CYCLE TIME FOR WHICH THIS VARIABLE
C                               IS NEEDED FOR THE DATE BEING PROCESSED.  A
C                               VARIABLE NEEDED FOR MORE THAN ONE CYCLE TIME
C                               WILL HAVE ONE (AND ONLY ONE) ENTRY FOR EACH
C                               CYCLE.
C                       J=7   --THE MAXIMUM TIME OFFSET RR (SEE IDPARS(9, )
C                               CORRESPONDING TO MSTORE(6, )
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , ) THAT 
C                       HAVE BEEN USED IN THIS RUN.
C              MITEMS = THE NUMBER OF ITEMS IN MSTORE( , ).
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA IDENTIFIED IN
C                       LSTORE( , ) (J=1,ND10).  WHEN CORE( ) IS FULL
C                       DATA ARE STORED ON DISK.  (OUTPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C               LASTL = THE LAST LOCATION IN CORE( ) USED FOR MOS-2000 INTERNAL
C                       STORAGE.  INITIALIZED TO 0 ON FIRST ENTRY TO GSTORE.
C                       ALSO INITIALIZED IN U201 IN CASE GSTORE IS NOT ENTERED.
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK FOR MOS-2000
C                       INTERNAL STORAGE.
C              NSTORE = THE NUMBER OF TIMES GSTORE HAS BEEN ENTERED.  GSTORE
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  THE USER 
C                       NEED NOT WORRY ABOUT THIS.   (OUTPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.  GFETCH
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).  (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).  (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C  FD1(J),FD2(J), ETC = WORK ARRAYS (J=1,ND2X3).  THESE MAY BE USED IN
C                       ROUTINES AS 2-DIMENSIONAL ARRAYS, WHERE THE
C                       TOTAL ARRAY SIZE IS ND2*ND3=ND2X3 AS DECLARED IN
C                       THE CALLING PROGRAM.  (INTERNAL)
C              FDA(J) = USED TO RETAIN A GRID WITHIN PRED21 TO ELIMINATE
C                       MULTIPLE SEARCHS BY GFETCH AND UNPACKING OF
C                       THE DATA.  (INTERNAL)
C           FDVERT(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE VERTP
C                       (J=1,ND2X3).
C           FDTIME(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE TEMEP
C                       (J=1,ND2X3).
C       FDSINS(IX,JY) = USED TO SAVE THE SIN OF THE LATITUDE IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C         FDMS(IX,JY) = USED TO SAVE THE MAP FACTOR IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C               ND2X3 = DIMENSION OF FD1( ), FD2( ), ETC.   MUST BE
C                       AT LEAST AS LARGE AS THE LARGEST GRID AND AS
C                       LARGE AS NSTA.  (INPUT)
C                IP12 = INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE INPUT VECTOR FILES WILL BE WRITTEN 
C                       TO UNIT IP12.
C                IP13 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE WRITTEN TO UNIT IP13 FOR VIEWING.  (INPUT)
C                IP14 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE CONTOURED AND WRITTEN TO UNIT IP14 FOR
C                       VIEWING.  (INPUT)
C                IP15 = INDICATES WHETHER (>1) OR NOT (=0) INTERPOLATED
C                       VALUES WILL BE WRITTEN TO UNIT IP15 FOR VIEWING.
C                       (INPUT)
C                IP16 = INDICATES WHETHER (>0) OR NOT (=0) DIAGNOSTICS
C                       WILL BE WRITTEN TO UNIT IP16 FOR LINEARIZATION
C                       AND CONSTANT ROUTINES (E.G., STATIONS IN
C                       THRESHOLD LISTS THAT ARE NOT BEING DEALT WITH
C                       IN THIS RUN).  (INPUT)
C              NTOTBY = THE TOTAL NUMBER OF BYTES IN THE FILE ASSOCIATED
C                       WITH UNIT NO. KFILIO (THE INTERPOLATED FILE).
C                       IT IS UPDATED WHEN THE DATA IN IPACK( ) ARE WRITTEN.
C                       (INPUT-OUTPUT)
C              NTOTRC = THE TOTAL NUMBER OF RECORDS IN THE FILE.  IT IS
C                       UPDATED AS NEEDED IN WRITEP.  (INPUT-OUTPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING USED
C                       (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  (INPUT)  
C              MISTOT = TOTAL NUMBER OF TIMES A PRIMARY MISSING INDICATOR
C                       HAS BEEN ENCOUNTERED IN UNPACKING GRIDS.  NOTE 
C                       THAT THIS IS LIMITED TO GRIDS AND DOES NOT
C                       INCLUDE VECTORS.  (INPUT-OUTPUT)
C            ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT MAY BE FATAL.
C                       FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER AN
C                       INPUT DATA RECORD IS NOT FOUND.  (INPUT-OUTPUT)
C                 IER = STATUS RETURN.
C                        0 = GOOD RETURN.
C                       38 = ND2X3 NOT LARGE ENOUGH.
C                       SEE OTHER ROUTINES FOR OTHER VALUES.
C                       (INTERNAL-OUTPUT)
C               NSLAB = THE NUMBER OF THE SLAB IN DIR( , , ) AND
C                       IN NGRIDC( , ) DEFINING THE CHARACTERISTICS
C                       OF THIS GRID.  SEE LSTORE(10, ).  (INTERNAL) 
C              NTIMES = THE NUMBER OF TIMES, INCLUDING THIS ONE, THAT THE 
C                       DATA HAVE BEEN FETCHED.  THIS IS STORED IN
C                       LSTORE(9, ).  (INTERNAL)
C                 NYR = YEAR, 4 DIGITS.  (INTERNAL)
C                 NMO = MONTH.  (INTERNAL)
C                 NDA = DAY OF MONTH.  (INTERNAL)
C                 NHR = HOUR, 2 DIGITS.  (INTERNAL)
C               LD(J) = HOLDS THE 3 ID WORDS OF THE DATA IN FDA( ) (J=1,3).  
C                       (INTERNAL)
C               LPARS = HOLDS THE VALUE OF IDPARS(15, ) OF THE DATA IN FDA( ).
C                       INITIALIZED TO 9999 FOR SAFETY.  (INTERNAL)
C               LFIND = THE VALUE OF IFIND( ) FOR THE VARIABLE IN FDA( ).
C                       (INTERNAL)
C               NSIZE = THE NUMBER OF VALUES IN VARIOUS ARRAYS, EITHER
C                       VECTOR OR GRIDPOINT.  (INTERNAL)
C               MISSP = PRIMARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C               MISSS = SECONDARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C              XMISSP = PRIMARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C              XMISSS = SECONDARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C              NGOMIS = SWITCH TO KEEP FROM PROCESSING A MISSING GRID.
C                       1 = MISSING GRIDPOINT DATA,
C                       0 = GOOD GRID DATA.
C                       (INTERNAL)
C              NWORDS = NUMBER OF WORDS IN IPACK( ) RETURNED FROM PACKV.
C                       (INTERNAL)
C              NRRDAT = DATE FAR INTO THE FUTURE TO FORCE SAVING OF
C                       STATION UPSLOPE VALUES.
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES USED 
C            GFETCH, OPTION, GRIDB, SMTH5, SMTH9, SMTH25, SMTH2X, SMTH3X,
C            INTRP, INTRPA, INTRPB, INTRPC, INTRPD, TRANS, BINARY,
C            PREDX1, PACKV, TIMPR
C
      CHARACTER*8 CCALL(ND1,6),
     1            CCALLD(ND5)
      CHARACTER*12 UNITS(NPRED)
      CHARACTER*20 NAME(ND1)
      CHARACTER*32 PLAIN(NPRED)
      CHARACTER*60 RACESS(NUMRA)
C
      DIMENSION ICALL(L3264W,ND1,6),
     1          NELEV(ND1),STALAT(ND1),STALON(ND1),ITIMEZ(ND1),
     2          ISDATA(ND1),SDATA(ND1),SDATA1(ND1),L1DATA(ND1)
      DIMENSION DIR(ND1,2,ND11),NGRIDC(6,ND11)
      DIMENSION ID(4,NPRED),IDPARS(15,NPRED),THRESH(NPRED),
     1          JD(4,NPRED),JP(3,NPRED),IFIND(NPRED),ISTAV(NPRED),
     2          ITIME(NPRED),ISCALD(NPRED),SMULT(NPRED),SADD(NPRED),
     3          ORIGIN(NPRED),CINT(NPRED)
      DIMENSION IPLAIN(L3264W,4,NPRED)
      DIMENSION FD1(ND2X3),FD2(ND2X3),FD3(ND2X3),FD4(ND2X3),
     1          FD5(ND2X3),FD6(ND2X3),FD7(ND2X3),FDA(ND2X3),
     2          FDVERT(ND2X3),FDTIME(ND2X3),FDSINS(ND2X3),FDMS(ND2X3)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5),ICALLD(L3264W,ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9),MSTORE(7,ND9)
      DIMENSION CORE(ND10)
      DIMENSION KFILRA(NUMRA)
      DIMENSION LD(3),ISTOP(2)
C
      DATA LPARS/9999/,
     1     NGOMIS/0/
      DATA NRRDAT/2100010100/
C
      IER=0
D     CALL TIMPR(KFILDO,KFILDO,'START PRED21        ')
C
C        SET UP SOME VALUES FOR LOADING IS1( ).
C
      NYR=NDATE/1000000
      NMO=NDATE/10000-NYR*100
      NDA=NDATE/100-NYR*10000-NMO*100
      NHR=NDATE-NYR*1000000-NMO*10000-NDA*100
C
C        FIND/COMPUTE ALL VARIABLES FOR THE DATE IN NDATE.
C      
      MITEMS=0
C 
      DO 400 N=1,NPRED
      ITIME(N)=1
C        ITIME(N) = 1 SIGNIFIES RR IS TO BE USED.  THIS WILL
C        BE MODIFIED LATER IF THE FULL ID IS LOCATED BY GFETCH.
      IFIND(N)=1
C        SET IFIND( ) FOR SAFETY.  IT SHOULD BE REPLACED.
C
      IF(IDPARS(1,N).EQ.799)GO TO 390
C           NO NEED TO LOOK FOR THE SPECIAL CCC = 799.
C
      IF(N.EQ.1)GO TO 130
      IF(ISTAV(N-1).EQ.1)GO TO 130
C        NOTE THAT ISTAV(N) HAS NOT BEEN INITIALIZED YET.
C
C        THIS SECTION IS NOT ENTERED FOR VECTOR DATA.
C        THIS VARIABLE CAN BE REUSED FROM THE PREVIOUS ONE ONLY IF:
C           (1) IT IS A GRID AND ONLY THE POINT COMPUTATIONS
C               ARE NECESSARY (E.G., INTERPOLATION).
C        IF GRID PROCESSING (E.G., SMOOTHING) IS NEEDED ON A 
C        BASIC GRID, IT MAY BE SAVED IN FDA( ).
C        THE MAIN PURPOSE OF THESE BYPASSES IS TO COUNT THE NUMBER OF
C        TIMES A GRID MUST BE ACCESSED ON SUBSEQUENT DATES.  THIS IS 
C        SO THAT ONLY THOSE DATA THAT MUST BE ACTUALLY RETRIEVED FROM 
C        THE MOS-2000 INTERNAL STORAGE SYSTEM WILL BE STORED WITH
C        GSTORE.)
C
      ISTAV(N)=ISTAV(N-1)
C        ISTAV(N) MAY LATER BE REPLACED.
      IF(JD(1,N).EQ.JD(1,N-1).AND.
     1   JD(2,N).EQ.JD(2,N-1).AND.
     2   JD(3,N).EQ.JD(3,N-1).AND.
     3   IDPARS(3,N).NE.5.AND.
     4   IDPARS(3,N-1).NE.5.AND.
     5   IDPARS(13,N).EQ.IDPARS(13,N-1).AND.
     6   IDPARS(14,N).EQ.IDPARS(14,N-1).AND.
     7   IDPARS(15,N).EQ.IDPARS(15,N-1).AND.
     8   NGOMIS.EQ.0)THEN
C           THE CHECK ON IDPARS(3,N-1) IS NOT NECESSARY WHEN
C           THE VARIABLES ARE ORDERED, AS THEY SHOULD BE
C           UNLESS SORTEM IS TAKEN OUT OF RDPRED.  NGOMIS
C           IS 1 WHEN THE PREVIOUS VARIABLE WAS MISSING.
         IFIND(N)=IFIND(N-1)
         GO TO 220
      ENDIF
C        WHEN THE ABOVE TEST IS MET, THE VARIABLE NEEDED IS THE
C        SAME AS THE PREVIOUS ONE.  THIS WILL BE A GRID,
C        THE DATA ARE IN DATA( ) AND POINT COMPUTATIONS
C        (E.G., INTERPOLATION) WILL BE DONE.  THE ONLY THING THAT
C        CAN BE DIFFERENT ARE BINARY THRESHOLDS.  SINCE POINT
C        BINARIES ARE NOT USUALLY MADE IN U201, THIS PROBABLY
C        HAS LITTLE UTILITY.
C
C        IS THIS VARIABLE REUSABLE AND STORED IN FDA( )?  NOTE THAT
C        THESE DATA ARE USED FOR MAKING A GRID BINARY AND/OR
C        SMOOTHING.
C
      IF(JD(1,N).NE.LD(1).OR.
     1   JD(2,N).NE.LD(2).OR.
     2   JD(3,N).NE.LD(3).OR.
     3   IDPARS(13,N-1).EQ.IDPARS(13,N).OR.
     4   IDPARS(14,N-1).EQ.IDPARS(14,N).OR.
     5   LPARS.NE.IDPARS(15,N))GO TO 130
C
C        TAKE DATA FROM FDA( ), UNLESS THE VALUES ARE MISSING, IN
C        WHICH CASE JUST SET THE INTERPOLATED VALUES MISSING.
C        DATA CAN BE USED FROM FDA( ) WHEN THE GRID (FROM GSTORE
C        OR OPTION) IS THE SAME, BUT MAKING A GRID BINARY AND
C        SMOOTHING CAN BE DIFFERENT, AS WELL AS THE POINT
C        CALCULATIONS OF MAKING A POINT BINARY, TRANSFORMATION,
C        AND INTERPOLATION.
C
D     WRITE(KFILDO,119)(JD(K,N),K=1,4)
D119  FORMAT( ' RESTORING GRID AT 119 IN PRED21 ',I11.9,3I11)
C
      IFIND(N)=LFIND
C
      DO 120  K=1,NSIZE
      DATA(K)=FDA(K)
 120  CONTINUE
C
      GO TO 205
C
 130  IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)GO TO 133
C        IN PRED21, TERRAIN HEIGHT MUST COME THROUGH OPTION WHEN 
C        DD = 0 (DD = 5 FOR LAMP FORECASTS).  PRED21 STORES 
C        TERRAIN DATA WITH DD = 0 AS VECTOR AT STATIONS (AT STATEMENT
C        NO. 360), PRED22 WILL OBTAIN THEM FROM THERE.
C
C        TRY TO FIND VARIABLE IN LSTORE AND RETURN IT IN DATA( ).
C        IF THE DATA ARE GRIDPOINT, THEN JD( , ) IS USED BECAUSE
C        THE RAW VARIABLE BEFORE THE PROCESSING IS DONE IS NEEDED.
C        WHEN THE DATA ARE VECTOR, THEN ID( , ) IS USED, BECAUSE
C        THE INPUT MAY HAVE COME FROM A PREVIOUS RUN OF U201
C        AND THE PROCESSING INDICATORS WILL ALREADY BE THERE.
C        SINCE ISTAV( ) IS INITIALIZED LATER, THERE IS NO WAY TO
C        TELL ON THIS FIRST ACCESS WHETHER VECTOR OR GRIDPOINT
C        DATA ARE NEEDED.  LOOK FOR VECTOR DATA FIRST, AND IF
C        NOT FOUND, THEN LOOK FOR GRIDPOINT DATA.
C
      JTIME=0
C        FIRST TRY WITH RR INOPERATIVE UNLESS THE PREVIOUS
C        VARIABLE IS THE SAME WITH ITIME = 0.  THEN, IN
C        ORDER TO NOT GET THE SAME VARIABLE, RR MUST BE
C        OPERATIVE.
C*******NOTE:  THE ND2X3 SHOULD REALLY BE ND5, BUT WITH A VERY
C*******       LARGE ND5 USES MUCH CP TIME PER DALLAVALLE.
 1300 CALL GFETCH(KFILDO,KFIL10,ID(1,N),N,LSTORE,ND9,LITEMS,
     1            IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,DATA,ND2X3,
     2            NSIZE,NPACK,NDATE,NTIMES,CORE,ND10,
     3            NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,JTIME,
     4            IER)
C***D     WRITE(KFILDO,1301)IER,N,(ID(KK,N),KK=1,4)
C***D1301 FORMAT(' AT 1301 IN PRED21, IER,N,ID( , ) =',2I6,I11.9,3I11)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN GFETCH.
      IF(IER.EQ.0)THEN
         ITIME(N)=JTIME
C           IF THE FULL ID WAS FOUND (WITH NO RR TIME OFFSET),
C           ITIME(N) IS SET TO JTIME SIGNIFYING WHETHER OR NOT RR
C           IS NOT TO BE USED ON SUBSEQUENT DAYS FOR THIS VARIABLE.
         IDYES=1
C           IDYES=1 INDICATES DATA FOR THE FULL ID WERE FOUND.
C           RR MAY OR MAY NOT HAVE BEEN OPERATIVE.
         GO TO 1305
      ELSE
         IDYES=0
         IF(IER.NE.47)ISTOP(1)=ISTOP(1)+1
C           THIS IS AN ERROR EXCEPT WHEN IER = 47.
C
         IF(JTIME.EQ.0)THEN
            JTIME=1
C              JTIME SET = 1 THE FIRST TIME THROUGH LETS
C              STATEMENT 1300 BE REPEATED ONLY ONCE.
            IF(IDPARS(9,N).NE.0)GO TO 1300
C              NO NEED TO ENTER GFETCH AGAIN IF RR = 0.
         ENDIF
C
      ENDIF
C
      IF(IER.EQ.47)THEN
         IF(ID(1,N).EQ.JD(1,N).AND.
     1      ID(2,N).EQ.JD(2,N).AND.
     2      ID(3,N).EQ.JD(3,N).AND.
     3      ID(4,N).EQ.JD(4,N))GO TO 1305
C              NO USE TO CALL GFETCH AGAIN FOR THE SAME THING.
C              CALLS GFETCH HERE ONLY ON IER = 47 FROM ABOVE.
C
C*******NOTE:  THE ND2X3 SHOULD REALLY BE ND5, BUT WITH A VERY
C*******       LARGE ND5 USES MUCH CP TIME PER DALLAVALLE.
         CALL GFETCH(KFILDO,KFIL10,JD(1,N),N,LSTORE,ND9,LITEMS,
     1               IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,DATA,ND2X3,
     2               NSIZE,NPACK,NDATE,NTIMES,CORE,ND10,
     3               NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,1,
     4               IER)
C***D        WRITE(KFILDO,1302)IER,N,(JD(KK,N),KK=1,4)
C***D1302    FORMAT(' AT 1302, IER,N,JD( , ) =',2I6,I11.9,3I11)
C
C           MOST NON-ZERO VALUES OF IER SHOULD BE NEAR FATAL.
C           ISTOP(1) IS INCREMENTED, EXCEPT WHEN IER = 47,
C           WHICH JUST MEANS DATA COULD NOT BE FOUND.  RETURNED
C           DATA WILL BE UNPACKED WHETHER OR NOT THEY WERE STORED
C           PACKED, AND NSIZE WILL BE THE NUMBER OF VALUES.
C           FOR GRIDPOINT DATA, THIS WILL BE IS2(3)*IS2(4); FOR
C           VECTOR DATA, THIS WILL BE NSTA.
      ENDIF
C
 1305 IF(IER.EQ.0)THEN
         IFIND(N)=1
C
         IF(NSIZE.GT.ND2X3)THEN
            WRITE(KFILDO,131)ND2X3,(ID(J,N),J=1,4),NSIZE
 131        FORMAT(/' ****ND2X3 =',I6,' TOO SMALL FOR GRID SIZE',
     1              ' PROCESSING VARIABLE',I11.9,3I11,
     2              ' IN PRED21 AT 131.  INCREASE TO GE',I6)
            IER=38
            ISTOP(1)=ISTOP(1)+1
            GO TO 300
         ENDIF
C
         IF(NSLAB.EQ.0)THEN
C
            IF(IDYES.EQ.0)THEN
               IFIND(N)=0
C                 IDYES = 0 INDICATES THAT THE FULL ID WAS NOT
C                 FOUND BY GFETCH, AND WHEN THE DATA ARE VECTOR,
C                 DATA FOR THE PARTIAL ID, EVEN IF FOUND, ARE
C                 NOT USED.  A PARTIAL ID INDICATES PROCESSING
C                 IS NEEDED, AND PROCESSING ON VECTOR DATA IS
C                 NOT DONE OUTSIDE OPTION.  NOTE THAT IT IS
C                 NOT KNOWN BEFORE CALLING GFETCH THE SECOND 
C                 TIME THAT THE DATA ARE VECTOR.
               GO TO 133
            ENDIF
C
            ISTAV(N)=1
C              WHEN NSLAB = 0, THE DATA ARE VECTOR, NOT GRIDPOINT.
C              TRANSFER DATA FROM DATA( ) TO SDATA( ) AND DO NO
C              PROCESSING.   THE ONLY PROCESSING THAT CAN BE DONE 
C              ON VECTOR DATA MUST BE DONE IN OPTION.
C              THEREFORE, PUT DATA INTO SDATA( ) AND OUTPUT.
C              NOTE THAT THE ARRANGEMENT OF VECTOR DATA HAS
C              ALREADY BEEN MADE IN RDSTR2.
            NSTA=NSIZE
C            
            DO 132 K=1,NSIZE
            SDATA(K)=DATA(K)
 132        CONTINUE
C
            GO TO 350
         ELSE
            ISTAV(N)=0
            IF(MISSP.NE.0)MISTOT=MISTOT+1
C              MISTOT IS AUGMENTED ONLY WHEN DATA ARE GRIDPOINT.
         ENDIF
C
         GO TO 138
C
      ELSEIF(IER.EQ.47)THEN
C           JUST MISSING DATA, A NOT UNEXPECTED EVENT.  GO TO OPTION,
C           DO NOT COUNT THIS AS AN ERROR.  (IT WOULD BE AN ERROR IN
C           PRED22.)
         ISTAV(N)=2
C           THE TYPE OF DATA IS UNDETERMINED.
         GO TO 133
C
      ELSE
         IFIND(N)=1
         ISTOP(1)=ISTOP(1)+1
C           FATAL ERROR FOR THIS VARIABLE.  IT WAS FOUND BY GFETCH, BUT
C           COULD NOT BE RETURNED.  ALL VALUES WILL BE MISSING.
C           GO TO 300 TO PUT MISSING VALUES INTO SDATA( ).
         ISTAV(N)=2
C           THE TYPE OF DATA IS UNDETERMINED.
         GO TO 300
C
      ENDIF
C
C        MUST COMPUTE THIS VARIABLE.
C
 133  CALL OPTION(KFILDO,KFIL10,NFIRST,
     1            ID(1,N),IDPARS(1,N),THRESH(N),JD(1,N),NDATE,
     2            KFILRA,RACESS,NUMRA,
     3            ICALL,CCALL,ICALLD,CCALLD,NAME,
     4            NELEV,STALAT,STALON,
     5            ITIMEZ,ISDATA,SDATA,SDATA1,L1DATA,DIR,ND1,NSTA,
     6            NGRIDC,NGRID,ND11,NSLAB,IPACK,IWORK,DATA,ND5,
     7            LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     8            NBLOCK,LASTD,NSTORE,NFETCH,
     9            IS0,IS1,IS2,IS4,ND7,
     A            FD1,FD2,FD3,FD4,FD5,FD6,FD7,
     B            FDVERT,FDTIME,FDSINS,FDMS,ND2X3,IP12,IP16,
     C            ISTAV(N),L3264B,L3264W,MISTOT,IER)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN OPTION.
      NSIZE=IS2(3)*IS2(4)
      IF(ISTAV(N).EQ.1)NSIZE=NSTA
C
C***D     WRITE(KFILDO,134)N,(ID(J,N),J=1,4),ISTAV(N),IER
C***D134  FORMAT(' OUT OF OPTION AT 133 IN PRED21--N,ID( ,N),ISTAV(N),IER',
C***D    1         I6,I11.9,3I11,2I6)
C
C        AS A SPECIAL FEATURE, IER = -1 FROM A SUBROUTINE CALLED
C        BY OPTION MEANS THAT THE DATA ARE NOT TO BE WRITTEN.
C        THIS CAN BE USED WHEN NOT ALL HOURS BEING PROCESSED
C        HAVE DATA FOR THAT HOUR (E.G., MAX/MIN TEMPERATURE).
C        ALSO, WHEN THE VARIABLE ID CANNOT BE LOCATED IN OPTION,
C        IER IS RETURNED AS -2.  THIS FACILITATES THE USE OF THE
C        LOOKBACK FEATURE WHEN NOT ALL DATA ARE AVAILABLE 
C        FOR DAY 1.
C 
      IF(IER.EQ.0)THEN
C           THE VARIABLE IS TO COME FROM OPTION.  THE SUBROUTINE
C           SHOULD HAVE SET ISTAV( ).
         IFIND(N)=0
         GO TO 1375
C
      ELSEIF(IER.EQ.-1)THEN
C           SURELY, THE VARIABLE IS TO COME FROM OPTION. 
C           THE SUBROUTINE SHOULD HAVE SET ISTAV( ).
         IFIND(N)=0
C            DON'T WRITE THIS VARIABLE.  IER = -1 IS RETURNED FROM
C            A SUBROUTINE.  IT SHOULD NOT REPRESENT AN ERROR; AN
C            ERROR SHOULD BE IER GT 0.
         GO TO 390
C
      ELSEIF(IER.EQ.-2)THEN
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=1
C           IER = -2 IS RETURNED FROM OPTION, WHICH MEANS VARIABLE
C           COULD NOT BE IDENTIFIED.  PUT THIS VARIABLE INTO 
C           MSTORE( , ) IN CASE IT IS A "RAW" VARIABLE AND IS 
C           JUST NOT AVAILABLE ON DAY 1.  SETTING IFIND( ) TO 1
C           KEEPS CONTROL OUT OF OPTION IN PRED22.
         ISTAV(N)=2
C           ISTAV(N) SET TO 2 WHEN THE VARIABLE COULD NOT BE
C           IDENTIFIED IN OPTION.  THIS WILL LET IT BE FOUND
C           ON INPUT IN CASES WHERE IT WAS NOT AVAILABLE ON
C           DAY 1.
C          
         GO TO 1343
C
      ELSEIF(IER.EQ.47)THEN
C           DON'T COUNT THIS AS AN ERROR.  IT IS POSSIBLE THE
C           VARIABLE IS FOUND IN OPTION, BUT MISSING DATA FROM
C           GFETCH THROWS IT TO OPTN2, WHERE THE VARIABLE CAN'T
C           BE IDENTIFIED.  THIS IS PROBABLY JUST CAUSED BY
C           MISSING DATA, AND OPTN2 DOES NOT WRITE A DIAGNOSTIC
C           UNLESS COMPILED WITH /D.
         IFIND(N)=2
C           STILL DON'T KNOW WHERE THE VARIABLE IS TO COME FROM.
         GO TO 1343
C
      ELSEIF(IER.EQ.120)THEN
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=0
C           THE VARIABLE IS TO COME FROM OPTION.
         IER=0
C           IER = 120 IS FROM FINDST IN CONST AND MEANS SOME
C           STATIONS COULD NOT BE FOUND.  THIS IS NOT FATAL.
         GO TO 1375
C
      ELSE
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=0
C           SURELY, THE VARIABLE IS TO COME FROM OPTION.
         GO TO 300
C
      ENDIF
C        IF OPTION COULD NOT IDENTIFY A VARIABLE, THEN IT
C        IT IS LIKELY THE VARIABLE IS ONE AVAILABLE ON
C        INPUT, BUT NOT AT THE FIRST DATE/TIME.  ENTER
C        IT INTO MSTORE( , ) IN ANTICIPATION.  THIS MAY
C        NOT WORK IN ALL CASES.  ONE PROBLEM IS THAT IT
C        IS NOT KNOWN WHETHER THIS IS A GRID NEEDED AT
C        TAU = IDPARS(12, ), IN WHICH CASE THE 4TH ID
C        WORD WOULD BE 0, OR WHETHER IT IS INTERPOLATED
C        DATA FROM A GRID, IN WHICH CASE THE 4TH ID 
C        WORD WOULD CONTAIN THE THRESHOLD, I, AND S.
C        MORE THAN ONE POSSIBILITY IS INCLUDED TO TRY
C        COVER ALL BASES.  NORMALLY, A BINARY WOULD
C        NOT BE LOOKED FOR AND IS NOT PROVIDED FOR,
C        EXCEPT FOR A GRID BINARY.
C
 1343 MITEMS=MITEMS+1
C
      IF(MITEMS.GT.ND9)THEN
         WRITE(KFILDO,1345)
 1345    FORMAT(/' ****ND9 =',I5,' NOT LARGE ENOUGH.',
     1           '  STOP AT 1345 IN PRED21.')
         STOP 1345
      ENDIF
C
      MSTORE(1,MITEMS)=IDPARS(1,N)*1000000+
     1                 IDPARS(2,N)*1000+
     2                 IDPARS(4,N)
      MSTORE(2,MITEMS)=ID(2,N)
      MSTORE(3,MITEMS)=IDPARS(8,N)*100000000+
     1                 IDPARS(10,N)*100000+
     2                 IDPARS(11,N)*1000+
     3                 IDPARS(12,N)
      MSTORE(4,MITEMS)=0
C
      IF(IDPARS(9,N).EQ.0)THEN
C           NOTE THAT ONLY "ON-TIME" DATA HAVE OTHER THAN 7777.
         MSTORE(5,MITEMS)=N+7777
         MSTORE(6,MITEMS)=NDATE
         MSTORE(7,MITEMS)=0
      ELSE
         MSTORE(5,MITEMS)=7777
         CALL UPDAT(NDATE,-IDPARS(9,N),LDATE)
         MSTORE(6,MITEMS)=LDATE
         MSTORE(7,MITEMS)=IDPARS(9,N)
C           DATA MAY BE KEPT LONGER THAN NEEDED; CAN'T
C           BE HELPED.
      ENDIF
C
C        DON'T KEEP IF A DUPLICATE, AND MAKE SURE
C        IT IS KEPT FAR ENOUGH BACK.
C
      IF(MITEMS.EQ.1)GO TO 1350
C
      DO 135 L=1,MITEMS-1
      IF(MSTORE(1,L).NE.MSTORE(1,MITEMS).OR.
     1   MSTORE(2,L).NE.MSTORE(2,MITEMS).OR.
     2   MSTORE(3,L).NE.MSTORE(3,MITEMS).OR.
     3   MSTORE(4,L).NE.MSTORE(4,MITEMS))GO TO 135
      IF(MOD(MSTORE(6,L),100).NE.MOD(MSTORE(6,MITEMS),100))GO TO 135
C        THE ABOVE STATEMENT KEEPS THE ENTRY IF ITS CYCLE 
C        IS DIFFERENT.
C
      IF(MSTORE(5,L).GT.7777)THEN 
         GO TO 1348
      ELSEIF(MSTORE(5,L).EQ.7777)THEN
C
         IF(MSTORE(5,MITEMS).EQ.7777)THEN
            GO TO 1348
         ELSEIF(MSTORE(5,MITEMS).LT.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,MITEMS)+7777
         ENDIF
C
      ELSE
C
         IF(MSTORE(5,MITEMS).LE.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,L)+7777
         ENDIF
C
      ENDIF
C
 1348 MSTORE(6,L)=MIN(MSTORE(6,L),MSTORE(6,MITEMS))
      MSTORE(7,L)=MAX(MSTORE(7,L),MSTORE(7,MITEMS))
C        
      MITEMS=MITEMS-1 
      GO TO 1350
C
 135  CONTINUE
C
C        THE BELOW IS FOR VECTOR DATA.  THIS SHOULD WORK
C        FOR OBSERVATIONS AND PREVIOUSLY COMPUTED/INTERPOLATED
C        DATA.  BINARIES ARE NOT PROVIDED FOR, EXCEPT FOR
C        GRID BINARIES.
C
 1350 MITEMS=MITEMS+1
C
      IF(MITEMS.GT.ND9)THEN
      WRITE(KFILDO,1351)
 1351 FORMAT(/' ****ND9 =',I5,' NOT LARGE ENOUGH.',
     1         '  STOP AT 1351 IN PRED21.')
      STOP 1351
      ENDIF
C
      MSTORE(1,MITEMS)=IDPARS(1,N)*1000000+
     1                 IDPARS(2,N)*1000+
     2                 IDPARS(4,N)
C
      IF(IDPARS(3,N).EQ.5)THEN
C           THIS IS A GRID BINARY.
         MSTORE(1,MITEMS)=MSTORE(1,MITEMS)+IDPARS(3,N)*100
      ENDIF
C
      MSTORE(2,MITEMS)=ID(2,N)
      MSTORE(3,MITEMS)=ID(3,N)
      MSTORE(4,MITEMS)=ID(4,N)
C        
      IF(IDPARS(9,N).EQ.0)THEN
C           NOTE THAT ONLY "ON-TIME" DATA HAVE OTHER THAN 7777.
         MSTORE(5,MITEMS)=N
      ELSE
         MSTORE(5,MITEMS)=7777
      ENDIF
C
      MSTORE(6,MITEMS)=NDATE
      MSTORE(7,MITEMS)=0
C
C        DON'T KEEP IF A DUPLICATE, AND MAKE SURE
C        IT IS KEPT FAR ENOUGH BACK.
C
      IF(MITEMS.EQ.1)GO TO 1370
C
      DO 137 L=1,MITEMS-1
      IF(MSTORE(1,L).NE.MSTORE(1,MITEMS).OR.
     1   MSTORE(2,L).NE.MSTORE(2,MITEMS).OR.
     2   MSTORE(3,L).NE.MSTORE(3,MITEMS).OR.
     3   MSTORE(4,L).NE.MSTORE(4,MITEMS))GO TO 137
C
      IF(MSTORE(5,L).GT.7777)THEN 
         GO TO 136
      ELSEIF(MSTORE(5,L).EQ.7777)THEN
C
         IF(MSTORE(5,MITEMS).EQ.7777)THEN
            GO TO 136
         ELSEIF(MSTORE(5,MITEMS).LT.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,MITEMS)+7777
         ENDIF
C
      ELSE
C
         IF(MSTORE(5,MITEMS).LE.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,L)+7777
         ENDIF
C
      ENDIF
C        
 136  MSTORE(6,L)=MIN(MSTORE(6,L),MSTORE(6,MITEMS))
      MSTORE(7,L)=MAX(MSTORE(7,L),MSTORE(7,MITEMS))
C        
      MITEMS=MITEMS-1
      GO TO 1370    
C
 137  CONTINUE
C
 1370 IER=0
C***D     WRITE(KFILDO,1374)((MSTORE(I,J),I=1,7),J=1,MITEMS)
C***D1374 FORMAT(' MSTORE IN PRED21 AT 1374'/(' '7I12))
      GO TO 300
C
C        COMES THROUGH HERE ONLY FOR IER = 0.
C
 1375 IF(ISTAV(N).EQ.1)GO TO 230
C        VECTOR DATA ARE NOT SAVED IN FDA( ).  TRANSFORMATION
C        AND BINARY OPERATORS ARE USED FOR VECTOR DATA FROM
C        OPTION (BUT NOT FOR VECTOR DATA NOT FROM OPTION). 
C
C        DETERMINE WHETHER OR NOT THE DATA IN DATA( ) CAN BE USED FOR
C        THE NEXT VARIABLE.  IF SO, SAVE IT IN FDA( ).  THIS IS OK 
C        EVEN THOUGH THE VALUES MAY BE SET TO THE MISSING VALUE.
C        NORMALLY, A MISSING FIELD IS NOT SAVED  OPTION DOES NOT SET
C        MISSING VALUES WHEN THE FIELD CANNOT BE RETURNED BECAUSE 
C        GFETCH HAS JUST BEEN CALLED WHICH DOES RETURN MISSING VALUES
C        WHICH ARE CARRIED OVER.  WHEN ISTAV( ) EQ 1, MISSING STATION
C        VALUES SHOULD BE RETURNED.  OCCASIONALLY, DATA WILL BE STORED
C        IN FDA( ) THAT ARE NOT NEEDED.  THIS HAPPENS WHEN 
C        INTERPOLATION AND SMOOTHING ARE THE SAME, BUT THE POINT BINARY
C        AND TRANSFORMATION IS PERFORMED ON THE INTERPOLATED DATA.
C        HOWEVER, SINCE THE PROGRAM LOOKS AHEAD ONLY ONE VARIABLE, IT IS
C        POSSIBLE THE DATA WOULD BE NEEDED EVEN THOUGH IT IS NOT NEEDED
C        FOR THE NEXT VARIABLE.
C
 138  IF(N.EQ.NPRED)GO TO 204
C        THE LAST VARIABLE IN THE LIST NEED NOT BE SAVED.
      IF(NSIZE.GT.ND2X3)GO TO 204
C        NSIZE CAN BE GREATER THAN ND2X3, BECAUSE ND5 CAN EXCEED
C        ND2X3.  THIS IS TO HANDLE LARGE CONSTANT GRIDS, SUCH
C        AS FINE SCALE TERRAIN.
C
C        SAVE GRID FOR POSSIBLE REUSE.  IT IS POSSIBLE IT WON'T BE 
C        NEEDED FOR THE NEXT VARIABLE (E.G., POINT BINARY) BUT
C        WILL BE NEEDED FOR THE NEXT (E.G., GRID BINARY).  OR IT
C        MAY NOT BE NEEDED AT ALL, BUT THIS CONTINGENCY KEEPS
C        GRIDS FROM BEING STORED BY GSTORE UNNECESSARILY IN
C        SUBSEQUENT PASSES IN PRED22.
C
      IF(JD(1,N).NE.JD(1,N+1).OR.
     1   JD(2,N).NE.JD(2,N+1).OR.
     2   JD(3,N).NE.JD(3,N+1).OR.
     3   IDPARS(15,N).NE.IDPARS(15,N+1))GO TO 204
C        THE IDPARS(15, ) CHECK IS A SAFETY.  AT PRESENT, IDPARS(15, )
C        IS NOT USED.     
C
      IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)GO TO 204
C        TERRAIN HEIGHT IS NOT SAVED WHEN DD = 0 (DD = 5 FOR LAMP
C        FORECASTS).
C
      LD(1)=JD(1,N)
      LD(2)=JD(2,N)
      LD(3)=JD(3,N)
      LPARS=IDPARS(15,N)
      LFIND=IFIND(N)
C        SAVES IFIND( ) SO THAT THE REUSED VARIABLE WILL HAVE THE
C        SAME VALUE.
C
D     WRITE(KFILDO,139)(JD(K,N),K=1,4)
D139  FORMAT(/' SAVING GRID AT 139 IN PRED21    ',I11.9,3I11)
C
      DO 140 K=1,NSIZE
      FDA(K)=DATA(K)
 140  CONTINUE
C
C        AT THIS POINT, THE VARIABLE HAS BEEN FOUND OR COMPUTED AND
C        EXISTS IN DATA( ).  THE FULL IDENTIFICATION IS IN IS1( ),
C        IS2( ), AND IS4( ).  IF IT MAY BE NEEDED FOR THE NEXT
C        VARIABLE AND IS A GRID, THE DATA ARE ALSO IN FDA( ).
C
 204  IF(IER.NE.0)GO TO 300
C        IT IS POSSIBLE THIS POINT COULD BE REACHED WITH MISSING
C        VALUES; HENCE, THE CHECK FOR IER=0 FOR SAFETY.
C
C        MAKE GRID BINARY IF DESIRED.
C
 205  IF(IDPARS(3,N).EQ.5)THEN
         CALL GRIDB(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),
     1              DATA,IWORK,IS2(3),IS2(4),IER)
C           IWORK( ) IS USED AS FLOATING POINT IN GRIDB.
C           THAT IS OK.  IWORK( ) AND DATA( ) ARE BOTH
C           DIMENSIONED ND5.
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
            GO TO 300
         ENDIF
C
      ENDIF
C
C        SMOOTH FIELD IF DESIRED.
C
      IF(IDPARS(14,N).NE.0)THEN
C
         IF(IDPARS(14,N).EQ.1)THEN
            CALL SMTH5 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.2)THEN
            CALL SMTH9 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.3)THEN
            CALL SMTH25(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.4)THEN
            CALL SMTH2X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.5)THEN
            CALL SMTH3X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
C              IWORK( ) IS USED AS FLOATING POINT IN 
C              SMOOTHING ROUTINES.  THAT IS OK.  IWORK( )
C              AND DATA( ) ARE BOTH DIMENSIONED ND5.
         ENDIF
C
      ENDIF
C
C        PRINT GRIDPOINT VALUES IF DESIRED.  TRY TO MATCH PRECISION
C        OF PRINTING TO SIZE OF VALUES THROUGH ISCALD( ).  WHILE
C        THE LOOP IS INEFFICIENT, IT WILL BE EXECUTED VERY RARELY.
C
      IF(IP13.EQ.0)GO TO 210
      IF(JP(1,N).EQ.0)GO TO 210
      WRITE(IP13,207)(ID(J,N),J=1,4),NDATE
 207  FORMAT(/' GRIDPOINT VALUES FOR VARIABLE',I11.9,3I11,
     1        ' FOR DATE',I12/)
C
      DO 209 JY=1,IS2(4)
C
      IF(ISCALD(N).LE.-1)THEN
         WRITE(IP13,208)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 208     FORMAT(' ',10F10.1/(' ',10F10.1))
      ELSEIF(ISCALD(N).EQ.0)THEN
         WRITE(IP13,2080)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2080    FORMAT(' ',10F10.2/(' ',10F10.2))
      ELSEIF(ISCALD(N).EQ.1)THEN
         WRITE(IP13,2081)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2081    FORMAT(' ',10F10.3/(' ',10F10.3))
      ELSEIF(ISCALD(N).EQ.2)THEN
         WRITE(IP13,2082)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2082    FORMAT(' ',10F10.4/(' ',10F10.4))
      ELSE
         WRITE(IP13,2083)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2083    FORMAT(' ',10F10.5/(' ',10F10.5))
      ENDIF
C
 209  CONTINUE
C
C        GRIDPRINT FIELD IF DESIRED.
C
 210  IF(IP14.EQ.0)GO TO 220
      IF(JP(2,N).EQ.0)GO TO 220
C
      CALL PREDX1(KFILDO,IDPARS(1,N),THRESH(N),
     1            SMULT(N),SADD(N),ORIGIN(N),CINT(N),
     2            PLAIN(N),UNITS(N),NDATE,-IDPARS(9,N),DATA,ND5,
     3            IS2,ND7,IP14,ISTOP(1),IER)
C        PREDX1 ALWAYS RETURNS IER = 0, EXCEPT FOR A PROBLEM
C        WITH GRIDPRINTING.  THIS DOES NOT CAUSE MISSING DATA.
C
C        INTERPOLATE TO STATIONS.
C
 220  NGOMIS=0
C        CONTROL HERE SHOULD MEAN NON-MISSING DATA.
C
      IF(IDPARS(13,N).EQ.1)THEN
         CALL INTRPA(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPA IS BIQUADRATIC INTERPOLATION WHERE POSSIBLE,
C           BILINEAR OTHERWISE.
C
      ELSEIF(IDPARS(13,N).EQ.2)THEN
         CALL INTRPB(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPB IS BILINEAR.
C
      ELSEIF(IDPARS(13,N).EQ.3)THEN
         CALL INTRP(KFILDO,DATA,IWORK,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRP IS INTERPOLATION FOR PRECIPITATION AMOUNT.  THE
C           PROCESS IS BILINEAR AFTER PREPARATION OF THE FIELD 
C           TO PUT THE ZERO LINE ABOUT HALFWAY BETWEEN POSITIVE 
C           AND ZERO GRIDPOINTS.
C           IWORK( ) IS USED AS FLOATING POINT IN INTRP.
C           THAT IS OK.  IWORK( ) AND DATA( ) ARE BOTH
C           DIMENSIONED ND5.
C
      ELSEIF(IDPARS(13,N).EQ.4)THEN
         CALL INTRPC(KFILDO,DATA,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPC IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT.
C
      ELSEIF(IDPARS(13,N).EQ.5)THEN
         NX=IS2(3)
         NY=IS2(4)
         CALL INTRPD(KFILDO,KFIL10,IP12,
     1               ID(1,N),IDPARS(1,N),JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,NELEV,
     4               ISDATA,SDATA,DIR,ND1,NSTA,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,ND5,
     7               LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               ND7,
     A               DATA,FD1,FD2,FD3,FD4,ND2X3,NX,NY,
     B               L3264B,L3264W,ISTOP(1),IER)
C           INTRPC IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT WITHIN THE 4-GRIDPOINT BOX WHERE THE STATION
C           IS LOCATED, BUT CONTINGENT ON A MASK INDICATING
C           A GRIDPOINT THAT CAN BE USED AND THE DIFFERENCE
C           BETWEEN THE ELEVATION OF THE GRIDPOINT AND THE
C           STATION BEING WITHIN BOUNDS (HARDWIRED IN INTRPD).
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
C              IER NE 0 FROM INTRPD IS TREATED AS AN ERROR, BUT
C              PROCESSING PROCEEDS.  IF THE GENERIC IDS WERE USED,
C              THE DATA ARE GOOD, BUT ISTOP(1) HAS BEEN INCREMENTED
C              IN INTRPD AND IER CAN = 0; IN OTHER CASES, THE DATA ARE
C              MISSING.  THE TRANSFORMATIONS BELOW HANDLE MISSING
C              VALUES.
            ISTOP(2)=ISTOP(2)+1
C              ANY IER NE 0 WILL MEAN MISSING DATA.  NOTE THAT THIS
C              IS THE ONLY "INTERPOLATION" ROUTINE THAT CAN ITSELF
C              CREATE AN ERROR OR MISSING DATA.
            IER=0
         ENDIF
C
      ELSEIF(IDPARS(1,N).GE.400.AND.IDPARS(1,N).LE.499)THEN
C            FOR THIS GRIDDED DATA FIELD, AN INTERPOLATION VALUE
C            OF 1, 2, 3, 4, OR 5 IS REQUIRED.
         WRITE(KFILDO,228)(JD(K,N),K=1,4)
 228     FORMAT(/' ****GRIDDED CONSTANT ',3I10.9,I11.3,' DOES NOT HAVE',
     1           ' A VALID INTERPOLATION VALUE IN IDPARS(13).'/
     2           '     DATA ARE SAVED IN INTERNAL STORAGE AS MISSING.',
     3           '  COUNTED AS MISSING ONLY THIS ONCE.')
         ISTOP(1)=ISTOP(1)+1
         GO TO 300
      ELSE
         GO TO 300
C           WHEN THE INTERPOLATION VALUE IS NOT LEGITIMATE, CKIDS WILL
C           HAVE PRINTED A DIAGNOSTIC EXCEPT FOR THE CONSTANTS
C           TREATED IMMEDIATELY ABOVE.
      ENDIF
C
C        TRANSFORM VARIABLE WHEN DESIRED.  FROM HERE ON, DATA ARE 
C        VECTOR.
C
 230  IF(IDPARS(1,N).GE.200.AND.IDPARS(1,N).LE.299)GO TO 350
      IF(IDPARS(1,N).GE.300.AND.IDPARS(1,N).LE.399)GO TO 350
      IF(IDPARS(1,N).GE.500.AND.IDPARS(1,N).LE.599)GO TO 350
      IF(IDPARS(1,N).GE.600.AND.IDPARS(1,N).LE.699)GO TO 350
C        IT IS ASSUMED THAT IF CCC = 2XX (MOS FORECASTS), 
C        3XX (COMBINATION OF MODELS), 5XX (1-D TRANSFORMATIONS)
C        AND 6XX (2-D TRANSFORMATIONS) SHOULD NOT HAVE BINARY
C        PROCESSING DONE.
C
      IF(IDPARS(10,N).EQ.9)GO TO 350
C        WHEN IDPARS(10, ) = 9, THE THRESHOLD IS USED THROUGH OPTION
C        AND NO FURTHER PROCESSING IS DONE.
C
      IF(IDPARS(8,N).NE.0)
     1    CALL TRANS(KFILDO,ID(1,N),IDPARS(8,N),SDATA,NSTA,FD1,ND2X3,
     2               IER)
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           WHEN IER NE O, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
         GO TO 312
      ENDIF
C
C         MAKE POINT BINARY VARIABLE WHEN DESIRED.
C
      IF(IDPARS(3,N).EQ.1)
     1    CALL BINARY(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),SDATA,NSTA,
     2                IER)
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           WHEN IER NE O, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
         GO TO 312
      ENDIF
C
C        CURRENTLY, THE ONLY LEGITIMATE VALUES OF IDPARS(3, ) ARE O, 1,
C        AND 5 IN U201.  OTHER VALUES CAUSE VALUES TO BE SET TO MISSING.
C        A DIAGNOSTIC WILL HAVE BEEN PROVIDED EARLIER AS TO 
C        NON-LEGITIMATE VALUES.  THIS ACCOMMODATES THE CUMULATIVE 
C        FROM ABOVE POINT BINARIES THAT CAN BE USED AS PREDICTORS 
C        AND GRID BINARIES, BUT NOT CUMULATIVE FROM BELOW OR DISCRETE
C        BINARIES THAT CAN BE USED AS PREDICTANDS.  NORMALLY, BINARIES
C        WILL NOT BE MADE BY U201 BECAUSE ALL USING PROGRAMS OF U201
C        OUTPUT WILL HAVE BINARY CAPABILITY.
C
      IF(IDPARS(3,N).EQ.0.OR.
     1   IDPARS(3,N).EQ.1.OR.
     2   IDPARS(3,N).EQ.5)GO TO 350
C
C        THE DATA ARE MISSING OR HAVE A NON-LEGITIMATE BINARY
C        INDICATOR.  NOTE THAT CCC = 2XX, 3XX, 5XX, AND 5XX HAVE BEEN
C        EXEMPTED FROM BINARY PROCESSING.  SET ALL VALUES TO 9999.
C
 300  DO 310 K=1,NSTA
      SDATA(K)=9999.
 310  CONTINUE
C
 312  ISTOP(2)=ISTOP(2)+1
C        AN ATTEMPT IS MADE TO COUNT ALL MISSING FIELDS IN ISTOP(2),
C        EVEN IF AN ERROR HAS BEEN COUNTED IN ISTOP(1).
      NGOMIS=1
C        SET NGOMIS = 1 TO KEEP FROM REUSING A GRID WITH 
C        MISSING VALUES.
      XMISSP=9999.
      XMISSS=0.
      GO TO 380
C        DON'T WRITE IDPARS(1, ) = 409 TO INTERNAL STORAGE IF
C        RECORD IS MISSING.  THIS WILL LET PRED22 COUNT MISSING 
C        RECORDS.  SINCE ALL VALUES = 9999., NO REASON TO ENTER
C        SETMIS.
C
C        SET XMISSP AND XMISSS.  NOTE THAT ANY VALUES OF 9997
C        IN VECTOR DATA HAVE BEEN SET TO PXMISS IN RDSTR2.
C        9997 IS NOT EXPECTED OR DEALT WITH IN GRIDPOINT DATA.
C        OPTION SHOULD NOT RETURN 9997 UNLESS IT IS DESIRED
C        TO LEAVE THOSE VALUES IN THE OUTPUT.
C
 350  CALL SETMIS(KFILDO,SDATA,NSTA,XMISSP,XMISSS)
C
C        FOR TERRAIN, SAVE VECTOR IN GSTORE.  THIS WILL BE THE
C        SAMED FOR EACH DAY FOR DD = 0 (DD = 5 FOR LAMP FORECASTS).
C
 360  IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)THEN
         NCOMBO=1
C           NCOMBO HAS NO MEANING FOR VECTOR DATA.
         NPACK=1
C           THE DATA ARE NOT PACKED.
         MSDATE=0
C           THE DATE TO STORE IS ZERO.
         CALL GSTORE(KFILDO,KFIL10,ID(1,N),NCOMBO,LSTORE,ND9,LITEMS,
     1               SDATA,NSTA,NPACK,NRRDAT,MSDATE,
     2               CORE,ND10,LASTL,NBLOCK,LASTD,
     3               NSTORE,L3264B,IER) 
      ENDIF
C
 380  CONTINUE
C
C        PACK AND WRITE THE DATA.
C
C***      WRITE(KFILDO,388)IS0,IS1,IS2
C*** 388  FORMAT(/' AT 388 IN PRED21--IS0,IS1,IS2'/(5(10I10/),4I10/))
C***      WRITE(KFILDO,389)ID(1,N),N,IP15,ISCALD(N),ND1,NSTA,
C***     1       ND5,ND7,L3264B,L3264W,NDATE,NTOTBY,NTOTRC,
C***     1      (SDATA(K),K=1,NSTA)
C*** 389  FORMAT(/' AT 389 IN PRED21--N,ID(1,N),IP15,ISCALD(N),ND1,NSTA,',
C***     1         'ND5,ND7,L3264B,L3264W,NDATE,NTOTBY,NTOTRC'/
C***     2         I10,12I8/
C***     3         (20F6.1))
      CALL PACKV(KFILDO,KFILIO,ID(1,N),IDPARS(1,N),
     1           JP(1,N),ISCALD(N),0,
     2           IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3           CCALL,ISDATA,SDATA,ND1,NSTA,IPACK,ND5,MINPK,
     4           IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5           IP15,NWORDS,NTOTBY,NTOTRC,
     6           L3264B,L3264W,ISTOP(1),IER)
C
 390  CONTINUE
C***D     WRITE(KFILDO,391)N,(ID(J,N),J=1,4),
C***D    1                 ISTAV(N),ISTOP(1),ISTOP(2),IFIND(N),IER
C***D391  FORMAT(/' AT 391 IN PRED21--N,(ID(J,N),J=1,4),',
C***D    1                'ISTAV(N),ISTOP(1),ISTOP(2),IFIND(N),IER',
C***D    2                 /I6,I11.9,3I11,5I6)
 400  CONTINUE
C
C***D     WRITE(KFILDO,405)((MSTORE(I,J),I=1,7),J=1,MITEMS)
C***D405  FORMAT(' MSTORE IN PRED21 AT 405'/(' '7I12))
      RETURN
      END
