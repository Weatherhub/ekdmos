      SUBROUTINE RDSTRX(KFILDO,KFIL10,KFILIN,NAMIN,JFOPEN,MDATE,NUMIN,
     1                  NDATE,CCALLD,IPACK,IWORK,DATA,ND5,
     2                  ID,IDPARS,ITAU,NVRBL,
     3                  IS0,IS1,IS2,IS4,ND7,
     4                  LSTORE,LITEMS,ND9,NBLOCK,CORE,ND10,
     5                  LASTL,LASTD,NSTORE,IP10,
     6                  CCALL,INDEXC,XDATA,ND1,NSTA,PXMISS,
     7                  IP12,IP23,L3264B,L3264W,ISTOP,IER)
C
C        JANUARY   1996   GLAHN   TDL   MOS-2000
C        FEBRUARY  1996   GLAHN   NAME CHANGE FROM RDSTR2
C        OCTOBER   1996   GLAHN   MODIFIED TO CLOSE FILE ON EOF
C        OCTOBER   1996   GLAHN   ADDED SUBROUTINE RDDIR 
C        DECEMBER  1996   GLAHN   CHANGED DIMENSION OF CCALLD, ND1 TO ND5
C        JANUARY   1997   GLAHN   ONE CHECK IER=38 REMOVED, IPACK( )
C                                 READING CHANGED TO MIN(ND5,...),
C                                 CHANGED 2-D IPACK TO 1-D.
C        FEBRUARY  1997   GLAHN   RESTRUCTURED TO STORE UNPACKED DATA BY
C                                 GSTORE, ADDED NBYTES(L3264W),
C                                 ADDED IER = 138.
C        FEBRUARY  1997   GLAHN   MODIFIED FOR PREDICTAND LOOKAHEAD
C        JULY      1997   GLAHN   INCREASED DIMENSIONS OF CCALL( ) TO
C                                 SUPPORT SUBSTITUTE STATIONS.
C        AUGUST    1997   GLAHN   MODIFIED SO THAT ALL DATA FOR DAY1
C                                 NEED NOT BE ON THE FIRST FILE.
C        SEPTEMBER 1997   GLAHN   CHANGES FOR TRAILER USE CHANGE
C        NOVEMBER  1997   GLAHN   PXMISS ADDED TO CALL, AND USED
C        DECEMBER  1997   GLAHN   MAXTAU COMPUTATION CHANGED
C        DECEMBER  1997   GLAHN   NOPP1 REMOVED
C        DECEMBER  1997   GLAHN   REMOVED SPACE IN A FORMAT
C        FEBRUARY  1998   GLAHN   CHANGED PRINT FOR LSTORE( , )
C        FEBRUARY  1998   GLAHN   INSERTED TEST FOR MSTA = 0
C        APRIL     1998   GLAHN   COMMENT CHANGED.
C                                 ADDED ISTOP=ISTOP+1 IN 3 PLACES
C        APRIL     1998   GLAHN   ADDED TEST FOR AEV DATA IN DO 2172
C        MAY       1998   GLAHN   REMOVED NTYPVR( ); ADDED ITAU( ),
C                                 PLUS OTHER CHANGES
C        JUNE      1998   GLAHN   ADDED MDATE( )
C        AUGUST    1998   GLAHN   ADDED TEST ON NUMIN = 0, GO TO 235
C        OCTOBER   1998   GLAHN   INDEXC( ) = 99999999 FOR MISSING
C        NOVEMBER  1998   GLAHN   COMMENT CHANGE
C        JANUARY   1999   GLAHN   CHANGES FOR LOOKAHEAD, IN 218 LOOP
C        NOVEMBER  1999   GLAHN   CORRECTED SPELLING
C        MARCH     2000   GLAHN   SET IER = 0 BEFORE RETURN AFTER 229
C        APRIL     2000   DALLAVALLE   MODIFIED FORMAT STATEMENTS TO 
C                                 CONFORM TO FORTRAN 90 STANDARDS
C                                 ON THE IBM SP
C        OCTOBER   2003   GLAHN   COMMAS IN COMMENTED OUT STATEMENTS
C        JULY      2004   GLAHN   CHANGED I4 TO I6 IN FORMAT 229
C        JUNE      2005   RLC     INCORPORATED MCE 5/2000 OPERATIONAL
C                                 MODIFICATION "REMOVED FILENAME FROM 
C                                 OPEN STATEMENT FOR OPERATIONS"
C        JULY      2012   ENGLE   ADDED CONVERTX; ADDED CALL TO CKFILEND
C                                 BEFORE OPENING A TDLPACK VECTOR FILE;
C                                 MODIFIED OPEN STATEMENT TO INCLUDE
C                                 CONVERT= SPECIFIER.
C
C        PURPOSE
C           TO READ PACKED VECTOR DATA FROM ALL MODELS NEEDED FOR THE
C           FIRST DAY AND TO STORE ALL FIELDS.  IT IS ASSUMED 
C           NO DATA ARE NEEDED FOR A DATE PRIOR TO THE FIRST DATE IN
C           THE SAMPLE.  THE CALL LETTERS RECORDS ARE READ AND MATCHED
C           WITH THE CALL LETTERS IN CCALL( , ), AND THE LOCATIONS
C           STORED IN INDEXC( , ).  RDSTRX INCORPORATES LOOKAHEAD.
C           IT IS MOST EFFICIENT IN TERMS OF HOW FAR AHEAD A
C           PARTICULAR FILE IS READ AND DATA STORED WHEN THE
C           FILE CONTAINING THE VARIABLES WHICH ARE TO BE FOUND
C           BY LOOKAHEAD (NORMALLY PREDICTANDS) IS READ FIRST.
C           HOWEVER, CORRECT EXECUTION SHOULD NOT DEPEND ON 
C           THE ORDER.
C           
C        DATA SET USE
C            KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10 - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                     (INPUT-OUTPUT) 
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)  
C           KFILIN(J) = UNIT NUMBERS FOR INPUT DATA, ALL IN TDL GRIB 
C                       FORMAT.  INPUT CAN INCLUDE INTERPOLATED MODEL
C                       DATA, PREDICTAND (OBSERVATIONS) DATA, VARIOUS
C                       CONSTANTS, OR MOS FORECASTS (FOR 2ND GENERATION
C                       MOS, POSSIBLY FOR LOCAL IMPLEMENTATION
C                       (J=1,NUMIN).  UNIT NUMBERS SHOULD BE THE SAME AND
C                       THE FILE NAMES IN SEQUENCE WHEN FILES ARE TO BE
C                       USED SEQUENTIALLY.  THE FIRST ONE (ONLY) WILL BE
C                       OPEN WHEN RDSTRX IS ENTERED.  (INPUT)
C            NAMIN(J) = NAME OF THE INPUT FILES BEING PROCESSED 
C                       (J=1,NUMIN).  (CHARACTER*60)  (INPUT)
C           JFOPEN(J) = FOR EACH FILE IN KFILIN(J), JFOPEN(J) IS 1 WHEN
C                       THE FILE IS OPEN, IS 0 WHEN IT HAS ALREADY BEEN
C                       USED AND IS 2 WHEN THE FILE HAS NOT BEEN OPENED 
C                       (J=1,NUMIN).  (OUTPUT)
C            MDATE(J) = THE LAST DATE READ BY RDSTRX FOR DAY 1 FOR EACH
C                       FILE (J=1,ND6).  THIS IS USED TO KEEP A 
C                       DIAGNOSTIC FROM PRINTING IN RDVECT.  (OUTPUT)
C               NUMIN = THE NUMBER OF VALUES IN KFILIN( ), NAMIN( ), AND
C                       INDEXC( , ).  ALSO TREATED AS THEIR DIMENSIONS.
C                       (INPUT)
C               NDATE = DAY 1 DATE IN FORM YYYYMMDDHH.  (INPUT)
C           CCALLD(K) = THE CALL LETTERS READ FROM THE INPUT FILES 
C                       (K=1,ND5).  (CHARACTER*8)  (INTERNAL)
C            IPACK(J) = HOLDS THE TDL GRIB RECORD (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  FURNISHED TO UNPACK.
C                       (INTERNAL)
C             DATA(J) = WORK ARRAY (J=1,ND5).  FURNISHED TO UNPACK AND
C                       UNPACKED DATA RETURNED.  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).
C                       MUST BE GE THE NUMBER OF STATIONS ON THE
C                       INPUT INTERPOLATED FILE(S).  (INPUT)
C             ID(J,N) = THE INTEGER VARIABLE ID'S NEEDED (J=1,4)
C                       (N=1,NVRBL).  (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE
C                       VARIABLE ID'S CORRESPONDING TO ID( ,N)
C                       (J=1,15), (N=1,NVRBL).  (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                          0 = NOT BINARY,
C                          1 = CUMULATIVE FROM ABOVE, VALUES GE LOWER
C                              THRESHOLD TRESHL = 1,
C                          2 = CUMULATIVE FROM BELOW, VALUES LT UPPER
C                              THRESHOLD TRESHU = 1.
C                          3 = DISCRETE BINARY.  VALUES GE LOWER 
C                              THRESHOLD AND LT UPPER THRESHOLD = 1.
C                          5 = GRID BINARY.  VALUES GE LOWER THRESHOLD
C                          ONLY THE VALUE OF 0, 1, OR 5 SHOULD BE USED
C                          FOR PREDICTORS;
C                          0, 1, 2, OR 3 CAN BE USED FOR PREDICTANDS.
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 
C                            1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND 
C                            BACK IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C                       (OUTPUT)
C             ITAU(N) = THE NUMBER OF HOURS TO ADD TO NDATE TO GET 
C                       THE VARIABLE N (N=1,NVRBL).
C                       THIS IS THE "LOOKAHEAD" FEATURE.  (INPUT)
C               NVRBL = THE TOTAL NUMBER OF VARIABLES.  (INPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).  (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).  (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C         LSTORE(L,J) = THE ARRAY TO HOLD INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.  NOTE THAT WHEN A FIELD 
C                              CANNOT BE STORED IN CORE( ), IT IS PUT
C                              ON DISK.  IT MAY BE THAT A LATER FIELD 
C                              WILL FIT, AND IT IS PUT IN CORE( ).
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --THE VALUE OF "IN" IN LOOPING THROUGH THE
C                              INPUT DATA SETS.  THIS IS NEEDED FOR INDEXING
C                              THE STATION LOCATIONS FROM THE VARIOUS
C                              INPUTS.
C                       L=11 --THE NUMBER OF THE PREDICTOR IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NVRBL) FOR WHICH THIS
C                              VARIABLE IS NEEDED, WHEN IT IS NEEDED ONLY
C                              ONCE FROM LSTORE( , ).  WHEN IT IS NEEDED
C                              MORE THAN ONCE, THE VALUE IS SET = 7777.
C                       L=12 --USED INITIALLY IN ESTABLISHING MSTORE( , ).
C                              LATER USED AS A WAY OF DETERMINING WHETHER
C                              TO KEEP THIS VARIABLE.
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , ) THAT 
C                       HAVE BEEN USED IN THIS RUN.  INITIALIZED TO ZERO
C                       AT BEGINNING.  (OUTPUT)
C                 ND9 = 2ND DIMENSION OF LSTORE( , ).  (INPUT)
C              NBLOCK = THE RECORD SIZE FOR THE FILE TO WRITE THE DATA
C                       WHEN CORE( ) IS FULL.  (INPUT)
C             CORE(J) = THE ARRAY TO STORE THE DATA IDENTIFIED IN
C                       LSTORE( , ) (J=1,ND10).  WHEN CORE( ) IS FULL
C                       DATA ARE STORED ON DISK.  (OUTPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C               LASTL = THE LAST LOCATION IN CORE( ) USED.  INITIALIZED 
C                       TO 0 ON FIRST ENTRY TO GSTORE.  (INPUT/OUTPUT)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK.
C                       INITIALIZED TO 0 ON FIRST ENTRY TO GSTORE. 
C                       (INPUT/OUTPUT)
C              NSTORE = RUNNING COUNT OF NUMBER OF TIMES DATA ARE 
C                       STORED BY GSTORE.  INITIALIZED TO ZERO THE
C                       FIRST TIME GSTORE IS CALLED.  THE USER NEED 
C                       NOT WORRY ABOUT THIS.  IT CAN BE USED FOR
C                       DIAGNOSTICS IF NEEDED.  (OUTPUT)
C                IP10 = INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                       FIELDS READ FOR DAY 1 WILL BE PRINTED TO THE FILE
C                       WHOSE UNIT NUMBER IS IP10.  (INPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST.  (CHARACTER*8)
C                       (INPUT)
C         INDEXC(K,J) = LOCATIONS OF THE STATIONS CORRESPONDING TO
C                       CCALL(K, ) (K=1,NSTA) FOR EACH MODEL (J=1,NUMIN).
C                       IF THE STATION CAN'T BE FOUND IN THE DIRECTORY,
C                       INDEXC( ) IS SET TO 99999999.  NOTE THAT THIS
C                       MUST BE LARGER THAN THE MAXIMUM NUMBER OF
C                       STATIONS BEING DEALT WITH (GRIDPOINTS IN THE
C                       CASE OF GRIDPOINT DEVELOPMENT).  (OUTPUT)
C            XDATA(J) = WORK ARRAY (J=1,ND1).  (INTERNAL)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT WITH.
C                       (INPUT)
C                NSTA = THE NUMBER OF STATIONS IN CCALL( , ).  (INPUT)
C              PXMISS = THE VALUE OF A SECONDARY MISSING VALUE TO INSERT
C                       WHEN THE SECONDARY MISSING VALUE IS 9997.
C                       THIS ALLOWS MAINTAINING A 9997, TREATING IT AS 
C                       ZERO, AS 9999, OR AS SOME OTHER VALUE.  (INPUT)
C                IP12 = INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE INPUT FILES WILL BE PRINTED TO 
C                       THE FILE WHOSE UNIT NUMBER IS IP12.  (INPUT)
C                IP23 = INDICATES WHETHER (>0) OR NOT (=0) STATEMENTS
C                       ABOUT EOF AND FILE OPENINGS AND CLOSINGS WILL
C                       BE OUTPUT FOR PRINTING ON UNIT IP(23).  (INPUT)
C              L3264B = THE NUMBER OF BITS IN THE WORD OF THE MACHINE
C                       BEING USED, 32 OR 64.  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).
C                       (INPUT)
C               ISTOP = INCREMENTED BY ONE EACH TIME AN ERROR IS 
C                       ENCOUNTERED.  (INPUT-OUTPUT)
C                 IER = STATUS RETURN.
C                         0 = GOOD RETURN.
C                        31 = TROUBLE OPENING OR SWITCHING FILES.
C                        38 = NUMBER OF WORDS READ EXCEEDS ARRAY SIZE ND5.
C                        56 = NO DATA FOUND FOR DAY 1.
C                       120 = ONE OR MORE STATIONS CAN'T BE FOUND ON ONE OR
C                             INPUT FILES IN RDDIR/FINDST.
C                       138 = ERROR READING PACKED RECORDS.
C                       140 = ERROR READING CALL LETTERS RECORD IN RDDIR.
C                       145 = SIZE OF CALL LETTERS RECORD EXCEEDS ARRAY SIZE
C                             CCALLD(ND5) IN RDDIR.  TRY TO RETURN 
C                             WITH ERROR INDICATED.
C                       146 = END OF FILE FOUND IN RDDIR.
C                       SEE OTHER ROUTINES FOR OTHER VALUES.  (OUTPUT)
C      NBYTES(L3264W) = NUMBER OF BYTES IN RECORD, FOLLOWING THE INITIAL
C                       64 BITS CONTAINING NBYTES ITSELF.   (INTERNAL)
C              NWORDS = NUMBER OF WORDS IN IPACK( ).  NWORDS IS CALCULATED 
C                       NWORDS=NBYTES*8/L3264B, WHERE NBYTES IS THE LENGTH 
C                       IN BYTES READ FROM THE RECORD ITSELF.  (INTERNAL)
C                MSTA = NUMBER OF STATIONS IN THE DIRECTORY (FIRST) RECORD
C                       OF THE FILE BEING PROCESSED.  TAKEN FROM THE RECORD
C                       SIZE.  (INTERNAL)
C                NREP = DETERMINES IN EACH LOOP IN=1,NUMIN WHETHER MAXTAU
C                       AND LDATE SHOULD BE RESET.  NREP NORMALLY = 0,
C                       BUT = 1 WHEN A NEW FILE HAS BEEN OPENED FOR 
C                       THE SAME UNIT NUMBER.  THIS IS NECESSARY FOR 
C                       THE LOOKAHEAD FEATURE TO WORK PROPERLY WHEN
C                       ALL PREDICTAND DATA FOR DAY 1 IS NOT ON THE 
C                       FIRST FILE WITH THAT UNIT NUMBER.  (INTERNAL)
C               LDATE = LOCAL COPY OF NDATE, UPDATED TO INDICATE
C                       HOW FAR TO READ A PARTICULAR FILE.  THIS IS
C                       DETERMINED BY THE ITAU( )S OF ALL THE
C                       VARIABLES NOT ALREADY FOUND (THAT HAVE AN
C                       (ITAU( ) GT 0).  (INTERNAL)
C               MXTAU = THE MAXIMUM TAU USED TO UPDATE LDATE.
C                       (INTERNAL)
C               MITAU = USED TO TEST AGAINST MXTAU.  (INTERNAL)
C              LSTOPC = AN INTERNAL COUNTER TO KEEP AN INFINITE READING
C                       LOOP FROM OCCURRING.  (INTERNAL)
C               LSTOP = THE VALUE TO COMPARE LSTOPC WITH TO STOP THE
C                       READING.  CURRENTLY SET AT 500; THIS ASSUMES
C                       500 READING ERRORS SHOULD NOT OCCUR IN A SINGLE
C                       RUN.  NOTE THAT THIS COUNT IS SEPARATE FROM
C                       ISTOP IN CASE ISTOP HAS TO BE LARGE WHEN DEALING
C                       WITH HOURLY DATA AND MISSING STATIONS.  (INTERNAL)
C            IFIND(J) = AUTOMATIC ARRAY TO KEEP TRACK OF WHICH 
C                       VARIABLES HAVE BEEN FOUND.  (INTERNAL)
C            CONVERTX = CHARACTER HOLDING THE KEYWORD USED TO OPEN
C                       RANDOM ACCESS FILE WITH THE CORRECT ENDIAN.
C                       (CHARACTER*20).
C
C        NONSYSTEM SUBROUTINES USED 
C            UNPACK, GSTORE, UNPKBG, RDDIR, UPDAT, TIMPR, CKFILEND
C
      CHARACTER*8 CCALL(ND1,6)
      CHARACTER*8 CCALLD(ND5)
      CHARACTER*60 NAMIN(NUMIN)
CINTEL
      CHARACTER*20 CONVERTX
CINTEL
C
      DIMENSION XDATA(ND1)
      DIMENSION ID(4,NVRBL),IDPARS(15,NVRBL),ITAU(NVRBL)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9)
      DIMENSION CORE(ND10)
      DIMENSION KFILIN(NUMIN),JFOPEN(NUMIN),MDATE(NUMIN)
      DIMENSION INDEXC(ND1,NUMIN)
      DIMENSION NBYTES(L3264W),IFIND(NVRBL)
C        NBYTES AND IFIND ARE AUTOMATIC ARRAYS.
C
CINTEL
      CONVERTX='BIG_ENDIAN'
CINTEL
      DATA LSTOP/500/,
     1     LSTOPC/0/
C
D     CALL TIMPR(KFILDO,KFILDO,'START RDSTRX        ')
C
      IER=0
      LITEMS=0
      NREP=0
      MITAU=0
C
C        INITIALIZE IFIND( ).
C
      DO 110 J=1,NVRBL
      IFIND(J)=0
 110  CONTINUE
C
C        IT IS POSSIBLE NO INPUT IS NEEDED HERE; RATHER ALL
C        INPUT WILL BE FROM RANDOM ACCESS CONSTANT FILE.
C
      IF(NUMIN.EQ.0)THEN
         IER=56
         GO TO 235
      ENDIF
C
C        START PROCESSING DAY 1 DATA.  FIRST READ THE CALL LETTERS
C        RECORD.  ALL DATA SOURCES ARE USED.
C
      DO 225 IN=1,NUMIN
D     WRITE(KFILDO,120)IN,((ID(L,J),L=1,4),ITAU(J),IFIND(J),
D    1                  J=1,NVRBL)
D120  FORMAT(' RDSTRX,IN,ID,ITAU,IFIND'I4/('     ',4I11,2I4))
      MDATE(IN)=0
      IF(JFOPEN(IN).NE.1)GO TO 225
C
      IF(NREP.EQ.0)THEN
         LDATE=NDATE
C           LDATE IS LOCAL COPY OF NDATE, WHICH IS UPDATED AS
C           NECESSARY FOR LOOKAHEAD.
         MAXTAU=0
         MITAU=0
C           MAXTAU AND MITAU ARE USED IN THE LOOKAHEAD FEATURE.
      ENDIF
C
 150  CALL RDDIR(KFILDO,KFILIN(IN),IP12,NAMIN(IN),NDATE,
     1           CCALL,INDEXC(1,IN),ND1,NSTA,CCALLD,ND5,MSTA,
     2           L3264B,L3264W,IER)
C
C***D     WRITE(KFILDO,151)IER,NSTA,MSTA,ND5,L3264B,L3264W
C***D151  FORMAT(' RDSTRX--IER,NSTA,MSTA,ND5,L3264B,L3264W'6I8)
      IF(IER.EQ.0)GO TO 200
C
      IF(IER.EQ.146)THEN
C           IER = 146 MEANS END OF FILE IN RDDIR.  SINCE
C           A TRAILER ALWAYS FOLLOWS DATA, THIS IS NOT
C           UNEXPECTED AND IS NOT COUNTED AS AN ERROR.
         GO TO 219
C
      ELSEIF(IER.EQ.120)THEN
C           IER = 120 IS NOT FATAL.  IT MEANS ONE OR MORE STATIONS
C           CAN'T BE FOUND ON INPUT FILE.
         ISTOP=ISTOP+1
         IF(MSTA.EQ.0)GO TO 2191
C           IT IS ASSUMED THAT IF THE NUMBER OF STATIONS FOUND
C           IN THE DIRECTORY IS ZERO, THE FILE IS UNUSABLE.
         GO TO 200
C
      ELSE
C           OTHER VALUES OF IER FROM RDDIR ARE FATAL FOR THIS DATA SET.
C           CLOSE IT AND MOVE ON.
         ISTOP=ISTOP+1
         GO TO 2191
C
      ENDIF
C 
C        READING CALL LETTERS COMPLETE AND INDEXC( , ) INITIALIZED
C        FOR MODEL IN.  NOW READ THE DATA.
C     
 200  READ(KFILIN(IN),IOSTAT=IOS,ERR=201,END=219)
     1               (NBYTES(J),J=1,L3264W),
     2               (IPACK(J),J=1,MIN(ND5,NBYTES(L3264W)*8/L3264B))
C
C*****************************
C****    TO CHECK MESSAGE, DECLARE IBYTE(2000) LOGICAL*1, AND REPLACE
C****    ABOVE READ WITH THE FOLLOWING READ AND WRITE.
C****      READ(KFILIN(IN),IOSTAT=IOS,ERR=201,END=219)
C****     1               (NBYTES(J),J=1,L3264W(L3264W)),
C****     2               (IBYTE(J),J=1,NBYTES)
C****D     WRITE(KFILDO,210)(IBYTE(J),J=1,NBYTES)
C****D210  FORMAT(/' PACKED MESSAGE'/
C****D    1      (16(1X,O3.3)))
C****      STOP 5555
C*****************************
C
C        IPACK( ) CONTAINS THE PACKED RECORD.
C        THE RECORD CONSISTS OF AN INITIAL 8 BYTES CONTAINING THE NUMBER
C        OF BYTES FOLLOWING.  FOR A 32-BIT MACHINE, THIS IS TWO WORDS.
      IF(L3264W.EQ.2)THEN
C           FOR A 32-BIT MACHINE, IPACK(5) HOLDS THE DATE/TIME OF THE
C           RECORD.
         IDATE=IPACK(5)
      ELSE
C           FOR A 64-BIT MACHINE, THE LEFT HALF OF IPACK(3) HOLDS 
C           THE DATE/TIME OF THE RECORD.
         LOC=3
         IPOS=1
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IDATE,32,L3264B,IER,*900)
      ENDIF
C
      NWORDS=NBYTES(L3264W)*8/L3264B
C
      IF(NWORDS.GT.ND5)THEN
         WRITE(KFILDO,2000)NWORDS,ND5,NAMIN(IN)
 2000    FORMAT(/,' ****THE NUMBER OF WORDS IN THE SOURCE FILE',
     1            ' IN RDSTRX =',I7,' EXCEEDS THE',/,
     2            '     NUMBER AVAILABLE ND5 =',I7,' AT 2000.',
     2            ' FOR SOURCE FILE ',A60,/,
     3            '     STOP THE PRESSES!')
         IER=38
         ISTOP=ISTOP+1
         GO TO 235
      ENDIF
C
      GO TO 205
C
 201  WRITE(KFILDO,202)KFILIN(IN),NDATE,IOS,NAMIN(IN)
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1          WRITE(IP23,202)KFILIN(IN),NDATE,IOS,NAMIN(IN)
 202  FORMAT(/,' ****ERROR READING PACKED RECORD ON UNIT NO.',I3,
     1         ' PROCESSING DATE',I11,' IN RDSTRX AT 202.  IOSTAT ='
     2        ,I5,/,'  ON FILE = ',A60)
      ISTOP=ISTOP+1
      LSTOPC=LSTOPC+1
      IF(LSTOPC.LT.LSTOP)GO TO 200
C        THIS CHECK IS TO STOP AN INFINITE LOOP THAT MIGHT OCCUR.
      WRITE(KFILDO,203)LSTOP,NDATE
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)WRITE(IP23,203)LSTOP,NDATE
 203  FORMAT('     A TOTAL OF',I5,' READING ERRORS HAVE OCCURRED.',
     1       '  RETURN FROM RDSTRX AT 203 WHILE PROCESSING DATE',
     2        I11)
      IER=138
      GO TO 235
C
 205  IF(IDATE.EQ.9999)GO TO 150
C        IF THE ABOVE TEST IS MET, THIS IS A TRAILER RECORD, AND A
C        CALL LETTERS RECORD OR AN EOF SHOULD FOLLOW.
      IF(IDATE.LT.NDATE)THEN
         GO TO 200
C           THE ABOVE SPACES UP TO THE (FIRST) DAY WANTED.
      ELSEIF(IDATE.GT.LDATE)THEN
C
C           THE SECTION BELOW IS NECESSARY IN CASE THE
C           VARIABLE WITH AN ITAU( ) GT 0 DOES NOT EXIST
C           (WITH THE SAME PROJECTION) ON THE FILE READ
C           UP TO THIS POINT.  SINCE THERE IS NO INPUT
C           REQUIRED AS TO WHICH FILE A PARTICULAR VARIABLE
C           IS ON, UNLESS THE FILE(S) WITH VARIABLES WITH
C           ITAU( ) GT 0 ARE SPECIFIED (AND READ) FIRST, DATA
C           FROM SOME FILES MAY BE SAVED FOR DAY 1 THAT WOULDN'T
C           HAVE TO BE.
C
         MITAU=0
C
         DO 210 J=1,NVRBL
         IF(IFIND(J).EQ.1)GO TO 210
         IF(ITAU(J).GT.MITAU)MITAU=ITAU(J)
 210     CONTINUE
C
         IF(MITAU.LE.MAXTAU)THEN         
            BACKSPACE KFILIN(IN)
C              THE READ ABOVE HAS GONE BEYOND THE DATE WANTED BY
C              1 RECORD; THEREFORE, THE BACKSPACE.  NOTE THAT
C              LDATE RATHER THAN NDATE IS USED.
            GO TO 2245
         ELSE
            CALL UPDAT(NDATE,MITAU,LDATE)
D           WRITE(KFILDO,211)MAXTAU,MITAU,IDATE,LDATE,
D    1           ((ID(J,L),J=1,4),ITAU(L),IFIND(L),L=1,NVRBL)
D211        FORMAT(' RDSTRX AT 211--MAXTAU,MITAU,IDATE,LDATE,ID,',
D    1             'ITAU,IFIND',4I11,/,('       ',4I11,2I4))
C
            IF(IDATE.GT.LDATE)THEN
               BACKSPACE KFILIN(IN)
               GO TO 2245
            ENDIF
C
         ENDIF
C
      ENDIF
C
C        THIS IS A DATE/TIME TO SAVE FOR MODEL NAMIN(IN) FOR DAY 1.
C        IT MUST BE SAVED SO THAT IT CAN BE RETAINED IN A RANDOM 
C        ACCESS MANNER.  THE TDL MOS-2000 STORAGE SYSTEM IS
C        USED FOR THIS PURPOSE.  UNPACK DATA AS WELL AS ID'S.
C
      CALL UNPACK(KFILDO,IPACK,IWORK,DATA,ND5,IS0,IS1,IS2,IS4,ND7,
     1            MISSP,MISSS,2,L3264B,IER)
C
C***D     WRITE(KFILDO,210)(IS0(K),K=1,3)
C***D210  FORMAT(/' IS0',1X,A4,2I10)
C***D     WRITE(KFILDO,211)(IS1(K),K=1,22+IS1(22))
C***D211  FORMAT(/' IS1',10I11/'    ',10I11/'    '2I11,4X32R1)
C***D     WRITE(KFILDO,212)(IS2(K),K=1,12)
C***D212  FORMAT(/' IS2',10I11/('    ',10I11))
C***D     WRITE(KFILDO,213)(IS4(K),K=1,4)
C***D213  FORMAT(/' IS4',10I11/('    ',10I11))
C
      IF(IER.NE.0)THEN
C           IER NE 0 INDICATES PROBLEM WITH UNPACKING RECORD.
C           IT IS NOT TREATED AS FATAL, BUT THIS RECORD IS 
C           SKIPPED.  A DIAGNOSTIC WILL HAVE BEEN PRINTED IN
C           UNPACK.
         ISTOP=ISTOP+1
         GO TO 200
C
      ELSE
         ISTA=IS4(3)
         IF(ISTA.GT.ND5)THEN
            WRITE(KFILDO,215)ND5,ISTA,KFILIN(IN),NDATE,NAMIN(IN)
 215        FORMAT(/,' ****ND5 =',I6,' TOO SMALL FOR DATA ARRAY',
     1               ' IN RDSTRX AT 215.  INCREASE TO GE',I6,/,
     2               '     READING ON UNIT NO.',I3,
     3               ' PROCESSING DATE',I11,' ON FILE = ',A60)
            IER=38
C              SET XDATA( ) TO MISSING.  DATA( ) WILL NOT HAVE
C              BEEN OVERFLOWED, BUT WILL CONTAIN THE MISSING
C              INDICATOR.  THESE DATA WILL BE STORED BY GSTORE.
C
            DO 216 K=1,NSTA
            XDATA(K)=9999.
 216        CONTINUE
C
         ELSE
C
C              PUT DATA INTO XDATA( ).  NOTE THAT EXCEPT FOR THE
C              INITIAL RETRIEVAL INTO DATA( ), ONLY THE NSTA WORDS
C              OF DATA ARE DEALT WITH.
C   
            DO 217 K=1,NSTA
C
            IF(INDEXC(K,IN).EQ.99999999)THEN
               XDATA(K)=9999.
            ELSE
               XDATA(K)=DATA(INDEXC(K,IN))
               IF(XDATA(K).EQ.9997.)XDATA(K)=PXMISS
C                 THE ABOVE STATEMENT ALLOWS THE MISSING VALUE
C                 9997 TO BE TREATED AS SOME OTHER VALUE.  THIS
C                 WOULD USUALLY BE 0, BUT COULD BE, SAY, 9999.
            ENDIF
C
 217        CONTINUE
C
         ENDIF
C
      ENDIF  
C
      CALL GSTORE(KFILDO,KFIL10,IS1(9),IN,LSTORE,ND9,LITEMS,
     1            XDATA,NSTA,1,0,IDATE,
     2            CORE,ND10,LASTL,NBLOCK,LASTD,NSTORE,L3264B,IER)
C        IS1(9) IS THE FIRST OF 4 ID WORDS.  NOTE THAT THE VALUE OF
C        "IN" IS PROVIDED TO BE STORED IN LSTORE(10, ) TO INDICATE
C        FOR FUTURE ROUTINES THE SOURCE OF THE DATA.  HOWEVER,
C        THIS MAY BE OF LITTLE OR NO USE, AND WILL BE UPDATED
C        IN LSTORE(10, ) IF FILE IN IS CLOSED AND IN+1 OPENED.
C        NOTE THAT THE DATE STORED IS IDATE.
C
      IF(IER.NE.0)THEN
C           IER NE 0 IS TREATED AS FATAL IN RDSTRX WITH RETURN TO
C           CALLING PROGRAM.
         ISTOP=ISTOP+1
         GO TO 235
      ENDIF
C
C        AT THIS POINT, THE VARIABLE READ HAS BEEN STORED AND
C        ITS IDS ARE IN IS1(9-12).  NOW RECORD THAT THE
C        VARIABLE HAS BEEN FOUND IF IT IS IN THE LIST 
C        EITHER AS A RAW VARIABLE OR A BINARY.  THE ATTEMPT
C        HERE IS TO KEEP DATA FOR ALL DATA SETS FROM BEING
C        STORED FOR LOOKAHEAD IF NOT NECESSARY.  TO BE
C        EFFECTIVE, THE DATA NEEDED FOR LOOKAHEAD SHOULD BE
C        ON THE FIRST DATASET.  HOWEVER, THIS IS NOT NECESSARY
C        FOR THE PROGRAM TO RUN.
C
      DO 218 J=1,NVRBL
      IF(ITAU(J).EQ.0)GO TO 218
C        WHEN ITAU(J) GT 0, LOOKAHEAD IS NEEDED FOR
C        VARIABLE J.
C
D     WRITE(KFILDO,2170)IN,J,NVRBL,ITAU(J),MAXTAU,
D    1      MITAU,NREP,LDATE,
D    2      IS1(9),IS1(10),IS1(11),IS1(12),IDATE
D2170 FORMAT(' RDSTRX--IN,J,NVRBL,ITAU(J),MAXTAU,MITAU,NREP',
D    1       ' LDATE',7I3,I11,I10,3I9,I11)
      IF(IFIND(J).EQ.1)GO TO 218
C
C***      WRITE(KFILDO,2171)(ID(K,J),K=1,4),(IS1(K),K=9,12),IDPARS(3,J)
C*** 2171 FORMAT(' ID,IS1',4I11.9,5X,4I11.9,I10) 
C
      IF(IS1( 9).EQ.ID(1,J).AND.
     1   IS1(10).EQ.ID(2,J).AND.
     2   IS1(11).EQ.ID(3,J).AND.
     3   IS1(12).EQ.ID(4,J))THEN
         MAXTAU=MAX(MAXTAU,ITAU(J))
         CALL UPDAT(NDATE,ITAU(J),KDATE)
         IF(KDATE.EQ.IDATE)IFIND(J)=1
D        WRITE(KFILDO,2174)MAXTAU
D2174    FORMAT(' MATCH FOUND AT 2174, MAXTAU =',I4)
         GO TO 218
      ENDIF
C
      IF(IDPARS(3,J).EQ.0)GO TO 218
      IF(IS1( 9).EQ.ID(1,J)-IDPARS(3,J)*100.AND.
     1   IS1(10).EQ.ID(2,J).AND.
     2   IS1(11).EQ.ID(3,J).AND.
     3   IS1(12).EQ.(ID(4,J)-(ID(4,J)/1000)*1000))THEN
         MAXTAU=MAX(MAXTAU,ITAU(J))
         CALL UPDAT(NDATE,ITAU(J),KDATE)
         IF(KDATE.EQ.IDATE)IFIND(J)=1
D        WRITE(KFILDO,2175)MAXTAU
D2175    FORMAT(' MATCH FOUND AT 2175, MAXTAU =',I4)
      ENDIF
C
C        THIS IS A VARIABLE TO BE USED FOR LOOKAHEAD. 
C        NORMALLY, THE PREDICTAND DATA WILL
C        BE ON A FILE SEPARATE FROM THE PREDICTORS, SO
C        A LARGE AMOUNT OF DATA WILL PROBABLY NOT BE 
C        SAVED.  ON THE OTHER HAND, SPACING FORWARD ON HOURLY
C        DATA FILES MAY REQUIRE A LOT OF DATA TO BE SAVED.
C        AT THE END OF THE LOOP FOR "IN", MAXTAU IS THE
C        MAXIMUM NUMBER OF HOURS TO "LOOK AHEAD" FOR
C        THIS DATA SET.  THIS IS NOT CARRIED OUTSIDE OF
C        RDSTRX.
 218  CONTINUE
C
C***      WRITE(KFILDO,2173)IN,MAXTAU,IS1(9),IS1(10),IS1(11),
C***     1                  IS1(12),(IFIND(J),J=1,NVRBL)
C*** 2173 FORMAT(' IN,MAXTAU,IS1(9-12),IFIND',2I4,4I11.9,/,
C***     1       (' ',50I2))
      IF(MITAU.GE.MAXTAU)GO TO 200
      CALL UPDAT(NDATE,MAXTAU,LDATE)
C        LDATE IS NOW THE LOCAL VALUE FOR NDATE FOR WHICH
C        DATA ARE NEEDED.  DATA WILL BE SAVED 
C        FROM THIS DATA SET FOR ALL VARIABLES UP TO AND
C        INCLUDING LDATE.
      GO TO 200
C
 219  IF(IP23.NE.0)WRITE(IP23,2190)KFILIN(IN),NDATE,NAMIN(IN)
 2190 FORMAT(/,' END OF  FILE ON UNIT NO.',I3,
     1         ' PROCESSING DATE',I11,'    FILE = ',A60)
 2191 CLOSE(KFILIN(IN),IOSTAT=IOS,ERR=2195)
      IF(IP23.NE.0)WRITE(IP23,2192)KFILIN(IN),NDATE,NAMIN(IN)
 2192 FORMAT(' CLOSING FILE ON UNIT NO.',I3,
     1       ' PROCESSING DATE',I11,'    FILE = ',A60)
      JFOPEN(IN)=0
      GO TO 220
C
 2195 WRITE(KFILDO,2196)KFILIN(IN),NDATE,IOS,NAMIN(IN)
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1             WRITE(IP23,2196)KFILIN(IN),NDATE,IOS,NAMIN(IN)
 2196 FORMAT(/,' ****ERROR CLOSING FILE NO.',I3,
     1         ' PROCESSING DATE',I11,
     2         ' IN RDSTRX AT 2196, IOSTAT =',I5,/,
     3         '  ON FILE = ',A60)
      ISTOP=ISTOP+1
      JFOPEN(IN)=0
C
 220  IF(IN.EQ.NUMIN)THEN
         WRITE(KFILDO,2200)KFILIN(IN),NDATE,NAMIN(IN)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1         WRITE(IP23,2200)KFILIN(IN),NDATE,NAMIN(IN)
 2200    FORMAT(' END OF  DATA ON UNIT NO.',I3,
     1          ' PROCESSING DATE',I11,'    FILE = ',A60)
         JFOPEN(IN)=0
         GO TO 2245
C
      ENDIF
C
      IF(KFILIN(IN).NE.KFILIN(IN+1))THEN
         WRITE(KFILDO,2200)KFILIN(IN),NDATE,NAMIN(IN)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1        WRITE(IP23,2200)KFILIN(IN),NDATE,NAMIN(IN)
         GO TO 2245
C
      ENDIF
C
      IF(JFOPEN(IN+1).EQ.2)THEN
C           JFOPEN(IN+1) SHOULD BE 2 WHEN
C           KFILIN(IN) = KFILIN(IN+1)
         JFOPEN(IN+1)=1
CINTEL
         CALL CKFILEND(KFILDO,KFILIN(IN+1),NAMIN(IN+1),ISYSEND,
     1                 IFILEND,CONVERTX,IER)
         OPEN(UNIT=KFILIN(IN+1),
     1        FORM='UNFORMATTED',STATUS='OLD',
     2        CONVERT=CONVERTX,IOSTAT=IOS,ERR=222)
C         OPEN(UNIT=KFILIN(IN+1),
C     1        FORM='UNFORMATTED',STATUS='OLD',
C     2        IOSTAT=IOS,ERR=222)
CINTEL
         IF(IP23.NE.0)WRITE(IP23,221)KFILIN(IN+1),NDATE,NAMIN(IN+1)
 221     FORMAT(' OPENING FILE ON UNIT NO.',I3,
     1          ' PROCESSING DATE',I11,'    FILE = ',A60)
C           ALLOW LOOP TO END.  IN WILL THEN BE INCREMENTED.
C           MAXTAU MUST NOT BE RESET, SO NREP SET = 1.
         NREP=1
C
C           IT IS NECESSARY THAT LSTORE(10, ) REFLECT THE
C           NUMBER OF THE FILE THAT IS OPEN.
C
         DO 2215 J=1,LITEMS
         IF(LSTORE(10,J).EQ.IN)LSTORE(10,J)=IN+1
 2215    CONTINUE
C
         GO TO 2246
C
 222     WRITE(KFILDO,223)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1          WRITE(IP23,223)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
 223     FORMAT(/,' ****ERROR OPENING FILE ON UNIT NO.',I3,
     1            ' PROCESSING DATE',I11,
     2            ' IN RDSTRX AT 223, IOSTAT =',I5,/,
     3            '  ON FILE = ',A60)
         IER=31
         ISTOP=ISTOP+1
      ELSE
         WRITE(KFILDO,224)KFILIN(IN+1),NDATE,NAMIN(IN+1)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1           WRITE(IP23,224)KFILIN(IN+1),NDATE,NAMIN(IN+1)
 224     FORMAT(/,' ****TROUBLE IN SWITCHING TO FILE ON UNIT NO.',
     1            I3,' PROCESSING DATE',I11,' IN RDSTRX AT 224.',/,
     2            '  ON FILE = ',A60)
         ISTOP=ISTOP+1
         IER=31
      ENDIF
C
 2245 NREP=0
 2246 MDATE(IN)=LDATE
 225  CONTINUE
C
      IF(LITEMS.EQ.0)THEN
         WRITE(KFILDO,228)
 228     FORMAT(/,' ****NO DATA FOUND FOR DAY 1.')
         IF(IP10.NE.0.AND.IP10.NE.KFILDO)WRITE(IP10,228)
         IER=56
         ISTOP=ISTOP+1
         GO TO 235
C
      ELSE
         IF(IP10.NE.0)
     1      WRITE(IP10,229)LITEMS,((LSTORE(J,K),J=1,12),K=1,LITEMS)
 229     FORMAT(/,' ',I6,' FIELDS READ AND STORED FOR DAY 1',/,
     1          (' ',I10.9,2I10,I11,3I8,I12,3I8,I12))
         IER=0
C           ABOVE STATEMENT IN CASE IER = 146 FROM RDDIR.
      ENDIF
C
D     CALL TIMPR(KFILDO,KFILDO,'END RDSTRX          ')
C
 235  RETURN
C 
 900  WRITE(KFILDO,901)IER
 901  FORMAT(/,' ****ERROR IN UNPKBG IN RDSTRX.  IER =',I4)
      ISTOP=ISTOP+1
      RETURN
      END
