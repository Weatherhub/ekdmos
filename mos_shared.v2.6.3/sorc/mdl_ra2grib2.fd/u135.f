      SUBROUTINE U135(KFILDI,KFILDO,IWORK,FLD,
     1                BMAPDATA,BMAP,IS0,IS1,IS2,IS4,
     2                ND4,ND5,ND7,ND8,ND10,ND11,ND12,
     3                LCGRIB,ISCT2LEN,IGDSTMPLEN,IPDSTMPLEN,
     4                IDRSTMPLEN,IDEFNUM,NUMCOORD,
     5                L3264B)
C
C$$$   SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: U135
C   PRGMMR: RUDACK         ORG: W/OST22          DATE: 2004-11-11
C
C ABSTRACT: PROGRAM U135 IS DESIGNED TO CONVERT TDLPACK GRIDDED DATA
C   INTO GRIB2.  THREE DIFFERENT TYPES OF MAP PROJECTIONS ARE 
C   SUPPORTED BY U135. (1) NORTH POLAR STEROGRAPHIC (2) 
C   LAMBERT CONFORMAL (3) MERCATOR.  THESE MAP PROJECTIONS 
C   ARE SUPPORTED AS EITHER INPUT OR OUTPUT.  THE GRIB2 MESSAGE 
C   IS WRITTEN TO FILE KFILGO.  THIS PROGRAM SUPPORTS THE FEATURE
C   IN GRIB2 THAT ALLOWS FOR THE REPETITION OF SECTIONS 2-7 
C   WITHIN ONE GRIB2 MESSAGE.   IN ADDITION, THE USER MAY SUPPLY
C   AN EXTERNAL GRIDDED RANDOM ACCESS FILE THAT CONTAINS BITMAP
C   INFORMATION TO MASK THE DATA FIELD PRIOR TO PACKING THE 
C   DATA INTO GRIB2.  THIS BITMAP MAY ALSO BE PACKED INTO THE 
C   GRIB2 MESSAGE.  THIS PROGRAM SHOULD RUN ON EITHER 32 OR 64 
C   BIT MACHINE.
C      PARAMETER (L3264B=32) FOR THE 32-BIT MACHINE AND
C      PARAMETER (L3264B=64) FOR THE 64-BIT MACHINE. 
C
C PROGRAM HISTORY LOG:
C   04-11-11  RUDACK
C   05-03-16  MALONEY    ADDED NCEP DOCBLOCK.  CHANGED CODE SO THAT
C                        DATE IS READ FROM THE NCEP DATE FILE WITH
C                        A CALL TO GET_NCEPDATE.  ADDED CALLS TO
C                        W3TAGE.
C   13-11-15  HUNTEMANN  ADDED LOCAL USE/SECTION 2.
C
C USAGE:  CALLED BY DRU135
C
C        DATA SET USE:
C        INPUT FILES:
C          FORT.KFILDI - UNIT NUMBER OF INPUT FILE.  (INPUT)
C           FORT.KFILP - UNIT NUMBER OF FILE CONTAINING THE MOS-2000
C                        BITMAP VARIABLE ID.  (INPUT)
C          FORT.KFILBM - UNIT NUMBER OF GRIDDED EXTERNAL RANDOM ACCESS
C                        FILE CONTAINIG BITMAP INFORMATION.  (INPUT)
C          FORT.KFILRA - UNIT NUMBER OF GRIDDED EXTERNAL RANDOM ACCESS
C                        FILE. (INPUT)
C          FORT.KFILCP - UNIT NUMBER FOR THE VARIABLE CONSTANTS DIRECTORY
C                        (INPUT)
C         FORT.KFILSC1 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE INDICATOR AND IDENTIFICATION 
C                        GRIB2 SECTIONS (SECTIONS 0 AND 1). (INPUT)
C         FORT.KFILSC2 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 LOCAL USE SECTION
C                        (SECTION 2).  (INPUT)
C         FORT.KFILSC3 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 GRID DEFINITION 
C                        SECTION (SECTION 3). (INPUT)
C         FORT.KFILSC4 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 PRODUCT DEFINITION 
C                        SECTION (SECTION 4). (INPUT)
C         FORT.KFILSC5 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 DATA REPRESENTATION
C                        SECTION (SECTION 5). (INPUT)
C          FORT.KFILDT - UNIT NUMBER WHERE THE DATE LIST IS LOCATED.
C                        (INPUT)
C        OUTPUT FILES:
C          FORT.KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C           FORT.IP(J) - UNIT NUMBERS FOR OPTIONAL OUTPUT (SEE IP( )
C                        UNDER "VARIABLES" BELOW.)  (J=1,25)  (OUTPUT)
C          FORT.KFILGO - UNIT NUMBER OF GRIB2 OUTPUT FILE.  (OUTPUT)
C
C        VARIABLES
C              KFILDI = UNIT NUMBER TO READ INPUT FILE 'U135.CN'.
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  INITIALLY,
C                       THIS IS SET BY DATA STATEMENT.  LATER, IN 
C                       IPOPEN, IF IP(1) NE 0, KFILDO IS SET = IP(1).
C                       THIS ALLOWS CHANGING THE "DEFAULT" PRINT FILE ON 
C                       THE FLY.  OTHERWISE, ON SOME SYSTEMS, THE OUTPUT
C                       FILE MIGHT HAVE THE SAME NAME AND BE OVERWRITTEN.
C                       WHEN THE OUTPUT FILE IS NOT THE ORIGINAL DEFAULT,
C                       THE NAME IS GENERATED AND CAN BE DIFFERENT FOR
C                       EACH RUN.
C            IWORK(J) = WORK ARRAY (J=1,ND5). 
C              FLD(J) = CONTAINS THE GRIDPOINT DATA FIELD BEING PROCESSED
C                       (J=1,ND5). 
C         BMAPDATA(J) = ARRAY CONTAINING THE BITMAP VALUES READ FROM THE
C                       BITMAP FILE KFILBM (J=1,ND5). 
C             BMAP(J) = LOGICAL*1 ARRAY CONTAINING BITMAP TO BE ADDED (J=1,ND5).
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,4).
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,21+).
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).
C                 ND4 = MAXIMUM NUMBER OF CONSTANT VARIABLES IN THE BITMAP
C                       VARIABLE LIST.  (MAXIMUM ALLOWED IS ONE)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), DATA( ) AND FLD( ).
C                       NOTE THAT ND5 MUST BE GE NX*NY.
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       SHOULD BE GE 54.
C                 ND8 = MAXIMUM NUMBER OF DATES THAT CAN BE DEALT WITH.
C                ND10 = MAXIMUM NUMBER OF FIELDS ALLOWED IN ANY ONE MESSAGE.
C                ND11 = MAXIMUM NUMBER OF OUTPUT GRID ENTRIES DEFINED IN 
C                       THE GRID DEFINITION FILE CORRESPONDING TO SECTION 3.
C                ND12 = MAXIMUM NUMBER OF GROUPS (OR MESSAGES) THAT CAN
C                       BE PROCESSED IN ONE RUN OF U135.
C              LCGRIB = MAXIMUM LENGTH (BYTES) OF GRIB2 MESSAGE (STORED IN 
C                       CHARACTER ARRAY CGRIB( ).)
C            ISCT2LEN = MAXIMUM DIMENSION OF FSCT2( ).  LOCAL USE
C                       SECTION OF THE GRIB2 MESSAGE (SECTION 2).
C          IGDSTMPLEN = MAXIMUM DIMENSION OF IGDSTMPL( ).  GRID DEFINITION
C                       SECTION OF THE GRIB2 MESSAGE (SECTION 3).
C          IPDSTMPLEN = MAXIMUM DIMENSION OF IPDSTMPL( ).  PRODUCT 
C                       DEFINITION SECTION OF THE GRIB2 MESSAGE (SECTION 4).
C          IDRSTMPLEN = MAXIMUM DIMENSION OF IDRSTMPL( ).  DATA REPRESENTATION
C                       SECTION OF THE GRIB2 MESSAGE (SECTION 5).
C             IDEFNUM = (USED IF IGDS(3).NE.0) THE NUMBER OF ENTRIES IN ARRAY
C                       IDEFLIST( ).  I.E., THE NUMBER OF ROWS (COLUMNS) FOR 
C                       WHICH OPTIONAL GRIDPOINTS ARE DEFINED.  SET IN 
C                       PARAMETER STATEMENT IN DRU135.
C            NUMCOORD = NUMBER OF VALUES IN ARRAY COORDLIST( ).  SET IN
C                       PARAMETER STATEMENT IN DRU135.
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  SET BY PARAMETER.
C
C****END OF VARIABLE LIST PASSED FROM DRU135
C
C            MDATE(J) = INITIAL DATE LIST (J=1,NDATES) WHICH MAY CONTAIN
C                       NEGATIVE VALUES INDICATING A DATE SPAN.
C                       THIS IS MODIFIED IN DATPRO TO CONTAIN THE
C                       COMPLETE DATE LIST WITH THE DATES IN THE SPANS
C                       FILLED IN (J=1,NDATES), WHERE NDATES HAS BEEN
C                       INCREASED IF NECESSARY.  DATES ARE INPUT AS
C                       YYMMDDHH AND MODIFIED TO YYYYMMDDHH.  ZEROS IN 
C                       THE INPUT ARE ELIMINATED.  TERMINATOR IS 
C                       99999999.  MAXIMUM NUMBER OF DATES IS ND8.
C              KFILRA = THE UNIT NUMBER OF THE EXTERNAL TDLPACK GRIDDED
C                       RANDOM ACCESS FILE.
C              RACESS = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER 
C                       KFILRA.  (CHARACTER*60)
C              OUTGRD = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER 
C                       KFILGO.  (CHARACTER*60)
C             KFILSC1 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE INDICATOR AND IDENTIFICATION
C                       GRIB2 SECTIONS (SECTIONS 0 AND 1). 
C              IDFNAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILSC1. (CHARACTER*60)
C             KFILSC2 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 LOCAL USE SECTION
C                       (SECTION 2).  
C              LCLNAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILSC2. (CHARACTER*60)
C             KFILSC3 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 GRID DEFINITION
C                       SECTION (SECTION 3). 
C              GDSNAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILSC3. (CHARACTER*60)
C             KFILSC4 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 PRODUCT DEFINITION
C                       SECTION (SECTION 4). (INPUT)
C              PDSNAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILSC4. (CHARACTER*60)
C             KFILSC5 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 DATA REPRESENTATION
C                       SECTION (SECTION 5). (INPUT)
C             DATANAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILSC5. (CHARACTER*60)
C              KFILBM = UNIT NUMBER OF GRIDDED EXTERNAL RANDOM ACCESS
C                       FILE CONTAINIG BITMAP INFORMATION.  
C              BMPNAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILBM.  (CHARACTER*60)
C               KFILP = UNIT NUMBER OF FILE CONTAINING THE MOS-2000
C                       BITMAP VARIABLE ID.  
C              PRENAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILP.  (CHARACTER*60)
C              KFILCP = UNIT NUMBER FOR THE VARIABLE CONSTANTS DIRECTORY.
C              CONNAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILCP.  (CHARACTER*60)
C              KFILDT = THE UNIT NUMBER FOR WHERE THE DATE LIST IS
C                       LOCATED.
C              DATNAM = HOLDS DATA SET NAME FOR THE UNIT NUMBER IN
C                       KFILDT.  (CHARACTER*60) 
C               IP(J) = EACH VALUE (J=1,25) INDICATES WHETHER (>1)
C                       OR NOT (=0) CERTAIN INFORMATION WILL BE WRITTEN.
C                       WHEN IP( ) > 0, THE VALUE INDICATES THE UNIT
C                       NUMBER FOR OUTPUT.  THESE VALUES SHOULD NOT BE
C                       THE SAME AS ANY KFILX VALUES EXCEPT POSSIBLY
C                       KFILDO, WHICH IS THE DEFAULT OUTPUT FILE.  THIS 
C                       IS ASCII OUTPUT, GENERALLY FOR DIAGNOSTIC 
C                       PURPOSES.  THE FILE NAMES WILL BE 4 CHARACTERS
C                       'U135', THEN 4 CHARACTERS FROM IPINIT, THEN 
C                       2 CHARACTERS FROM IP(J) (E.G., 'U135DER130').
C                       THE ARRAY IS INITIALIZED TO ZERO IN CASE LESS
C                       THAN THE EXPECTED NUMBER OF VALUES ARE READ IN.
C                       (1) = ALL ERRORS AND OTHER INFORMATION NOT
C                             SPECIFICALLY IDENTIFIED WITH OTHER IP( )
C                             NUMBERS.  WHEN IP(1) IS READ AS NONZERO,
C                             KFILDO, THE DEFAULT OUTPUT FILE UNIT NUMBER,
C                             WILL BE SET TO IP(1).  WHEN IP(1) IS READ
C                             AS ZERO, KFILDO WILL BE USED UNCHANGED.
C                       (2) = THE INPUT DATES IN MDATE( ).  WHEN THERE
C                             ARE ERRORS, PRINT WILL BE TO UNIT KFILDO AS
C                             WELL AS TO UNIT IP(2).
C                       (3) = THE OUTPUT DATES IN MDATE( ).  WHEN THERE
C                             ARE ERRORS, OUTPUT WILL BE TO UNIT KFILDO AS
C                             WELL AS TO UNIT IP(3).
C                       (6) = THE BITMAP VARIABLES AS THEY ARE BEING
C                             READ IN.  THIS IS GOOD FOR CHECKOUT;
C                             FOR ROUTINE OPERATION, IP(7), IP(8), AND/OR
C                             IP(9), MAY BE BETTER.
C                       (7) = THE BITMAP VARIABLE LIST IN SUMMARY FORM.
C                             IF THERE ARE ERRORS, THE BITMAP VARIABLE LIST
C                             WILL BE WRITTEN TO THE DEFAULT OUTPUT FILE
C                             UNIT KFILDO AS WELL AS TO UNIT IP(7).
C                             THIS LIST INCLUDES THE PARSED ID'S IN IDPARS( , ).
C                       (8) = THE BITMAP VARIABLE LIST IN SUMMARY FORM AFTER
C                             AFTERV REORDERING.  THIS LIST INCLUDES THE PARSED
C                             ID'S IN IDPARS( , ).
C                       (9) = THE BITMAP VARIABLE LIST IN SUMMARY FORM AFTER
C                             REORDERING.  THIS DIFFERS FROM (8) IN THAT (9)
C                             DOES NOT INCLUDE THE PARSED ID'S IN IDPARS( , ),
C                             BUT RATHER INCLUDES THE INFORMATION TAKEN
C                             FROM THE CONSTANT FILE ON UNIT KFILCP.
C                      (12) = THE LIST OF VALUES PERTAINING TO SECTIONS 0 
C                             AND 1 IN THE GRIB2 MESSAGE.  THESE VALUES 
C                             ARE SET IN THE GRIB2 INDICATOR AND
C                             IDENTIFICATION INPUT FILE. 
C                      (13) = THE LIST OF VALUES PERTAINING TO SECTION 2 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN 
C                             THE LOCAL USE SECTION INPUT FILE.
C                      (14) = THE LIST OF VALUES PERTAINING TO SECTION 3 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN 
C                             THE GRID DEFINITION SECTION INPUT FILE.
C                      (15) = THE LIST OF VALUES PERTAINING TO SECTION 4 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN 
C                             THE PRODUCT DEFINITION SECTION INPUT FILE.
C                      (16) = THE LIST OF VALUES PERTAINING TO SECTION 5 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN 
C                             THE DATA REPRESENTATION SECTION INPUT FILE.
C                      (17) = THE RAW TDLPACK GRIDDED VALUES PRINTED TO THE
C                             NEAREST THOUSANDTHS PLACE.
C                      (18) = PRINT OF BITMAP GRIDDED VALUES.
C             ID(J,N) = THE INTEGER VARIABLE BITMAP ID (J=1,4) (N=1,ND4).
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE
C                       VARIABLE BITMAP ID CORRESPONDING TO ID( ,N)
C                       (J=1,15), (N=1,ND4).
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY
C                            1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK
C                            IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID'S (J=1,4)
C                       (N=1,ND4).
C                       THIS IS THE SAME AS ID(J,N), EXCEPT THAT THE
C                       PORTIONS PERTAINING TO PROCESSING ARE OMITTED:
C                       B = IDPARS(3, ),
C                       T = IDPARS(8,),
C                       I = IDPARS(13, ),
C                       S = IDPARS(14, ),
C                       G = IDPARS(15, ), AND
C                       THRESH( ).
C                       JD( , ) IS USED TO IDENTIFY THE BASIC MODEL
C                       FIELDS AS READ FROM THE ARCHIVE.
C             JP(J,N) = JP( ,N) INDICATES WHETHER (>0) OR NOT (=0)
C                       VARIABLE N WILL BE OUTPUT FOR VIEWING
C                       (N=1,ND4).
C                       J=1--GRIDPOINT VALUES,
C                       J=2--GRIDPRINT WITH CONTOURS, AND
C                       J=3--INTERPOLATED VALUES.
C                       (NOT USED)
C           JPLAIN(N) = THE PLAIN LANGUAGE DESCRIPTION OF THE BITMAP 
C                       VARIABLE (N=1,ND4).  (CHARACTER*32)
C           ISCALD(N) = THE DECIMAL SCALING FOR THE BITMAP VARIABLE
C                       RETRIEVED BY 'RDPRED'.  NO BINARY SCALING IS
C                       PROVIDED FOR.
C            SMULT(N) = THE MULTIPLICATIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (NOT USED)
C             SADD(N) = THE ADDITIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (NOT USED)
C           ORIGIN(N) = THE CONTOUR ORIGIN, APPLIES TO THE UNITS IN
C                       UNITS(N) (N=1,ND4).  (NOT USED)
C             CINT(N) = THE CONTOUR INTERVAL, APPLIES TO THE UNITS IN
C                       UNITS(N) (N=1,ND4).  (NOT USED)
C            UNITS(N) = THE UNITS OF THE DATA THAT APPLY AFTER
C                       MULTIPLYING BY SMULT(N) AND ADDING SADD(N)
C                       (N=1,ND4).  (CHARACTER*12)  (NOT USED)
C           THRESH(N) = THE BINARY THRESHOLD ASSOCIATED WITH
C                       IDPARS( ,N), N=1,ND4).  (NOT USED)
C             IUSE(J) = EACH VALUE J PERTAINS TO IP(J).  WHEN AN IP(J)
C                       VALUE IS USED BY THE PROGRAM, IPRINT(J) = 1;
C                       OTHERWISE, IPRINT(J) = 0.  USED BY IPRINT TO
C                       PRINT IP( ) VALUES.
C              KFILGO = UNIT NUMBER OF GRIB2 OUTPUT FILE.
C               RUNID = INFORMATION INPUT TO IDENTIFY THE OUTPUT.
C                       (CHARACTER*72)
C              INCCYL = INCREMENT IN HOURS BETWEEN DATE/TIMES THAT
C                       ARE PUT INTO MDATE( ) BY SUBROUTINE DATPRO.
C              NTOTBG = THE TOTAL NUMBER OF BYTES WRITTEN TO THE GRIB2 
C                       OUTPUT FILE. 
C              NTOTRG = THE TOTAL NUMBER OF FIELDS WRITTEN TO THE GRIB2 
C                       OUTPUT FILE.
C              NDATES = NUMBER OF VALUES IN MDATE( ).  MODIFIED AS 
C                       NECESSARY IN DATPRO.
C              IPINIT = 4 CHARACTERS, USUALLY A USER'S INITIALS PLUS
C                       A RUN NUMBER, TO APPEND TO 'U135' TO 
C                       IDENTIFY A PARTICULAR SEGMENT OF OUTPUT 
C                       INDICATED BY A SUFFIX IP(J).  THE RUN NUMBER
C                       ALLOWS MULTIPLE RUNS OF U135 AND WRITING OF
C                       UNIQUELY NAMED FILES, PROVIDED THE USER USES
C                       A DIFFERENT RUN NUMBER FOR EACH RUN.
C             IDUM(J) = SCRATCH ARRAY (J=1,2).
C                 IER = STATUS RETURN.
C                       0 = GOOD RETURN.  SEE CALLED ROUTINES FOR OTHER
C                       VALUES.
C                       OTHER VALUES RETURNED FROM SUBROUTINES.
C               STATE = VARIABLE SET TO STATEMENT NUMBER TO INDICATE
C                       WHERE AN ERROR OCCURRED.  (CHARACTER*4)
C            ITEMP(J) = WORK ARRAY (J=1,14).
C            ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER
C                       AN INPUT DATA RECORD IS NOT FOUND.
C              XMISSS = VALUE ASSIGNED TO A SECONDARY MISSING WHEN PACKED 
C                       INTO GRIB2.
C               JFLAG = FLAG (=1) INDICATES THAT AN EXTERNAL GRIDDED RANDOM
C                       ACCESS FILE IS BEING USED TO MASK THE DATA.
C               MPROJ = MAP PROJECTION IDENTIFIER SET AT THE TOP OF
C                       U135.CN.  (INPUT)
C               JBMAP = FLAG (=1) INDICATES THAT THE BITMAP SUPPLIED BY THE
C                       USER ON INPUT WILL BE PACKED INTO THE GRIB2 MESSAGE.   
C             BMAPVAL = VALUE ASSIGNED TO THE UNPACKED TDLPACK DATA THAT IS
C                       TO BE MASKED.
C 
C        SUBPROGRAMS CALLED:  IPOPEN, GET_NCEPDATE, IPRINT, RDSNAM,  
C            TIMPR, DATPRO, RDI, RDPRED, RDTDLPK, IERX, W3TAGE
C          UNIQUE: - RDTDLPK
C          LIBRARY:
C           MOSLIB - IPOPEN, GET_NCEPDATE, IPRINT, RDSNAM,  
C            TIMPR, DATPRO, RDI, RDPRED, IERX
C           W3LIB - W3TAGE
C
C        EXIT STATES:
C          COND =    0 - SUCCESSFUL RUN
C                  134 - ERROR READING NCEPDATE FILE
C                  144 - NO GRIB2 OUTPUT DATASET PROVIDED
C                  171 - INCONSISTENCY IN UNIT NUMBERS IN KFILDO
C                  210 - VARIABLE LIST ENTERED BUT NO BITMAP
C                        GRIDDED RANDOM ACCESS FILE
C                  220 - VARIABLE LIST NOT ENTERED BUT BITMAP
C                        GRIDDED RANDOM ACCESS FILE WAS SPECIFIED
C                  225 - BITMAP REQUESTED BUT NOT PROVIDED
C                  230 - MORE THAN ONE BITMAP ID SPECIFIED
C                 1282 - ERROR READING CONTROL RECORDS
C                 1420 - NO INPUT DATA SET SPECIFIED
C                 1452 - NO INDICATOR AND IDENTIFICATION DATASET
C                 1461 - NO GRID DEFINITION SECTION LIST
C                 1464 - NO PRODUCT DEFINITION LIST
C                 1467 - NO DATA REPRESENTATION LIST
C                 1901 - INCONSISTENCY IN UNIT NUMBERS IN KFILRA
C                 1910 - INCONSISTENCY IN UNIT NUMBERS IN KFILGO
C                 1920 - INCONSISTENCY IN UNIT NUMBERS IN KFILSC1
C                 1930 - INCONSISTENCY IN UNIT NUMBERS IN KFILSC2
C                 1940 - INCONSISTENCY IN UNIT NUMBERS IN KFILSC3
C                 1950 - INCONSISTENCY IN UNIT NUMBERS IN KFILSC4
C                 1960 - INCONSISTENCY IN UNIT NUMBERS IN KFILSC5
C                 1970 - INCONSISTENCY IN UNIT NUMBERS IN KFILBM 
C                 1980 - INCONSISTENCY IN UNIT NUMBERS IN KFILP
C                 1990 - INCONSISTENCY IN UNIT NUMBERS IN KFILCP
C                 9999 - ERROR WITH EITHER AN OPEN OR WRITE STATEMENT 
C
C REMARKS:  NONE 
C                                                                       
C ATTRIBUTES:                                                           
C   LANGUAGE:  FORTRAN 90 (xlf90 compiler) 
C   MACHINE:  IBM SP
C
C$$$               
C
      CHARACTER*4 STATE,IPINIT
      CHARACTER*6 MPROJ
      CHARACTER*12 UNITS(ND4)
      CHARACTER*32 JPLAIN(ND4)
      CHARACTER*60 OUTGRD,DATNAM,IDFNAM,LCLNAM,GDSNAM,
     1             PDSNAM,DATANAM,RACESS,BMPNAM,PRENAM,
     2             CONNAM
      CHARACTER*72 RUNID/' '/
C
      LOGICAL*1 BMAP(ND5)
C
      DIMENSION IWORK(ND5),FLD(ND5),BMAPDATA(ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION ITEMP(14),IP(25),IUSE(25),IDUM(2),ISTOP(2)
      DIMENSION ISCALD(ND4),SMULT(ND4),SADD(ND4),
     1          ORIGIN(ND4),CINT(ND4),THRESH(ND4)
      DIMENSION JP(3,ND4),ID(4,ND4),JD(4,ND4),IDPARS(15,ND4)
      DIMENSION MDATE(ND8)
C
      DATA ISTOP/0,0/
      DATA IP/25*0/
      DATA INCCYL/0/
      DATA KFILGO/0/,
     1     NTOTBG/0/,
     2     NTOTRG/0/
      DATA IUSE/1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0/
C
      JLCL=0
      JFLAG=0
      NPRED=0
C
C        READ AND PROCESS THE PRINT UNIT NUMBERS.  THE INPUT UNIT
C        KFILDI HAS BEEN OPENED IN THE DRIVER OR BY SOME OTHER
C        MECHANISM SUCH AS A SCRIPT. 
C     
C        NOTE THAT IF KFILDO NE IP(1) (READ BELOW), THE OUTPUT FROM
C        TIMPR (IN THE DRIVER) WILL BE ON UNIT KFILDO, BUT ALL OTHER 
C        "DEFAULT" PRINT ON UNIT IP(1), UNLESS THERE IS AN ERROR ON 
C        THE OPEN STATEMENT BELOW OR THE FOLLOWING READ.
C
      STATE='108 ' 
      READ(KFILDI,108,IOSTAT=IOS,ERR=900,END=109)IPINIT,(IP(J),J=1,25) 
 108  FORMAT(A4,25I3)
C        LESS THAN 25 IP( ) VALUES WILL NOT BE INDICATED AS AN ERROR.
C        SOME IP( ) VALUES ARE NOT USED; SEE IUSE( ).
      CALL IPOPEN(KFILDO,'U135',IPINIT,IP,IER)
C        WHEN IP(1) NE 0, KFILDO HAS BEEN SET TO IP(1).
C        A FILE WILL BE OPENED FOR EVERY DIFFERENT VALUE IN IP( ).
C        THE FILE NAMES WILL BE 4 CHARACTERS 'U135' THEN 4 CHARACTERS
C        FROM IPINIT, THEN 2 CHARACTERS FROM IP(J).  IPINIT MIGHT BE
C        'DER1' INDICATING THE PERSONS INITIALS PLUS A SEQUENCE NUMBER.
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
 109  WRITE(KFILDO,110)IPINIT
 110  FORMAT(/,' IPINIT = ',A4)
      CALL IPRINT(KFILDO,IP,IUSE)
C
C        TIME STAMP ALL ASCII OUTPUT OTHER THAN KFILDO.
C        THIS IS NOT DONE IN IPOPEN BECAUSE SOME PROGRAMS
C        MIGHT NOT WANT SOME FILE TO BE TIME STAMPED.
C
      DO 113 J=1,25
      IF(IP(J).EQ.0.OR.IP(J).EQ.KFILDO)GO TO 113
      IF(J.EQ.1)GO TO 112
C
      DO 111 I=1,J-1
      IF(IP(J).EQ.IP(I))GO TO 113
 111  CONTINUE
C
 112  CALL TIMPR(IP(J),IP(J),'START U135          ')
 113  CONTINUE
C
C        READ AND PRINT THE RUN IDENTIFICATION.
C
      STATE='115 '
      READ(KFILDI,115,IOSTAT=IOS,ERR=900,END=116)RUNID 
C        LESS THAN 72 CHARACTERS IS NOT CONSIDERED AN ERROR.
 115  FORMAT(A72)  
 116  WRITE(KFILDO,117)RUNID
 117  FORMAT(/,' ',A72)
C
C        PRINT TO MAKE SURE USER KNOWS WHAT MACHINE IS BEING USED.
C 
      WRITE(KFILDO,119)L3264B
 119  FORMAT(/,' RUNNING ON A',I3,'-BIT MACHINE.')
C
C        READ AND PRINT CONTROL INFORMATION.
C
      READ(KFILDI,120,IOSTAT=IOS,ERR=900,END=1281)
     1     INCCYL,MPROJ,XMISSS,JBMAP,BMAPVAL
 120  FORMAT(I10/,4X,A6/,F10.4/,I10/,F10.4)
      GOTO 1283
C
C        INCOMPLETE CONTROL INFORMATION SHOULD BE CONSIDERED AN ERROR.
C        HOWEVER, A SHORT RECORD DOES NOT CAUSE AN "END" CONDITION.
C
1281  WRITE(KFILDO,1282)
1282  FORMAT(/,' ****CONTROL INFORMATION NOT COMPLETE.',/,
     1        '     STOP IN U135 AT 1282.')
      CALL W3TAGE('U135')
      STOP 1282
C
 1283  WRITE(KFILDO,1284)INCCYL,MPROJ,XMISSS,JBMAP,
     1                   BMAPVAL,L3264B
 1284  FORMAT(/,' INCCYL',I10,'  INCREMENT IN HOURS BETWEEN DATE/',
     1           ' TIMES',/,
     2        ' MPROJ',5X,A6,'  OUTPUT GRID (MAP PROJECTION)',
     3        ' IDENTIFIER',/,
     4        ' XMISSS',F10.0,'  VALUE ASSIGNED TO A SECONDARY',
     5        ' MISSING',/,
     6        ' JBMAP',I10,'   PACK A BITMAP INTO GRIB2 MESSAGE',
     7        ' (1=YES, 0=NO)',/, 
     8        ' BMAPVAL',F9.0,'  MASKING VALUE ASSIGNED TO DATA',
     9        ' FIELD',/,
     A        ' L3264B',I10,'  INTEGER WORD SIZE OF MACHINE')
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR READING
C        DATE LIST.  FILE WILL BE OPENED AS 'OLD', UNLESS THE FILE
C        IS THE DEFAULT INPUT FILE.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILDT,DATNAM,IDUM,IDUM,1,
     1            N,'OLD','FORMATTED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,130)KFILDT
 130  FORMAT(/,' NCEP DATE FILE UNIT NUMBER..',/,' ',I4)
C
C        READ AND PRINT THE DATE TO BE PROCESSED
C
      CALL GET_NCEPDATE(KFILDT,IYR,IMO,IDA,IHR,JDATE,IER)
      IF(IER.NE.0)THEN
         WRITE(KFILDO,134)
 134     FORMAT(/' ****ERROR: CAN NOT READ NCEP DATE FILE - ',
     1           'CATASTROPHIC ERROR IN U135. STOP AT 134.')
         CALL W3TAGE('U135')
         STOP 134
      ENDIF
      NDATES = 1
C
C        ASSIGN THE DATE TO BE PROCESSED TO VARIABLE 'JDATE'.
C
      MDATE(1) = JDATE
      WRITE(KFILDO,135)NDATES,(MDATE(J),J=1,NDATES) 
 135  FORMAT(/,' ',I4,' INPUT DATE AS READ',/,(1X,10I12)) 
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR THE 
C        MOS-2000 INPUT EXTERNAL RANDOM ACCESS FILE.  ONLY ONE 
C        INPUT FILE IS ALLOWED.  THE FILE WILL BE OPENED IN 
C        'CONSTG' WHICH IS CALLED BY 'RDTDLPK'.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILRA,RACESS,IDUM,IDUM,1,
     1            NUMRA,'NOT','NOTOPENED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(NUMRA.NE.0)THEN
         WRITE(KFILDO,142)KFILRA,RACESS
 142     FORMAT(/,' MOS-2000 EXTERNAL RANDOM ACCESS DATA SET,',
     1          ' UNIT, AND NAME.',/(' ',I4,2X,A60))
      ELSE
         WRITE(KFILDO,1420) 
 1420    FORMAT(/,' ****A MOS-2000 EXTERNAL RANDOM ACCESS INPUT',
     1            ' DATA SET HAS NOT BEEN PLACED IN THE CONTROL',
     2            ' FILE.',/,5X,'U135 REQUIRES AN INPUT DATA SET.',
     3            '  CATASTROPHIC ERROR.  STOP 1420 IN U130.')
         CALL W3TAGE('U135')
         STOP 1420
      ENDIF
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR GRIDDED 
C        OUTPUT.  THE FILE WILL NOT BE OPENED.   IF A GRIB2 OUTPUT
C        FILE IS NOT SPECIFIED, U135 TERMINATES. 
C
      CALL RDSNAM(KFILDI,KFILDO,KFILGO,OUTGRD,IDUM,IDUM,1,
     1            IOUT,'NOTOPENED','UNFORMATTED',IP,IER)
C         IOUT IS THE NUMBER OF VALUES READ AND IS NOT USED.
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(KFILGO.NE.0)THEN
         WRITE(KFILDO,1435)KFILGO,OUTGRD
 1435    FORMAT(/' GRIB2 OUTPUT DATA SET, UNIT AND NAME.'/
     1         ('  ',I3,2X,A60))
      ELSE
         WRITE(KFILDO,144)
 144     FORMAT(/' ****NO GRIB2 OUTPUT DATA SET PROVIDED;',
     1           ' CATASTROPHIC ERROR.  STOP 144 IN U135.')
         CALL W3TAGE('U135')
         STOP 144
      ENDIF
C
C        OPEN THE UNIT NUMBER AND FILE NAME FOR INFORMATION
C        PERTAINING TO SECTION 0 AND SECTION 1. 
C
      CALL RDSNAM(KFILDI,KFILDO,KFILSC1,IDFNAM,IDUM,IDUM,1,
     1            IOUT,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,1451)KFILSC1,IDFNAM
 1451 FORMAT(/' GRIB2 INDICATOR AND IDENTIFICATION DATA SET,',
     1        ' UNIT AND NAME.',/,('  ',I3,2X,A60))
C
C        ENSURE THAT AN INDICATOR AND IDENTIFICATION HAS BEEN 
C        SUPPLIED BY THE USER.  IF A LIST IS NOT PRESENT, TERMINATE
C        THE PROGRAM.
C
      IF(KFILSC1.EQ.0) THEN
         WRITE(KFILDO,1452)
 1452    FORMAT(/,' ****U135 REQUIRES AN INDICATOR AND IDENTIFICATION',
     1            ' DATA SET FOR PROCESSING.  STOP 1452 IN U135.')
         CALL W3TAGE('U135')
         STOP 1452
      ENDIF
C
C        OPEN THE UNIT NUMBER AND FILE NAME FOR THE LOCAL USE 
C        SECTION 2.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILSC2,LCLNAM,IDUM,IDUM,1,
     1            IOUT,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(KFILSC2.EQ.0)THEN
         WRITE(KFILDO,1453)
 1453    FORMAT(/,' NO GRIB2 LOCAL USE SECTION 2 SET PROVIDED.')
      ELSE
         JLCL=1
         WRITE(KFILDO,1455)KFILSC2,LCLNAM
 1455    FORMAT(/' GRIB2 LOCAL USE SECTION DATA SET, UNIT AND NAME.'/
     1          ('  ',I3,2X,A60))
      ENDIF
C
C        OPEN THE UNIT NUMBER AND FILE NAME FOR THE GRID DEFINITION 
C        SECTION.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILSC3,GDSNAM,IDUM,IDUM,1,
     1            IOUT,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,1460)KFILSC3,GDSNAM
 1460 FORMAT(/' GRIB2 GRID DEFINITION SECTION DATA SET, UNIT AND NAME.'/
     1       ('  ',I3,2X,A60))
C
C        ENSURE THAT INFORMATION PERTAINING TO THE GRID DEFINITION 
C        SECTION HAS BEEN SUPPLIED BY THE USER.  IF A LIST IS NOT
C        PRESENT, TERMINATE THE PROGRAM.
C
      IF(KFILSC3.EQ.0) THEN
         WRITE(KFILDO,1461)
 1461    FORMAT(/,' ****U135 REQUIRES A GRID DEFINITION SECTION',
     1            ' LIST FOR PROCESSING.  STOP 1461 IN U135.')
         CALL W3TAGE('U135')
         STOP 1461
      ENDIF
C
C        OPEN THE UNIT NUMBER AND FILE NAME FOR THE PRODUCT 
C        DEFINITION SECTION.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILSC4,PDSNAM,IDUM,IDUM,1,
     1            IOUT,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,1463)KFILSC4,PDSNAM
 1463 FORMAT(/' GRIB2 PRODUCT DEFINITION DATA SET, UNIT AND NAME.'/
     1       ('  ',I3,2X,A60))
C
C        ENSURE THAT INFORMATION PERTAINING TO THE PRODUCT DEFINITION
C        SECTION HAS BEEN SUPPLIED BY THE USER.  IF A LIST IS NOT 
C        PRESENT, TERMINATE THE PROGRAM.
C
      IF(KFILSC4.EQ.0) THEN
         WRITE(KFILDO,1464)
 1464    FORMAT(/,' ****U135 REQUIRES A PRODUCT DEFINITION LIST FOR',
     1            ' PROCESSING.  STOP 1464 IN U135.')
         CALL W3TAGE('U135')
         STOP 1464
      ENDIF
C
C        OPEN THE UNIT NUMBER AND FILE NAME FOR THE DATA REPRESENTATION
C        SECTION.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILSC5,DATANAM,IDUM,IDUM,1,
     1            IOUT,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,1466)KFILSC5,DATANAM
 1466 FORMAT(/' GRIB2 DATA REPRESENTATION DATA SET, UNIT AND NAME.'/
     1       ('  ',I3,2X,A60))
C
C        ENSURE THAT INFORMATION PERTAINING TO THE DATA REPRESENTATION
C        SECTION HAS BEEN SUPPLIED BY THE USER.  IF A LIST IS NOT 
C        PRESENT, TERMINATE THE PROGRAM.
C
      IF(KFILSC5.EQ.0) THEN
         WRITE(KFILDO,1467)
 1467    FORMAT(/,' ****U135 REQUIRES A DATA REPRESENTATION LIST FOR',
     1            ' PROCESSING.  STOP 1467 IN U135.')
         CALL W3TAGE('U135')
         STOP 1467
      ENDIF
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR THE
C        MOS-2000 EXTERNAL RANDOM ACCESS FILE THAT CONTAINS
C        THE BITMAP INFORMATION.  THE FILE WILL BE OPENED 
C        AND READ IN "RDTDLPK" BY "CONSTG".
C
      CALL RDSNAM(KFILDI,KFILDO,KFILBM,BMPNAM,IDUM,IDUM,1,
     1            NUMRA,'NOT','NOTOPENED',IP,IER)
C        IDUM( ) IS USED AS A SCRATCH ARRAY.
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C 
      IF(NUMRA.NE.0)THEN
         WRITE(KFILDO,1468) KFILBM,BMPNAM
 1468    FORMAT(/' MOS-2000 EXTERNAL BITMAP GRIDDED RANDOM ACCESS',
     1           ' DATA SET, UNIT, AND NAME.',/,('  ',I3,2X,A60))
      ELSE
         WRITE(KFILDO,1469)
 1469    FORMAT(/,' NO MOS-2000 EXTERNAL BITMAP GRIDDED RANDOM ACCESS',
     1            ' DATA SET PROVIDED.')
C           THE ABOVE PRINT IS FOR THE EMPTY SET.
      ENDIF
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR READING
C        MOS-2000 BITMAP ID.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILP,PRENAM,IDUM,IDUM,1,
     1            N,'OLD','FORMATTED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(KFILP.EQ.0)THEN
         WRITE(KFILDO,1470)
 1470    FORMAT(/' NO MOS-2000 BITMAP ID DATA SET PROVIDED.')
      ELSE
         WRITE(KFILDO,1475)KFILP,PRENAM
 1475    FORMAT(/' MOS-2000 BITMAP ID DATA SET, UNIT AND NAME.'/
     1         ('  ',I3,2X,A60))
      ENDIF
C
C        READ AND PROCESS UNIT NUMBER FOR THE VARIABLE CONSTANTS DIRECTORY.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILCP,CONNAM,IDUM,IDUM,1,
     1            N,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,1478)KFILCP,CONNAM
 1478 FORMAT(/' VARIABLE CONSTANT DIRECTORY DATA SET, UNIT AND NAME.'/
     1       ('  ',I3,2X,A60))
C
C        CHECK POSSIBLE INCONSISTENCY OF INPUT UNIT NUMBERS WITH
C        OTHERS USED BY THE PROGRAM.
C
C        NOTE: THE CHECK OF IP( ) VERSUS ALL OTHER UNIT NUMBERS IS
C        NOT PERFORMED HERE.  A CHECK IN 'RDSNAM' ENSURES THAT THERE
C        ARE NO CONFLICT BETWEEN UNIT NUMBERS.  IF A CONFLICT IS
C        FOUND, THE IP( ) VALUE IS SET BACK TO THE DEFAULT VALUE
C        OF KFILDO (WHICH IS USUALLY 12).
C
      IF(KFILDO.EQ.KFILDT.OR.
     1   KFILDO.EQ.KFILRA.OR.
     2   KFILDO.EQ.KFILGO.OR.
     3   KFILDO.EQ.KFILSC1.OR.
     4   KFILDO.EQ.KFILSC2.OR.
     5   KFILDO.EQ.KFILSC3.OR.
     6   KFILDO.EQ.KFILSC4.OR.
     7   KFILDO.EQ.KFILSC5.OR.
     8   KFILDO.EQ.KFILBM.OR.
     9   KFILDO.EQ.KFILP.OR.
     A   KFILDO.EQ.KFILCP) THEN
         WRITE(KFILDO,170)
 170     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILDO WITH EITHER KFILDT, KFILRA,',/,4X,
     2            ' KFILGO, KFILSC1, KFILSC2, KFILSC3, KFILSC4,',
     3            ' KFILSC5, KFILBM, KFILP OR KFILCP.',/,4X,
     4            ' STOP IN U135 AT 171.')
         WRITE(KFILDO,171) KFILDO,KFILDT,KFILRA,KFILGO,KFILSC1,
     1                     KFILSC2,KFILSC3,KFILSC4,KFILSC5,KFILBM,
     2                     KFILP,KFILCP
 171     FORMAT(/,5X,'KFILDO  = ',I2,/,5X,'KFILDT  = ',I2,/,5X,
     1           'KFILRA  = ',I2,/,5X,'KFILGO  = ',I2,/,5X,
     2           'KFILSC1 = ',I2,/,5X,'KFILSC2 = ',I2,/,5X,
     3           'KFILSC3 = ',I2,/,5X,'KFILSC4 = ',I2,/,5X,
     4           'KFILSC5 = ',I2,/,5X,'KFILBM  = ',I2,/,5X,
     5           'KFILP   = ',I2,/,5X,'KFILCP  = ',I2)
         CALL W3TAGE('U135')
         STOP 171
      ENDIF
C
      IF(KFILRA.EQ.KFILDI.OR.
     1   KFILRA.EQ.KFILGO.OR.
     2   KFILRA.EQ.KFILDT.OR.
     3   KFILRA.EQ.KFILSC1.OR.
     4   KFILRA.EQ.KFILSC2.OR.
     5   KFILRA.EQ.KFILSC3.OR.
     6   KFILRA.EQ.KFILSC4.OR.
     7   KFILRA.EQ.KFILSC5.OR.
     8   KFILRA.EQ.KFILBM.OR.
     9   KFILRA.EQ.KFILP.OR.
     A   KFILRA.EQ.KFILCP) THEN
         WRITE(KFILDO,190)
 190     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILRA WITH EITHER KFILDI,',
     2            ' KFILGO,',/,5X,'KFILDT, KFILSC1, KFILSC2,',
     3            ' KFILSC3, KFILSC4, KFILSC5, KFILBM, KFILP',
     4            ' OR KFILCP.'/,5X,'STOP IN U135 AT 1901.')
         WRITE(KFILDO,1901) KFILRA,KFILDI,KFILGO,KFILDT,KFILSC1,
     1                      KFILSC2,KFILSC3,KFILSC4,KFILSC5,KFILBM,
     2                      KFILP,KFILCP
 1901    FORMAT(/,5X,'KFILRA  = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1           'KFILGO  = ',I2,/,5X,'KFILDT  = ',I2,/,5X,
     2           'KFILSC1 = ',I2,/,5X,'KFILSC2 = ',I2,/,5X,
     3           'KFILSC3 = ',I2,/,5X,'KFILSC4 = ',I2,/,5X,
     4           'KFILSC5 = ',I2,/,5X,'KFILBM  = ',I2,/,5X,
     5           'KFILP   = ',I2,/,5X,'KFILCP  = ',I2)
         CALL W3TAGE('U135')
         STOP 1901
      ENDIF
C
      IF(KFILGO.EQ.KFILDI.OR.
     1   KFILGO.EQ.KFILDT.OR.
     2   KFILGO.EQ.KFILSC1.OR.
     3   KFILGO.EQ.KFILSC2.OR.
     4   KFILGO.EQ.KFILSC3.OR.
     5   KFILGO.EQ.KFILSC4.OR.
     6   KFILGO.EQ.KFILSC5.OR.
     7   KFILGO.EQ.KFILBM.OR.
     8   KFILGO.EQ.KFILP.OR.
     9   KFILGO.EQ.KFILCP) THEN
         WRITE(KFILDO,191)
 191     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILGO WITH EITHER KFILDI,',
     2            ' KFILDT,',/,5X,'KFILSC1, KFILSC2,',
     3            ' KFILSC3, KFILSC4, KFILSC5, KFILBM, KFILP',
     4            ' OR KFILCP.',/,5X,'STOP IN U135 AT 1910.')
         WRITE(KFILDO,1910) KFILGO,KFILDI,KFILDT,KFILSC1,
     1                      KFILSC2,KFILSC3,KFILSC4,KFILSC5,
     2                      KFILBM,KFILP,KFILCP
 1910    FORMAT(/,5X,'KFILGO  = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1           'KFILDT  = ',I2,/,5X,'KFILSC1 = ',I2,/,5X,
     2           'KFILSC2 = ',I2,/,5X,'KFILSC3 = ',I2,/,5X,
     3           'KFILSC4 = ',I2,/,5X,'KFILSC5 = ',I2,/,5X,
     4           'KFILBM  = ',I2,/,5X,'KFILP   = ',I2,/,5X,
     5           'KFILCP  = ',I2)
         CALL W3TAGE('U135')
         STOP 1910
      ENDIF
C
      IF(KFILSC1.EQ.KFILDI.OR.
     1   KFILSC1.EQ.KFILDT.OR.
     2   KFILSC1.EQ.KFILSC2.OR.
     3   KFILSC1.EQ.KFILSC3.OR.
     4   KFILSC1.EQ.KFILSC4.OR.
     5   KFILSC1.EQ.KFILSC5.OR.
     6   KFILSC1.EQ.KFILBM.OR.
     7   KFILSC1.EQ.KFILP.OR.
     8   KFILSC1.EQ.KFILCP) THEN
         WRITE(KFILDO,192)
 192     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILSC1 WITH EITHER KFILDI,',/,4X,
     2            ' KFILDT, KFILSC2, KFILSC3, KFILSC4,',
     3            ' KFILSC5, KFILBM, KFILP OR KFILCP.',/,4X,
     4            ' STOP IN U135 AT 1920.')
         WRITE(KFILDO,1920) KFILSC1,KFILDI,KFILDT,KFILSC2,KFILSC3,
     1                      KFILSC4,KFILSC5,KFILBM,KFILP,KFILCP
 1920    FORMAT(/,5X,'KFILSC1 = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1           'KFILDT  = ',I2,/,5X,'KFILSC2 = ',I2,/,5X,
     2           'KFILSC3 = ',I2,/,5X,'KFILSC4 = ',I2,/,5X,
     3           'KFILSC5 = ',I2,/,5X,'KFILBM  = ',I2,/,5X,
     4           'KFILP   = ',I2,/,5X,'KFILCP  = ',I2)
         CALL W3TAGE('U135')
         STOP 1920
      ENDIF
C
      IF(KFILSC2.NE.0) THEN
         IF(KFILSC2.EQ.KFILDI.OR.
     1      KFILSC2.EQ.KFILDT.OR.
     2      KFILSC2.EQ.KFILSC3.OR.
     3      KFILSC2.EQ.KFILSC4.OR.
     4      KFILSC2.EQ.KFILSC5.OR.
     5      KFILSC2.EQ.KFILBM.OR.
     6      KFILSC2.EQ.KFILP.OR.
     7      KFILSC2.EQ.KFILCP) THEN
            WRITE(KFILDO,193)
 193        FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1               ' IN KFILSC2 WITH EITHER KFILDI,',
     2               ' KFILDT,',/,5X,'KFILSC3, KFILSC4,',
     3               ' KFILSC5, KFILBM, KFILP OR KFILCP.',
     4               '  STOP IN U135 AT 1930.')
            WRITE(KFILDO,1930) KFILSC2,KFILDI,KFILDT,KFILSC3,
     1                         KFILSC4,KFILSC5,KFILBM,KFILP,KFILCP
 1930       FORMAT(/,5X,'KFILSC2 = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1              'KFILDT  = ',I2,/,5X,'KFILSC3 = ',I2,/,5X,
     2              'KFILSC4 = ',I2,/,5X,'KFILSC5 = ',I2,/,5X,
     3              'KFILBM  = ',I2,/,5X,'KFILP   = ',I2,/,5X,
     4              'KFILCP  = ',I2)
            CALL W3TAGE('U135')
            STOP 1930
         ENDIF
      ENDIF
C
      IF(KFILSC3.EQ.KFILDI.OR.
     1   KFILSC3.EQ.KFILDT.OR.
     2   KFILSC3.EQ.KFILSC4.OR.
     3   KFILSC3.EQ.KFILSC5.OR.
     4   KFILSC3.EQ.KFILBM.OR.
     5   KFILSC3.EQ.KFILP.OR.
     6   KFILSC3.EQ.KFILCP) THEN
         WRITE(KFILDO,194)
 194     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILSC3 WITH EITHER KFILDI, KFILDT,',/,
     2            5X,'KFILSC4, KFILSC5, KFILBM, KFILP OR',
     3            ' KFILCP.  STOP IN U135 AT 1940.')
         WRITE(KFILDO,1940) KFILSC3,KFILDI,KFILDT,KFILSC4,
     1                      KFILSC5,KFILBM,KFILP,KFILCP
 1940    FORMAT(/,5X,'KFILSC3 = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1           'KFILDT  = ',I2,/,5X,'KFILSC4 = ',I2,/,5X,
     2           'KFILSC5 = ',I2,/,5X,'KFILBM  = ',I2,/,5X,
     3           'KFILP   = ',I2,/,5X,'KFILCP  = ',I2)
         CALL W3TAGE('U135')
         STOP 1940
      ENDIF
C
      IF(KFILSC4.EQ.KFILDI.OR.
     1   KFILSC4.EQ.KFILDT.OR.
     2   KFILSC4.EQ.KFILSC5.OR.
     3   KFILSC4.EQ.KFILBM.OR.
     4   KFILSC4.EQ.KFILP.OR.
     5   KFILSC4.EQ.KFILCP) THEN
         WRITE(KFILDO,195)
 195     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILSC4 WITH EITHER KFILDI,',/,4X,
     2            ' KFILDT, KFILSC5, KFILBM, KFILP OR KFILCP. ',
     3            ' STOP IN U135 AT 1950.')
         WRITE(KFILDO,1950) KFILSC4,KFILDI,KFILDT,KFILSC5,KFILBM,
     1                      KFILP,KFILCP
 1950    FORMAT(/,5X,'KFILSC4 = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1           'KFILDT  = ',I2,/,5X,'KFILSC5 = ',I2,/,5X,
     2           'KFILBM  = ',I2,/,5X,'KFILP   = ',I2,/,5X,
     3           'KFILCP  = ',I2)
         CALL W3TAGE('U135')
         STOP 1950
      ENDIF
C
      IF(KFILSC5.EQ.KFILDI.OR.
     1   KFILSC5.EQ.KFILDT.OR.
     2   KFILSC5.EQ.KFILBM.OR.
     3   KFILSC5.EQ.KFILP.OR.
     4   KFILSC5.EQ.KFILCP) THEN
         WRITE(KFILDO,196)
 196     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILSC5 WITH EITHER KFILDI,',/,4X, 
     2            ' KFILDT, KFILBM, KFILP OR KFILCP.  STOP IN',
     3            ' U135 AT 1960.')
         WRITE(KFILDO,1960) KFILSC5,KFILDI,KFILDT,KFILBM,
     1                      KFILP,KFILCP
 1960    FORMAT(/,5X,'KFILSC5 = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1          'KFILDT  = ',I2,/,5X,'KFILBM  = ',I2,/,5X,
     2          'KFILP   = ',I2,/,5X,'KFILCP  = ',I2)
         CALL W3TAGE('U135')
         STOP 1960
      ENDIF
C
      IF(KFILBM.NE.0) THEN
         IF(KFILBM.EQ.KFILDI.OR.
     1      KFILBM.EQ.KFILDT.OR.
     2      KFILBM.EQ.KFILP.OR.
     3      KFILBM.EQ.KFILCP) THEN
            WRITE(KFILDO,197)
 197        FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1               ' IN KFILBM WITH EITHER KFILDI, KFILDT,',
     2               ' KFILP OR KFILCP.',/,4X,' STOP IN U135',
     3               ' AT 1970.')
            WRITE(KFILDO,1970) KFILBM,KFILDI,KFILDT,KFILP,KFILCP
 1970       FORMAT(/,5X,'KFILBM  = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1             'KFILDT  = ',I2,/,5X,'KFILP   = ',I2,/,5X,
     2             'KFILCP  = ',I2)
            CALL W3TAGE('U135')
            STOP 1970
         ENDIF
      ENDIF
C
      IF((KFILP.GT.0).AND.(KFILP.NE.KFILDI)) THEN
         IF(KFILP.EQ.KFILDT.OR.
     1      KFILP.EQ.KFILCP) THEN
            WRITE(KFILDO,198)
 198        FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1               ' IN KFILP WITH EITHER KFILDT OR KFILCP.',/,
     2               4X,' STOP IN U135 AT 1980.')
            WRITE(KFILDO,1980) KFILP,KFILDT,KFILCP
 1980       FORMAT(/,5X,'KFILP   = ',I2,/,5X,'KFILDT  = ',I2,/,5X,
     1             'KFILCP  = ',I2)
            CALL W3TAGE('U135')
            STOP 1980
         ENDIF
      ENDIF
C
      IF(KFILCP.EQ.KFILDI.OR.
     1   KFILCP.EQ.KFILDT) THEN
         WRITE(KFILDO,199)
 199     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILCP WITH EITHER KFILDI OR KFILDT.',/,
     2            4X,' STOP IN U135 AT 1990.')
         WRITE(KFILDO,1990) KFILCP,KFILDI,KFILDT
 1990    FORMAT(/,5X,'KFILCP  = ',I2,/,5X,'KFILDI  = ',I2,/,5X,
     1               'KFILDT  = ',I2)
         CALL W3TAGE('U135')
         STOP 1990
      ENDIF
C
C        IF AN EXTERNAL GRIDDED RANDOM ACCESS FILE CONTAINING BITMAP
C        INFORMAION IS PRESENT, A VARIABLE MOS-2000 ID MUST ALSO BE 
C        PRESENT IN THE VARIABLE LIST.  THE CONVERSE IS ALSO TRUE.
C
      IF((KFILBM.NE.0).AND.(KFILP.NE.0)) THEN
C           A RANDOM ACCESS FILE IS PRESENT WITH A MOS-2000 ID
C           IN THE VARIABLE LIST.
         JFLAG=1
      ELSEIF((KFILBM.EQ.0).AND.(KFILP.NE.0)) THEN
        WRITE(KFILDO,210)
 210    FORMAT(/,' ****A VARIABLE LIST HAS BEEN ENTERED AS INPUT',
     1           ' HOWEVER A BITMAP GRIDDED RANDOM ACCESS FILE IS',
     2           ' NOT',/,4X,' STIPULATED IN THE CONTROL FILE. ',
     3           ' INCONSISTENCY.',1X,' STOP IN U135 AT 210.')
        CALL W3TAGE('U135')
        STOP 210
      ELSEIF((KFILBM.NE.0).AND.(KFILP.EQ.0)) THEN
         WRITE(KFILDO,220)
 220     FORMAT(/,' ****A VARIABLE LIST IS NOT PRESENT IN THE',
     1            ' CONTROL FILE WHILE A BITMAP GRIDDED RANDOM',
     2            ' ACCESS FILE',/,5X,'HAS BEEN STIPULATED IN THE',
     3            ' CONTROL FILE.  INCONSISTENCY.  STOP IN',
     4            ' U135 AT 220.')
         CALL W3TAGE('U135')
         STOP 220
      ENDIF
C
C        ENSURE CONSISTENCY BETWEEN THE FLAG OF 'JBMAP' AND 'KFILBM'.
C        THAT IS TO SAY THAT IF A BITMAP HAS NOT BEEN DEFINED ON INPUT,
C        'JBMAP' MUST BE CONSISTENT WITH THIS DECLARATION.
C
      IF((KFILBM.EQ.0).AND.(JBMAP.EQ.1)) THEN 
         WRITE(KFILDO,225)
 225     FORMAT(/,' ****THE USER REQUESTS THAT A BITMAP BE PACKED',
     1            ' INTO GRIB2.  HOWEVER, A BITMAP HAS NOT BEEN',
     2            /,5X,'DEFINED ON INPUT.  STOP 225 IN U135.') 
         CALL W3TAGE('U135')
         STOP 225
      ENDIF
C
C        READ THE BITMAP ID LIST.
C
      IF(KFILP.NE.0) THEN
         CALL RDPRED(KFILDO,IP(6),IP(7),IP(8),IP(9),KFILP,KFILCP,
     1               ID,IDPARS,THRESH,JD,JP,ISCALD,SMULT,SADD,
     2               ORIGIN,CINT,JPLAIN,UNITS,ND4,NPRED,ISTOP(1),IER)
         IF(KFILP.NE.KFILDI)CLOSE(UNIT=KFILP)
C        FILE KFILP IS CLOSED WHEN IT IS NOT THE SAME AS
C        THE DEFAULT INPUT FILE.
      ENDIF
C
C        ENSURE THAT ONLY ONE BITMAP ID IS IN THE VARIABLE
C        LIST.  IF MORE THAN ONE VARIABLE EXISTS, TERMINATE
C        THE PROGRAM.
C
      IF(NPRED.GT.1) THEN
         WRITE(KFILDO,230)
 230     FORMAT(/,' ****THE NUMBER OF BITMAP IDS IN THE',
     1            ' VARIABLE LIST EXCEEDS ONE.  ONLY ONE BITMAP',
     2            /,5X,'ID ENTRY IS PERMITTED.  STOP 230 IN U135.')
         CALL W3TAGE('U135')
         STOP 230
      ENDIF
C
C        READ THE TDLPACK DATA AND CONVERT THE DATA TO GRIB2.
C        THE GRIB2 DATA ARE WRITTEN TO OUTPUT FILE 'KFILGO',
C        IF DESIRED. 
C
      CALL RDTDLPK(KFILDO,KFILRA,KFILGO,KFILSC1,KFILSC2,
     1             KFILSC3,KFILSC4,KFILSC5,RACESS,
     2             OUTGRD,KFILBM,BMPNAM,ID,IWORK,
     3             FLD,BMAPDATA,BMAP,ND5,ND7,
     4             ND10,ND11,ND12,IP,LCGRIB,ISCT2LEN,IGDSTMPLEN,
     5             IPDSTMPLEN,IDRSTMPLEN,IDEFNUM,NUMCOORD,
     6             JDATE,IS0,IS1,IS2,IS4,MPROJ,XMISSS,
     7             NTOTBG,NTOTRG,L3264B,JLCL,JFLAG,JBMAP,
     8             BMAPVAL,ISTOP,IER)
C
C        PRINT THE FINAL DIAGNOSTICS.
C
      WRITE(KFILDO,309)NTOTBG,NTOTRG,OUTGRD
 309  FORMAT(/,' A TOTAL OF ',I11,' BYTES IN ',I7,' FIELDS NOW',
     1         ' EXIST ON FILE ',A60)
      IF(ISTOP(1).NE.0)WRITE(KFILDO,311)ISTOP(1)
 311  FORMAT(/,' AT LEAST ISTOP(1) =',I6,
     1        ' ERRORS HAVE OCCURRED ON THIS RUN.')
      IF(ISTOP(2).NE.0.AND.ISTOP(1).EQ.0)WRITE(KFILDO,312)ISTOP(2)
 312  FORMAT(/,' AT LEAST ISTOP(2) =',I6,
     1        ' DATA FIELDS NOT FOUND ON THIS RUN.')
      IF(ISTOP(2).NE.0.AND.ISTOP(1).NE.0)WRITE(KFILDO,313)ISTOP(2)
 313  FORMAT(' AT LEAST ISTOP(2) =',I6,
     1       ' DATA FIELDS NOT FOUND ON THIS RUN.')
      IF(ISTOP(1).EQ.0.AND.ISTOP(2).EQ.0)WRITE(KFILDO,314)
 314  FORMAT(/,' NO ERRORS HAVE BEEN DETECTED ON THIS RUN.')
      WRITE(KFILDO,315)
 315  FORMAT(' ')
      RETURN
C 
C        ERROR STOP BELOW IS FOR ERRORS OF CONTROL INFORMATION INPUT.
C
 900  CALL IERX(KFILDO,KFILDO,IOS,'U135  ',STATE)
      CALL W3TAGE('U135')
      STOP 9999
      END
