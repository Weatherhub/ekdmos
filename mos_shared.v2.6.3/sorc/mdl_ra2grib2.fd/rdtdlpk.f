      SUBROUTINE RDTDLPK(KFILDO,KFILRA,KFILGO,KFILSC1,KFILSC2,
     1                   KFILSC3,KFILSC4,KFILSC5,RACESS,
     2                   OUTGRD,KFILBM,BMPNAM,ID,IWORK,
     3                   FLD,BMAPDATA,BMAP,ND5,ND7,
     4                   ND10,ND11,ND12,IP,LCGRIB,ISCT2LEN,IGDSTMPLEN,
     5                   IPDSTMPLEN,IDRSTMPLEN,IDEFNUM,NUMCOORD,
     6                   JDATE,IS0,IS1,IS2,IS4,MPROJ,XMISSS,
     7                   NTOTBG,NTOTRG,L3264B,JLCL,JFLAG,JBMAP,
     8                   BMAPVAL,ISTOP,IER)
C
C$$$   SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: RDTDLPK
C   PRGMMR: RUDACK         ORG: W/OST22          DATE: 2004-11-11
C
C ABSTRACT: TO READ TDLPACKED GRIDDED DATA FROM A GRIDDED RANDOM 
C   ACCESS FILE AND CONVERT THE DATA AND METADATA TO GRIB2.  
C   THE DATA ARE THEN PACKED INTO OUTPUT FILE 'KFILGO'.  
C   NOTE THAT THE UNIT NUMBER CORRESPONDING TO THE FILE 
C   CONTAINING INFORMATION FOR THE LOCAL USE SECTION
C   (SECTION 2) IS PASSED INTO THIS SUBROUTINE.  HOWEVER,
C   THIS SECTION IS OPTIONAL.
C
C PROGRAM HISTORY LOG:
C   04-11-11  RUDACK
C   05-03-16  MALONEY   ADDED NCEP DOCBLOCK.  ADDED CALLS TO W3TAGE.
C   12-09-13  ENGLE     CHANGED ENVVAR FROM 'XLFUNIT_  ' TO 'FORT  '
C   13-11-15  HUNTEMANN ADDED LOCAL USE/SECTION 2.
C                       INITIALIZED JGROUPS( ) ARRAYS TO 0.
C                       INITIALIZED ENVVAR AND FILEO TO CHARACTER*90
C                       FOR LONGER FILENAMES ON WCOSS SYSTEM.
C
C USAGE:  CALLED BY U135
C
C        DATA SET USE:
C        INPUT FILES:
C          FORT.KFILRA - UNIT NUMBER OF GRIDDED EXTERNAL RANDOM ACCESS
C                        FILE.  (INPUT)
C         FORT.KFILSC1 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE INDICATOR AND IDENTIFICATION
C                        GRIB2 SECTIONS (SECTIONS 0 AND 1). (INPUT)
C         FORT.KFILSC2 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 LOCAL USE SECTION
C                        (SECTION 2).  (INPUT)
C         FORT.KFILSC3 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 GRID DEFINITION
C                        SECTION (SECTION 3). (INPUT)
C         FORT.KFILSC4 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 PRODUCT DEFINITION
C                        SECTION (SECTION 4). (INPUT)
C         FORT.KFILSC5 - UNIT NUMBER OF FILE CONTAINING THE VALUES
C                        PERTAINING TO THE GRIB2 DATA REPRESENTATION
C                        SECTION (SECTION 5). (INPUT)
C          FORT.KFILBM - UNIT NUMBER OF GRIDDED EXTERNAL RANDOM ACCESS
C                        FILE CONTAINIG BITMAP INFORMATION.  (INPUT)
C        OUTPUT FILES:
C          FORT.KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C          FORT.KFILGO - UNIT NUMBER OF GRIB2 OUTPUT FILE.  (OUTPUT)
C           FORT.IP(J) - UNIT NUMBERS FOR OPTIONAL OUTPUT (SEE IP( )
C                        UNDER "VARIABLES" BELOW.)  (J=1,25)  (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFILRA = UNIT NUMBER OF EXTERNAL RANDOM ACCESS FILE.  (INPUT)
C              KFILGO = UNIT NUMBER OF GRIDPOINT OUTPUT FILE. (INPUT)
C             KFILSC1 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE INDICATOR AND IDENTIFICATION
C                       GRIB2 SECTIONS (SECTIONS 0 AND 1). (INPUT)
C             KFILSC2 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 LOCAL USE SECTION
C                       (SECTION 2).  (INPUT)
C             KFILSC3 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 GRID DEFINITION
C                       SECTION (SECTION 3). (INPUT)
C             KFILSC4 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 PRODUCT DEFINITION
C                       SECTION (SECTION 4). (INPUT)
C             KFILSC5 = UNIT NUMBER OF FILE CONTAINING THE VALUES
C                       PERTAINING TO THE GRIB2 DATA REPRESENTATION
C                       SECTION (SECTION 5). (INPUT)
C              RACESS = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILRA.  (CHARACTER*60)  (INPUT)
C              OUTGRD = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILGO.  (CHARACTER*60) (INPUT)
C              KFILBM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILBM.  (CHARACTER*60)  (INPUT)
C              BMPNAM = CHARACTER FILE NAME CORRESPONDING TO UNIT NUMBER
C                       KFILBM.  (CHARACTER*60)  (INPUT)
C               ID(J) = THE INTEGER VARIABLE BITMAP ID (J=1,4).  (INPUT)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INPUT)
C              FLD(J) = CONTAINS THE GRIDPOINT DATA FIELD BEING PROCESSED
C                       (J=1,ND5).  (INPUT)
C         BMAPDATA(J) = ARRAY CONTAINING THE BITMAP VALUES READ FROM THE
C                       BITMAP FILE KFILBM (J=1,ND5).  (INPUT)
C             BMAP(J) = LOGICAL*1 ARRAY CONTAINING BITMAP TO BE ADDED (J=1,ND5).
C                       (INPUT)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND FLD( ). 
C                       NOTE THAT ND5 MUST BE GE NX*NY.  (INPUT)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       SHOULD BE GE 54.  (INPUT)
C                ND10 = MAXIMUM NUMBER OF FIELDS ALLOWED IN ANY ONE
C                       SPECIFIC MESSAGE.  (INPUT)
C                ND11 = MAXIMUM NUMBER OF OUTPUT GRID ENTRIES DEFINED IN
C                       THE GRID DEFINITION FILE CORRESPONDING TO SECTION 3.
C                       (INPUT)
C                ND12 = MAXIMUM NUMBER OF GROUPS (OR MESSAGES) THAT CAN
C                       BE PROCESSED IN ONE RUN OF U135.  (INPUT)
C               IP(J) = EACH VALUE (J=1,25) INDICATES WHETHER (>1)
C                       OR NOT (=0) CERTAIN INFORMATION WILL BE WRITTEN.
C                       WHEN IP( ) > 0, THE VALUE INDICATES THE UNIT
C                       NUMBER FOR OUTPUT.  THESE VALUES SHOULD NOT BE
C                       THE SAME AS ANY KFILX VALUES EXCEPT POSSIBLY
C                       KFILDO, WHICH IS THE DEFAULT OUTPUT FILE.  THIS
C                       IS ASCII OUTPUT, GENERALLY FOR DIAGNOSTIC
C                       PURPOSES.  THE FILE NAMES WILL BE 4 CHARACTERS
C                       'U135', THEN 4 CHARACTERS FROM IPINIT, THEN
C                       2 CHARACTERS FROM IP(J) (E.G., 'U135DER130').
C                       THE ARRAY IS INITIALIZED TO ZERO IN CASE LESS
C                       THAN THE EXPECTED NUMBER OF VALUES ARE READ IN.
C                       (1) = ALL ERRORS AND OTHER INFORMATION NOT
C                             SPECIFICALLY IDENTIFIED WITH OTHER IP( )
C                             NUMBERS.  WHEN IP(1) IS READ AS NONZERO,
C                             KFILDO, THE DEFAULT OUTPUT FILE UNIT NUMBER,
C                             WILL BE SET TO IP(1).  WHEN IP(1) IS READ
C                             AS ZERO, KFILDO WILL BE USED UNCHANGED.
C                       (2) = THE INPUT DATE.  WHEN THERE ARE ERRORS, 
C                             PRINT WILL BE TO UNIT KFILDO AS WELL AS 
C                             TO UNIT IP(2).
C                       (3) = THE OUTPUT DATE.  WHEN THERE ARE ERRORS, 
C                             OUTPUT WILL BE TO UNIT KFILDO AS WELL AS
C                             TO UNIT IP(3).
C                       (6) = THE BITMAP VARIABLES AS THEY ARE BEING
C                             READ IN.  THIS IS GOOD FOR CHECKOUT;
C                             FOR ROUTINE OPERATION, IP(7), IP(8), AND/OR
C                             IP(9), MAY BE BETTER.
C                       (7) = THE BITMAP VARIABLE LIST IN SUMMARY FORM.
C                             IF THERE ARE ERRORS, THE BITMAP VARIABLE LIST
C                             WILL BE WRITTEN TO THE DEFAULT OUTPUT FILE
C                             UNIT KFILDO AS WELL AS TO UNIT IP(7).
C                             THIS LIST INCLUDES THE PARSED ID'S IN IDPARS( , ).
C                       (8) = THE BITMAP VARIABLE LIST IN SUMMARY FORM AFTER
C                             AFTERV REORDERING.  THIS LIST INCLUDES THE PARSED
C                             ID'S IN IDPARS( , ).
C                       (9) = THE BITMAP VARIABLE LIST IN SUMMARY FORM AFTER
C                             REORDERING.  THIS DIFFERS FROM (8) IN THAT (9)
C                             DOES NOT INCLUDE THE PARSED ID'S IN IDPARS( , ),
C                             BUT RATHER INCLUDES THE INFORMATION TAKEN
C                             FROM THE CONSTANT FILE ON UNIT KFILCP.
C                      (12) = THE LIST OF VALUES PERTAINING TO SECTIONS 0
C                             AND 1 IN THE GRIB2 MESSAGE.  THESE VALUES
C                             ARE SET IN THE GRIB2 INDICATOR AND
C                             IDENTIFICATION INPUT FILE.
C                      (13) = THE LIST OF VALUES PERTAINING TO SECTION 2 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN
C                             THE LOCAL USE SECTION INPUT FILE.
C                      (14) = THE LIST OF VALUES PERTAINING TO SECTION 3 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN
C                             THE GRID DEFINITION SECTION INPUT FILE.
C                      (15) = THE LIST OF VALUES PERTAINING TO SECTION 4 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN
C                             THE PRODUCT DEFINITION SECTION INPUT FILE.
C                      (16) = THE LIST OF VALUES PERTAINING TO SECTION 5 IN
C                             THE GRIB2 MESSAGE.  THESE VALUES ARE SET IN
C                             THE DATA REPRESENTATION SECTION INPUT FILE.
C                      (17) = THE RAW TDLPACK GRIDDED VALUES PRINTED TO THE
C                             NEAREST THOUSANDTHS PLACE.
C                      (18) = PRINT OF BITMAP GRIDDED VALUES.
C              LCGRIB = MAXIMUM LENGTH (BYTES) OF GRIB2 MESSAGE (STORED IN
C                       CHARACTER ARRAY CGRIB( ).)  (INPUT)
C            ISCT2LEN = MAXIMUM DIMENSION OF FSCT2( ).  LOCAL USE
C                       SECTION OF THE GRIB2 MESSAGE (SECTION 2). (INPUT)
C          IGDSTMPLEN = MAXIMUM DIMENSION OF IGDSTMPL( ).  GRID DEFINITION
C                       SECTION OF THE GRIB2 MESSAGE (SECTION 3). (INPUT)
C          IPDSTMPLEN = MAXIMUM DIMENSION OF IPDSTMPL( ).  PRODUCT
C                       DEFINITION SECTION OF THE GRIB2 MESSAGE (SECTION 4).
C          IDRSTMPLEN = MAXIMUM DIMENSION OF IDRSTMPL( ).  DATA REPRESENTATION
C                       SECTION OF THE GRIB2 MESSAGE (SECTION 5).  (INPUT)
C             IDEFNUM = (USED IF IGDS(3,ND11).NE.0) THE NUMBER OF ENTRIES 
C                       IN ARRAY IDEFLIST( , ).  I.E., THE NUMBER OF ROWS 
C                       (COLUMNS) FOR WHICH OPTIONAL GRIDPOINTS ARE DEFINED. 
C                       (SET IN PARAMETER STATEMENT IN DRIVER)  (INPUT)
C            NUMCOORD = NUMBER OF VALUES IN ARRAY COORDLIST( ).  SET IN
C                       PARAMETER STATEMENT IN DRU135.  (INPUT)
C               JDATE = PROCESSING DATE PLACED IN THE DATE LIST. (INPUT)  
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,4).  (INPUT)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,21+).  (INPUT)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INPUT)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INPUT)
C               MPROJ = MAP PROJECTION IDENTIFIER SET AT THE TOP OF
C                       U135.CN (CHARACTER*6).  (INPUT)
C              XMISSS = VALUE ASSIGNED TO A SECONDARY MISSING WHEN PACKED
C                       INTO GRIB2.  (INPUT)
C              NTOTBG = THE TOTAL NUMBER OF BYTES WRITTEN TO THE GRIB2 
C                       OUTPUT FILE.  (OUTPUT)
C              NTOTRG = THE TOTAL NUMBER OF RECORDS WRITTEN TO THE GRIB2 
C                       OUTPUT FILE.  (OUTPUT) 
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  SET BY PARAMETER IN DRU135. 
C                       (INPUT)
C                JLCL = FLAG (=1) INDICATES THAT THE LOCAL USE SECTION
C                       (SECTION 2) IS BEING USED. (INPUT)
C               JFLAG = FLAG (=1) INDICATES THAT AN EXTERNAL GRIDDED RANDOM
C                       ACCESS FILE IS BEING USED TO MASK THE DATA.  (INPUT)
C               JBMAP = FLAG (=1) INDICATES THAT THE BITMAP SUPPLIED BY THE
C                       USER ON INPUT WILL BE PACKED INTO THE GRIB2 MESSAGE.
C                       (INPUT)
C             BMAPVAL = VALUE ASSIGNED TO THE UNPACKED TDLPACK DATA THAT IS
C                       TO BE MASKED.  (INPUT)
C            ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER
C                       AN INPUT DATA RECORD IS NOT FOUND.  (INPUT/OUTPUT)
C                 IER = STATUS RETURN.
C                        0 = GOOD RETURN.
C                        > 0 VALUES RETURNED FROM OTHER ROUTINES. 
C                       (INTERNAL-OUTPUT)
C
C****END OF VARIABLE LIST PASSED FROM U135
C
C         LISTSEC0(2) = CONTAINS INFORMATION NEEDED FOR GRIB INDICATOR 
C                       SECTION 0.  MUST BE DIMENSIONED GREATER THAN OR 
C                       EQUAL TO 2.  (INTERNAL)
C        LISTSEC1(13) = CONTAINS INFORMATION NEEDED FOR GRIB IDENTIFICATION 
C                       SECTION 1.  MUST BE DIMENSIONED GREATER THAN OR 
C                       EQUAL TO 13.  (INTERNAL)
C        FSCT2(N,K,J) = CONTAINS THE DATA VALUES FOR THE SPECIFIED LOCAL 
C                       USE FILE. EACH INTEGER IN THE ARRAY IS A DECIMAL 
C                       REPRESENTATION THAT CORRESPONDS TO AN ASCII 
C                       CHARACTER. 0 IN THE ARRAY MARKS THE ENDING OF A 
C                       UNIQUE WEATHER KEY (N=1,NFSCT2) (K=1,ND12)
C                       (J=1,ND10)  (INTERNAL)
C         NFSCT2(K,J) = DIMENSION OF FSCT2(N).  LOCAL USE SECTION 
C                       OF THE GRIB2 MESSAGE (SECTION 2). (K=1,ND12)
C                       (J=1,ND10)  (INTERNAL)
C           IGDS(5,J) = CONTAINS INFORMATION NEEDED FOR GRIB2 GRID 
C                       DEFINITION SECTION 3.  MUST BE DIMENSION GREATER 
C                       THAN OR EQUAL TO 5 (J=1,ND11).  (INTERNAL)
C       IGDSTMPL(N,J) = CONTAINS THE DATA VALUES FOR THE SPECIFIED GRID 
C                       DEFINITION TEMPLATE (NN=IGDS(5,J)).  EACH ELEMENT 
C                       OF THIS INTEGER ARRAY CONTAINS AN ENTRY (IN THE 
C                       ORDER SPECIFIED) OF GRID DEFINITION TEMPLATE 3.NN 
C                       (N=IGDSTMPLEN),(J=1,ND11).  (INTERNAL)
C       IDEFLIST(N,J) = (USED IF IGDS(3,J).NE.0)  THIS ARRAY CONTAINS THE 
C                       NUMBER OF GRIDPOINTS CONTAINED IN EACH ROW 
C                       (OR COLUMN) (N=IDEFNUM),(J=1,ND12).  
C                       (NOT CURRENTLY USED)  (INTERNAL)
C      COORDLIST(N,J) = ARRAY CONTAINING FLOATING POINT VALUES INTENDED
C                       TO DOCUMENT THE VERTICAL DISCRETIZATION ASSOCIATED 
C                       TO THE MODEL DATA ON THE HYBRID COORDINATE 
C                       VERTICAL LEVELS.  (N=NUMCOORD),(J=1,ND12).  
C                       (NOT USED)  (INTERNAL)
C     IPDSTMPL(N,K,J) = CONTAINS THE DATA VALUES FOR THE SPECIFIED PRODUCT 
C                       DEFINITION TEMPLATE (N=IPDSNUM).  EACH ELEMENT OF 
C                       THIS INTEGER ARRAY CONTAINS AN ENTRY (IN THE ORDER 
C                       SPECIFIED) OF THE PRODUCT DEFINITION TEMPLATE 4.N. 
C                       (K=1,ND10),(J=1,ND12).  (INTERNAL)
C     IDRSTMPL(N,K,J) = CONTAINS THE DATA VALUES FOR THE SPECIFIED DATA 
C                       REPRESENTATION TEMPLATE (N=IDRSNUM).  EACH ELEMENT 
C                       OF THIS INTEGER ARRAY CONTAINS AN ENTRY (IN THE 
C                       ORDER SPECIFIED) OF DATA REPRESENTATION TEMPLATE 5.N. 
C                       NOTE THAT SOME VALUES IN THIS TEMPLATE (E.G.
C                       REFERENCE VALUES, NUMBER OF BITS, ETC...) MAY BE 
C                       CHANGED BY THE DATA PACKING ALGORITHMS.  USE THIS 
C                       TO SPECIFY SCALING FACTORS AND ORDER OF SPATIAL 
C                       DIFFERENCING, IF DESIRED.  (INTERNAL)
C        IPDSNUM(K,J) = PRODUCT DEFINITION TEMPLATE NUMBER (SEE CODE
C                       TABLE 4.0) (K=1,ND10),(J=1,ND12).  (INTERNAL)
C        IDRSNUM(K,J) = DATA REPRESENTATION TEMPLATE NUMBER (SEE CODE 
C                       TABLE 5.0) (K=1,ND10),(J=1,ND12).  (INTERNAL)
C        IDMDL(4,K,J) = FOUR WORD MOS-2000 ID TO BE PROCESSED (K=1,ND10),
C                       (J=1,ND12).  (INTERNAL)
C      JPLAIN(32,K,J) = THE PLAIN LANGUAGE DESCRIPTION OF THE VARIABLES
C                       READ FROM THE PRODUCT DEFINITION FILE (K=1,ND10),
C                       (J=1,ND12).  (CHARACTER*32)  (INTERNAL)
C          JGPLAIN(N) = THE SIX CHARACTER STRING MAP PROJECTION IDENTIFIER
C                       AS READ FROM THE GRID DEFINITION FILE (N=1,ND11).
C                       (CHARACTER*6)  (INTERNAL)
C           JEND(K,J) = FLAG (HAVING A VALUE OF ONE) INDICATING THE LAST
C                       ENTRY IN A PARTICULAR GROUP (K=1,ND10),(J=1,ND12).  
C                       (INTERNAL)
C        JGROUPS(J).. = NUMBER OF ENTRIES (GRIDS) IN EACH GROUP THAT WILL BE
C                       PLACED INTO GRIB2 (J=1,ND12).  (INTERNAL)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (ALLOCATABLE ARRAY)  (INTERNAL)
C            CGRIB(J) = CHARACTER ARRAY THAT CONTAINS THE GRIB2 MESSAGE
C                       (J=1,LCGRIB).  (ALLOCATABLE ARRAY)  (INTERNAL)
C             NGROUPS = TOTAL NUMBER OF GROUPS (OR MESSAGES) THAT WILL BE 
C                       PROCESSED IN ONE RUN OF U135.  (INTERNAL)
C               JGRID = THE SPECIFIC ENTRY NUMBER IN THE GRID DEFINITION 
C                       FILE THAT MATCHES 'MPROJ'.  (INTERNAL)
C               JPACK = COUNTER THAT TALLYS THE TOTAL NUMBER OF ENTRIES 
C                       PACKED FOR A SPECIFIC GROUP OF ENTRIES.  (INTERNAL)
C          IS2BMAP(J) = MOS-2000 GRIB SECTION 2 ID'S FOR THE EXTERNAL
C                       GRIDDED BITMAP RANDOM ACCESS FILE (J=1,12).  
C                       (INTERNAL)
C              JCHECK = FLAG (=1) INDICATING THAT THE BITMAP GRID
C                       CHARACTERISTICS HAVE BEEN CHECKED AGAINST THE 
C                       GRID CHARACTERISTICS FOUND IN THE TDLPACK INPUT
C                       FILE.  (INTERNAL)
C              ENVVAR = XLF "NAME" OF OUTPUT FILE (INTERNAL)
C               FILEO = ACTUAL FILE OUTPUT NAME LINKED TO XLF UNIT NO. 
C                       (INTERNAL)
C                IRET = STATUS RETURNED FROM BAOPEN & BACLOSE
C
C        SUBPROGRAMS CALLED:  CONSTG, CHKGRID, RDSECT1, RDSECT2, RDSECT3, 
C         RDSECT4, RDSECT5, CHKDUP, PACKGRIB2, GRIBCLOSE, BAOPEN,
C          BACLOSE, WRYTE, W3TAGE, GETENV
C          UNIQUE: - CHKGRID, RDSECT1, RDSECT2, RDSECT3, RDSECT4, RDSECT5,
C                    CHKDUP, PACKGRIB2, GRIBCLOSE
C          LIBRARY:
C             MDL - CONSTG
C            NCEP - BAOPEN, BACLOSE, WRYTE, GETENV
C           W3LIB - W3TAGE
C
C        EXIT STATES:
C          COND =    0 - SUCCESSFUL RUN
C                   32 - PROBLEM OPENING GRIB2 FILE
C                   35 - TOTAL NUMBER OF MESSAGE ENTRIES IN THE GRIB2
C                        DESCRIPTOR FILES ARE NOT EQUAL
C                   38 - TOTAL NUMBER OF MESSAGE ENTRIES IN THE GRIB2
C                        INPUT FILES ARE NOT EQUAL
C                   55 - CANNOT FIND BITMAP
C                   75 - DATE MISMATCH
C
C REMARKS:  NONE
C
C ATTRIBUTES:
C   LANGUAGE:  FORTRAN 90 (xlf90 compiler)
C   MACHINE:  IBM SP
C
C$$$
C
      CHARACTER*1, ALLOCATABLE, DIMENSION(:) :: CGRIB
      CHARACTER*6  MPROJ,JGPLAIN(ND11)
      CHARACTER*32 JPLAIN(32,ND10,ND12)
      CHARACTER*60 OUTGRD,RACESS,BMPNAM
      CHARACTER*90 ENVVAR,FILEO
C
      LOGICAL*1 BMAP(ND5)
C
      INTEGER, ALLOCATABLE, DIMENSION(:) :: IPACK
C
      REAL, ALLOCATABLE,DIMENSION(:,:,:) :: FSCT2
C
      DIMENSION IWORK(ND5),FLD(ND5),BMAPDATA(ND5)
      DIMENSION LISTSEC0(2),LISTSEC1(13),
     1          NFSCT2(ND10,ND12),
     2          IGDS(5,ND11),IGDSTMPL(IGDSTMPLEN,ND11),
     3          IDRSTMPL(IDRSTMPLEN,ND10,ND12),
     4          IPDSTMPL(IPDSTMPLEN,ND10,ND12),
     5          IDEFLIST(IDEFNUM,ND12),IPDSNUM(ND10,ND12),
     6          IDRSNUM(ND10,ND12),COORDLIST(NUMCOORD,ND12)
      DIMENSION IDMDL(4,ND10,ND12),JEND(ND10,ND12)
      DIMENSION ID(4)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7),IS2BMAP(ND7)
      DIMENSION JBIRG2(ND10,ND12),JBIRG4(ND10,ND12),JBIRG5(ND10,ND12),
     1          JGROUPS(ND12),JGROUPS2(ND12),JGROUPS4(ND12),
     2          JGROUPS5(ND12)
      DIMENSION ISTOP(2),IP(25)
C
      IER=0
      NTOTRG=0
      NTOTBG=0
      JCHECK=0
      JPACK=0
      JGROUPS(1:ND12)=0
      JGROUPS2(1:ND12)=0
      JGROUPS4(1:ND12)=0
      JGROUPS5(1:ND12)=0
C
C        INITIALIZE 'BMAP( )' ARRAY TO FALSE.
C
      DO 25 J=1,ND5
         BMAP(J)=.FALSE.
 25   CONTINUE 
C
C        OPEN THE OUTPUT FILE WHERE ALL PROCESSED DATA
C        WILL BE WRITTEN OUT IN GRIB2.
C  
CCC         CHANGED BAOPEN FOR OPERATIONAL CONCERNS
CCC      CALL BAOPEN(KFILGO,OUTGRD,IRET)
CCC
CINTEL
      ENVVAR='FORT  '
      WRITE(ENVVAR(5:6),FMT='(I2)')KFILGO
C      ENVVAR='XLFUNIT_  '
C      WRITE(ENVVAR(9:10),FMT='(I2)')KFILGO
CINTEL
      CALL GETENV(ENVVAR,FILEO)
      CALL BAOPEN(KFILGO,FILEO,IRET)
C
      IF(IRET.NE.0) THEN
         WRITE(KFILDO,32) KFILGO,IRET
 32      FORMAT(/,' ****PROBLEM OPENING GRIB2 OUTPUT FILE WITH UNIT',
     1            ' NUMBER ',I2,'.  IRET FROM BAOPEN =',I3,
     2            '.  STOP 32 IN RDTDLPK.F')
         CALL W3TAGE('RDTDLPK')
         STOP 32
      ENDIF
C
C        READ THE INFORMATION CONTAINED IN THE INDICATOR AND 
C        IDENTIFICATION FILE (SECTIONS 0-1).
C
      CALL RDSECT1(KFILDO,KFILSC1,LISTSEC0,LISTSEC1,IP(12))
C
C        ALLOCATE SPACE TO THE LOCAL USE SECTION ARRAY.
C        WHEN THE LOCAL USE SECTION IS NOT TO BE INCLUDED,
C        ISCT2LEN CAN BE SET IN THE DRIVER TO BE A VERY SMALL
C        VALUE (I.E., 1) TO CONSERVE MEMORY.
C               
      ALLOCATE(FSCT2(ISCT2LEN,ND10,ND12),STAT=IS)
C
      IF(IS.NE.0) THEN
         WRITE(KFILDO,34) IS
  34     FORMAT(/,' ****PROBLEM ALLOCATING LOCAL USE ARRAY.',
     1            ' STOP 34 IN RDTDLPK.  IOSTAT=',I4)
         STOP 34
      ENDIF
C
C        CHECK IF THE LOCAL USE SECTION IS TO BE INCLUDED. IF SO,
C        READ THE INFORMATION CONTAINED IN THE LOCAL USE FILE
C        (SECTION 2).
C
      IF(JLCL.EQ.1) THEN
         CALL RDSECT2(KFILDO,KFILSC2,ISCT2LEN,FSCT2,NFSCT2,
     1                ND10,ND12,IP(13),JBIRG2,NGROUPS2,JGROUPS2)
      ENDIF
C
C        READ IN THE INFORMATION CONTAINED IN THE GRID DEFINITION FILE.
C
      CALL RDSECT3(KFILDO,KFILSC3,MPROJ,JGRID,IGDS,IGDSTMPL,
     1             IGDSTMPLEN,JGPLAIN,ND11,IP(14))
C
C        READ THE INFORMATION CONTAINED IN THE PRODUCT DEFINITION FILE.
C
      CALL RDSECT4(KFILDO,KFILSC4,IDMDL,JPLAIN,IPDSNUM,
     1             IPDSTMPL,IPDSTMPLEN,ND10,ND12,IP(15),
     2             JBIRG4,NGROUPS4,JGROUPS4,ISTOP)
C
C        READ THE INFORMATION CONTAINED IN THE DATA REPRESENTATION FILE.
C
      CALL RDSECT5(KFILDO,KFILSC5,IDRSNUM,IDRSTMPL,
     1             IDRSTMPLEN,ND10,ND12,IP(16),JBIRG5,
     2             NGROUPS5,JGROUPS5)
C
C        CHECK THAT THE NUMBER OF MESSAGES READ FROM SECTIONS 2, 4
C        AND 5 ARE EQUAL.  IF THEY ARE NOT, TERMINATE THE PROGRAM.
C
       IF(JLCL.EQ.1) THEN
C
          IF((NGROUPS2.NE.NGROUPS4).OR.(NGROUPS2.NE.NGROUPS5).OR.
     1       (NGROUPS4.NE.NGROUPS5)) THEN
             WRITE(KFILDO,35)
 35          FORMAT(/,' ****THE TOTAL NUMBER OF MESSAGE ENTRIES',
     1                ' LISTED IN THE GRIB2 DESCRIPTOR FILES ARE',
     2                ' NOT EQUAL.',/,5X,'STOP 35 IN RDTDLPK.')
              STOP 35
          ENDIF
       ELSE
          IF(NGROUPS4.NE.NGROUPS5) THEN
             WRITE(KFILDO,36)
 36          FORMAT(/,' ****THE TOTAL NUMBER OF MESSAGE ENTRIES',
     1                ' LISTED IN THE GRIB2 DESCRIPTOR FILES ARE',
     2                ' NOT EQUAL.',/,5X,'STOP 36 IN RDTDLPK.')
             STOP 36
          ENDIF
       ENDIF
C
      NGROUPS=NGROUPS4 
C
C        CHECK THAT THE NUMBER OF ENTRIES READ FROM SECTIONS 2, 4
C        AND 5 ARE EQUAL.  IF THEY ARE NOT TERMINATE THE PROGRAM.
C
      DO 40 J=1,NGROUPS
C
         IF(JLCL.EQ.1) THEN
            IF((JGROUPS2(J).NE.JGROUPS4(J)).OR.
     1         (JGROUPS2(J).NE.JGROUPS5(J)).OR.
     2         (JGROUPS4(J).NE.JGROUPS5(J))) THEN
               WRITE(KFILDO,37) J
 37            FORMAT(/,' ****THE NUMBER OF ENTRIES FOR MESSAGE ',I4,
     1               ' LISTED IN THE INPUT FILES PERTAINING TO',
     2               ' SECTIONS 2, 4, AND 5 ARE NOT EQUAL.  STOP 37 IN',
     3               ' RDTDLPK.')
               STOP 37
            ENDIF
         ELSE
            IF(JGROUPS4(J).NE.JGROUPS5(J)) THEN
               WRITE(KFILDO,38) J
 38            FORMAT(/,' ****THE NUMBER OF ENTRIES FOR MESSAGE ',I4,
     1               ' LISTED IN THE INPUT FILES PERTAINING TO',
     2               ' SECTIONS 4 AND 5 ARE NOT EQUAL.  STOP 38 IN',
     3               ' RDTDLPK.')
               STOP 38
            ENDIF
         ENDIF
 40   CONTINUE
C
      DO 50 J=1,NGROUPS
         JGROUPS(J)=JGROUPS4(J)
 50   CONTINUE
C
C        ELIMINATE DUPLICATE ENTRIES FROM EACH GROUP IN 
C        SECTIONS 2 (IF PRESENT), 4 AND 5.  FLAG THE END OF EACH GROUP. 
C
      CALL CHKDUP(KFILDO,FSCT2,NFSCT2,ISCT2LEN,JBIRG2,
     1            IDMDL,JPLAIN,IPDSNUM,IPDSTMPL,
     2            IPDSTMPLEN,JBIRG4,IDRSNUM,IDRSTMPL,
     3            IDRSTMPLEN,JBIRG5,NGROUPS,JGROUPS,
     4            JEND,ND10,ND12,ISTOP)
C
C        CHECK IF A BITMAP IS TO BE PROCESSED.  IF SO, RETRIEVE
C        THE BITMAP.
C
      IF(JFLAG.EQ.1) THEN
C
         ALLOCATE(IPACK(ND5),STAT=IS)
C
            IF(IS.NE.0) THEN
               WRITE(KFILDO,54) IS
  54           FORMAT(/,' ****PROBLEM ALLOCATING IPACK ARRAY.',
     1                  ' STOP 54 IN RDTDLPK.  IOSTAT=',I4)
               STOP 54
            ENDIF
C
         CALL CONSTG(KFILDO,KFILBM,BMPNAM,ID,IPACK,IWORK,
     1               BMAPDATA,ND5,IS0,IS1,IS2BMAP,IS4,ND7,
     2               ISTAV,L3264B,IER)
C
         IF(IER.NE.0) THEN
            WRITE(KFILDO,55) (ID(N),N=1,4)
 55         FORMAT(/,' ****BITMAP VARIABLE ',3(I9.9,1X),
     1              I10.10,' IS NOT FOUND.',/,5X,'PROCESSING', 
     2              ' CANNOT CONTINUE.  STOP 55 IN RDTDLPK.')
            CALL W3TAGE('RDTDLPK')
            STOP 55
         ENDIF
C
C           PLACE THE REAL VALUES RETURNED FROM 'CONSTG' INTO A 
C           LOGICAL VARIABLE 'BMAP( )'.  THIS ACTION IS TAKEN
C           ONLY IF A BITMAP IS TO BE PLACED INTO GRIB2.
C
         IF(JBMAP.EQ.1) THEN
            DO 60 J=1,IS2BMAP(3)*IS2BMAP(4)
               IF(INT(BMAPDATA(J)).EQ.1) BMAP(J)=.TRUE.
 60         CONTINUE
         ENDIF 
C
C           IF THE USER DESIRES A PRINT OF THE BITMAP VALUES
C           AS EXTRACTED FROM THE TDLPACK, WRITE THE VALUES
C           TO IP(18). 
C
         IF(IP(18).NE.0) THEN
            WRITE(IP(18),63) (ID(N),N=1,4),JDATE
 63         FORMAT(/,' BITMAP VALUES FOR VARIABLE',I11.9,
     1             3I11,' FOR DATE',I12/)
            DO 67 JY=1,IS2BMAP(4)
               WRITE(IP(18),65)(BMAPDATA(KK),KK=(IS2BMAP(4)-JY)*
     1                          IS2BMAP(3)+1,(IS2BMAP(4)-JY)*
     2                          IS2BMAP(3)+IS2BMAP(3))
 65            FORMAT(' ',10F10.1/(' ',10F10.1))
 67         CONTINUE
         ENDIF
C
         DEALLOCATE(IPACK)
C     
      ENDIF
C
C        RETRIEVE THE INFORMATION FOR THE PARTICULAR PRODUCT BEING 
C        PROCESSED.  FIRST CHECK IF AN EXTERNAL TDLPACK RANDOM ACCESS 
C        FILE IS TO BE PROCESSED.  ALLOCATE 'CGRIB( )' FOR EACH MESSAGE
C        AND 'IPACK( )' FOR EACH FIELD.  IF THE MEMEORY ALLOCATION IS
C        DONE IN THIS WAY, MEMORY PROBLEMS ARISE WHEN TRYING TO READ
C        TDLPACK DATA AND WHEN PACKING A LARGE NUMBER OF FIELDS INTO
C        ONE MESSAGE.
C
      DO 95 J=1,NGROUPS
C
         JPACK=0
C        
         ALLOCATE(CGRIB(LCGRIB),STAT=IS)
C
         IF(IS.NE.0) THEN
            WRITE(KFILDO,96) IS
  96        FORMAT(/,' ****PROBLEM ALLOCATING CGRIB ARRAY.',
     1                  ' STOP 96 IN RDTDLPK.  IOSTAT=',I4)
            STOP 96
         ENDIF
C         
         DO 90 K=1,JGROUPS(J)
C
            ALLOCATE(IPACK(ND5),STAT=IS)
C
            IF(IS.NE.0) THEN
               WRITE(KFILDO,97) IS
  97           FORMAT(/,' ****PROBLEM ALLOCATING IPACK ARRAY.',
     1                  ' STOP 97 IN RDTDLPK.  IOSTAT=',I4)
               STOP 97
            ENDIF
C
            CALL CONSTG(KFILDO,KFILRA,RACESS,IDMDL(1,K,J),
     1                  IPACK,IWORK,FLD,ND5,IS0,IS1,IS2,IS4,
     2                  ND7,ISTAV,L3264B,IER)
C
            IF(IER.NE.0) THEN
               WRITE(KFILDO,69) (IDMDL(N,K,J),N=1,4),J
 69            FORMAT(/,' ****VARIABLE ',3(I9.9,1X),I10.10,
     1                  ' IN MESSAGE ',I4,' IS NOT FOUND AND',
     2                  ' WILL NOT BE PROCESSED.')
               ISTOP(2)=ISTOP(2)+1
C
C                 CHECK IF THE LAST ENTRY IN THE GROUP TERMINATED
C                 BY A '7777' IS THE ENTRY THAT HAS AN 'IER' NOT 
C                 EQUAL TO ZERO.  IF THE 'IER' IN LAST ENTRY IN THE
C                 GROUP IS NOT EQUAL TO ZERO, CALL THE SUBROUTINE 
C                 "GRIBCLOSE" ADD THE FINAL SECTION 8 TO THE GRIB2 
C                 MESSAGE, UPDATE THE LENGTH OF THE MESSAGE AND 
C                 WRITE THE MESSAGE OUT TO OUTPUT FILE 'KFILGO'.
C                 
               IF((JPACK.GE.1).AND.(JEND(K,J).EQ.1))THEN 
                  CALL GRIBCLOSE(KFILDO,KFILGO,CGRIB,LCGRIB,NTOTBG)
               ENDIF
C
            ELSE
C
C                 ENSURE THAT THE DATE ON THE EXTERNAL TDLPACK
C                 RANDOM ACCESS FILE IS THE SAME AS THE DATE
C                 FOUND IN THE DATE LIST.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C************FOR OPERATIONS***********************
C
C              IF(JDATE.NE.IS1(8)) THEN
C                 WRITE(KFILDO,75) JDATE,IS1(8)
C 75              FORMAT(/,' ****THE DATE PLACED IN THE INPUT',
C     1                    ' DATE LIST, ',I10,' DOES NOT MATCH',/,
C     2                    5X,'THE DATE,',I10,' FOUND IN THE',
C     3                    ' INPUT RANDOM ACCESS FILE.',/,5X, 
C     4                    'STOP 75 IN RDTDLPK.')
C                 CALL W3TAGE('RDTDLPK')
C                 STOP 75
C              ENDIF
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C                 ENSURE THAT THE GRID CHARACTERISTICS FOUND
C                 ON THE RANDOM ACCESS FILE MATCH THOSE FOUND
C                 IN THE GRID DEFINITION FILE.
C
               CALL CHKGRID(KFILDO,IS2,ND7,MPROJ,
     1                      IGDSTMPL(1,JGRID),IGDSTMPLEN)
C
C                 CHECK THAT THE GRID CHARACTERISTICS IN THE
C                 GRIDDED BITMAP RANDOM ACCESS FILE ARE THE
C                 SAME AS THE GRID CHARACTERISTICS DEFINED 
C                 IN THE INPUT TDLPACK DATA FILE.  THIS 
C                 CROSS-CHECK IS NECESSARY TO ENSURE THAT IF 
C                 A GRIDDED BITMAP RANDOM ACCESS FILE IS USED,
C                 ITS GRID CHARACTERISTICS ARE ALSO CONSISTENT
C                 WITH THE GRID CHARACTERISTICS FOUND IN THE 
C                 GRID DEFINITION FILE (INPUT FOR SECTION 3).
C                 PERFORM THIS CHECK ONCE.
C
               IF((JFLAG.EQ.1).AND.(JCHECK.EQ.0)) THEN
                  CALL CHKGRID4(KFILDO,IS2,IS2BMAP,ND7)
                  JCHECK=1
               ENDIF
C
C                 IF A BITMAP IS PROVIDED IN U135.CN, MASK THE
C                 GRIDDED DATA.  SINCE IT IS UNSAFE TO EQUATE REAL
C                 VALUES (A "REAL" DANGER), TAKE THE 'NINT' OF THE
C                 DATA WHICH WILL ONLY HAVE A VALUE OF ZERO OR ONE.
C                 ASSIGN THE SECONDARY MISSING VALUE TO THOSE POINTS
C                 ON THE GRID CORRESPONDING TO A BITMAP VALUE OF ZERO.
C
               IF(JFLAG.EQ.1) THEN
                  DO 80 JJ=1,IS2(3)*IS2(4)
                     IF(NINT(BMAPDATA(JJ)).EQ.0) FLD(JJ)=BMAPVAL
 80               CONTINUE
               ENDIF
C
C                 CHANGE THE SECONDARY MISSING VALUE FROM '9997' TO
C                 'XMISSS'.
C
               DO 83 JJ=1,IS2(3)*IS2(4)
                  IF(INT(FLD(JJ)).EQ.9997) FLD(JJ)=XMISSS
 83            CONTINUE
C
C                 PACK THE DATA INTO GRIB2 FORMAT.
C
               CALL PACKGRIB2(KFILDO,JDATE,CGRIB,LCGRIB,FLD,LISTSEC0,
     1                        LISTSEC1,JLCL,FSCT2(1,K,J),NFSCT2(K,J),
     2                        IGDS(1,JGRID),IGDSTMPL(1,JGRID),
     3                        IGDSTMPLEN,IDEFLIST,IDEFNUM,
     4                        COORDLIST,NUMCOORD,IPDSNUM(K,J),
     5                        IPDSTMPL(1,K,J),IPDSTMPLEN,
     6                        IDRSNUM(K,J),IDRSTMPL(1,K,J),
     7                        IDRSTMPLEN,BMAP,IDMDL(1,K,J),
     8                        IS2(3),IS2(4),K,J,JPACK,JBMAP,
     9                        ISTOP)
C
C                 IF THE USER DESIRES A PRINT OF THE TDLPACK INPUT
C                 GRIDDED VALUES, WRITE THE VALUES TO IP(17).  THE
C                 VALUES ARE WRITTEN TO THE NEAREST THOUSANDTHS PLACE.
C
               IF(IP(17).NE.0) THEN
                  WRITE(IP(17),85) (IDMDL(N,K,J),N=1,4),JDATE
 85               FORMAT(/,' INPUT GRIDPOINT VALUES FOR',
     1                     ' VARIABLE',I11.9,3I11,' FOR DATE',
     2                     I12/)
                  DO 87 JY=1,IS2(4)
                     WRITE(IP(17),86)(FLD(KK),KK=(IS2(4)-JY)*
     1                                IS2(3)+1,(IS2(4)-JY)*
     2                                IS2(3)+IS2(3))
 86                  FORMAT(' ',10F10.3/(' ',10F10.3))
 87               CONTINUE
               ENDIF
C
C                 TALLY THE NUMBER OF ENTRIES PACKED IN EACH GROUP.
C
               NTOTRG=NTOTRG+1
               JPACK=JPACK+1
C
C                 CHECK IF THE LAST ENTRY IN THE GROUP TERMINATED
C                 BY A '7777' IS THE ENTRY THAT HAS AN 'IER' NOT
C                 EQUAL TO ZERO.  IF THE 'IER' IN LAST ENTRY IN THE
C                 GROUP IS NOT EQUAL TO ZERO, CALL THE SUBROUTINE
C                 "GRIBCLOSE" ADD THE FINAL SECTION 8 TO THE GRIB2
C                 MESSAGE, UPDATE THE LENGTH OF THE MESSAGE AND
C                 WRITE THE MESSAGE OUT TO OUTPUT FILE 'KFILGO'.
C
               IF((JPACK.GE.1).AND.(JEND(K,J).EQ.1))THEN
                  CALL GRIBCLOSE(KFILDO,KFILGO,CGRIB,LCGRIB,NTOTBG)
               ENDIF
C 
            ENDIF
C
            DEALLOCATE(IPACK)
C
 90      CONTINUE
C
         DEALLOCATE(CGRIB)
C
 95   CONTINUE
C
C        DEALLOCATE LOCAL USE ARRAY.
C
      DEALLOCATE(FSCT2)
C
C        AFTER ALL VARIABLES HAVE BEEN PROCESSED AND CONVERTED
C        TO GRIB2, EXIT THE PROGRAM.
C
      CALL BACLOSE(KFILGO,IRET)
C
      IF(IRET.NE.0) THEN
         WRITE(KFILDO,100) KFILGO
 100     FORMAT(/,' ****PROBLEM CLOSING GRIB2 OUTPUT FILE ON UNIT',
     1            I3,'.')
      ENDIF
C
      RETURN
      END
