      SUBROUTINE DISTAP(KFILDO,KFIL10,KFILAO,IP12,IP15,
     1                 KFILRA,RACESS,NUMRA,
     2                 ID,IDPARS,JD,TRESHL,TRESHU,ITAU,NVRBL,
     3                 NDATE,CCALL,ISDATA,SDATA,ND1,NSTA,
     4                 XDATA,SDDATA,ND2,KER,ISD,SD,DS,NN,M,
     5                 ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     6                 LSTORE,ND9,LITEMS,CORE,ND10,
     7                 NBLOCK,NFETCH,
     8                 IS0,IS1,IS2,IS4,ND7,
     9                 XAXIS,PDF,CDF,ND11,NPCDF,CDFTH,XCDF,NCDFTH,
     A                 L3264B,L3264W,ISTOP,IER)
C
C        SEPTEMBER 2009  WAGNER    CREATED FROM DISTF
C                                  BEFORE KERN=2
C           JULY   2010  ZYLSTRA   MODIFIED TO CALCULATE HEAT INDEX
C                                  FROM FORECASTED TEMPERATURE AND
C                                  FORECASTED RELATIVE HUMIDITY AND
C                                  TO CALCULATE WIND CHILL FROM
C                                  FORECASTED TEMPERATURE AND FORECASTED
C                                  WIND SPEED.  ADDED FUNCTION HTINDX.
C        OCTOBER   2010  ZYLSTRA   MODIFIED TO CALCULATE HEAT INDEX 
C                                  FROM FORECASTED TEMPERATURE AND
C                                  FORECASTED DEWPOINT TEMPERATURE.
C                                  ADDED FUNCTIONS RELHUM AND WCHILL.
C       NOVEMBER   2010  VEENHUIS  MODIFIED IF STATEMENT NEAR LINE 361
C                                  TO INCLUDE A CHECK FOR THE 'G' AS THIS
C                                  IS NEEDED TO HANDLE MULTIPLE MODELS.
C        DECEMBER  2010  VEENHUIS  MULTIPLE CHANGES TO CORRECT PREXISTING ERRORS.
C                                  THE ORIGINAL DISTAP CODE WAS BASED ON AN EARLIER
C                                  VERSION OF DISTF WHICH HAD SOME ISSUES. THE FIXES
C                                  INCLUDE:
C                                  1.) ARRAYS INCORRECTLY SIZE WITH ND1 ARE NOW SIZED
C                                      WITH ND2
C                                  2.) CHECKS TO MAKE SURE DIVISION BY ZERO WILL NOT
C                                      OCCUR.  
C                                  3.) INCREASED THE STANDARD DEVIATION CHECK FROM
C                                      9 TO 12.
C          DECEMBER 2010 VEENHUIS  REMOVED RETREIVALS OF STANDARD ERROR FOR WIND SPEED
C                                  AND DEWPOINT SINCE THESE ARE NOT USED.  MODIFIED
C                                  A PRINT STATMENT.  REMOVED ARRAYS WSSD(ND1,ND2) AND
C                                  DPSD(ND1,ND2).
C          DECEMBER 2010 VEENHUIS  CHANGED THE ID OF THE SUFACE TEMPERATURE TO 202000
C          JANUARY  2011 VEENHUIS  MODIFED CHECK THAT MAKES SURE ND11 IS NOT EXCEEDED.
C                                  THE CODE NOW SKIPS TO THE NEXT STATION IF THIS 
C                                  OCCURS.
C          MARCH    2011 VEENHUIS  CODE WAS NOT CORRECTLY PASSING BACK THE MEAN OF
C                                  THE DISTRIBUTION. INSERTED CODE TO DO THIS.
C
C        PURPOSE
C            DISTAP IS CALLED FROM OPTY AND COMPUTES A DISTRIBUTION
C            FUNCTION FOR THE APPARENT TEMPERATURE FROM THE 
C            TEMPERATURE, WIND SPEED, AND DEWPOINT TEMPERATURE FORECASTS.
C
C        DATA SET USE
C            KFILDO    - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10    - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM
C                        ACCESS.  (INPUT-OUTPUT) 
C            KFILAO    - UNIT NUMBER OF ASCII OUTPUT FILE.  ZERO MEANS
C                        OUTPUT WILL NOT BE WRITTEN.  (OUTPUT)
C            IP12      - LIST OF STATIONS ON THE INPUT FILES.  (OUTPUT)
C            IP15      - LIST OF DATA IN DIST.  (OUTPUT)
C            KFILRA(J) - UNIT NUMBERS FOR EXTERNAL RANDOM ACCESS FILES
C                        (J=1,5).  (INPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              KFILAO = UNIT NUMBER OF ASCII OUTPUT FILE.
C                       ZERO MEANS OUTPUT WILL NOT BE WRITTEN.  (INPUT)
C                IP12 = INDICATES WHETHER (>0) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE EXTERNAL RANDOM ACCESS FILES
C                       WILL BE LISTED TO UNIT IP12.  (INPUT)
C                IP15 = LIST OF DATA IN DIST.  (INPUT)
C           KFILRA(J) = THE UNIT NUMBERS FOR THE MOS-2000 EXTERNAL
C                       RANDOM ACCESS FILES (J=1,NUMRA)
C           RACESS(J) = THE FILE NAME FOR THE MOS-2000 EXTERNAL RANDOM
C                       ACCESS FILE (J=1,NUMRA).  (CHARACTER*60)
C               NUMRA = THE NUMBER OF VALUES IN KFILRA( ) AND RACESS( ).
C                       (INPUT)
C             ID(J,N) = THE VARIABLE ID (J=1,4) (N=1,NVRBL).  (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE
C                       VARIABLE ID CORRESPONDING TO ID( ) (J=1,15)
C                       (N=1,NVRBL).
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY
C                            1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK
C                            IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C                       (INPUT)
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID (J=1,4)
C                       (N=1,NVRBL).  THIS IS THE SAME AS ID(J), EXCEPT
C                       THAT THE FOLLOWING PORTIONS ARE OMITTED:
C                       B = IDPARS(3),
C                       G = IDPARS(15), AND
C                       THRESH.
C                       (INPUT)
C           TRESHL(N) = THE LOWER BINARY THRESHOLD ASSOCIATED WITH 
C                       IDPARS( ,N) (N=1,NVRBL).  (INPUT)
C           TRESHU(N) = THE UPPER BINARY THRESHOLD ASSOCIATED WITH
C                       IDPARS( ,N) (N=1,NVRBL).  (INPUT)
C             ITAU(N) = THE NUMBER OF HOURS AHEAD TO FIND A VARIABLE
C                       (N=1,NVRBL).  THIS DOES NOT APPLY TO ALL
C                       SUBROUTINES.  NO PRESENT USE; SHOULD BE ZERO.
C                       (INPUT)
C               NVRBL = THE NUMBER OF VARIABLES IN ID( , ), ETC.
C                       (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH VARIABLE IS NEEDED.
C                       (INPUT)
C            CCALL(K) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (K=1,NSTA).  ALL STATION DATA ARE
C                       KEYED TO THIS LIST.  (CHARACTER*8)  (INPUT)
C           ISDATA(K) = WORK ARRAY (K=1,ND1). (INTERNAL)
C            SDATA(K) = WORK ARRAY (K=1,ND1).  (INTERNAL)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT
C                       WITH.  (INPUT)
C                NSTA = NUMBER OF STATIONS OR LOCATIONS BEING DEALT
C                       WITH.  (INPUT)
C          XDATA(K,L) = THE ARRAY USED FOR VECTOR VALUES (K=1,ND1) 
C                       (L=1,ND2).  THE COLUMNS HOLD THE VALUES FOR
C                       THE M MEMBERS (SEE M BELOW).
C                       (INTERNAL/OUTPUT)
C         SDDATA(K,L) = USED FOR THE STANDARD ERRORS (K=1,ND1)
C                       (L=1,ND2).  THE COLUMNS HOLD THE SD'S FOR THE
C                       M MEMBERS (SEE M BELOW).  (INTERNAL/OUTPUT)
C                 ND2 = MAXIMUM NUMBER OF ENSEMBLE MEMBERS.  (INPUT)
C              KER(N) = DESIGNATES THE KERNEL TO BE USED FOR VARIABLE N
C                       (N=1,ND4).
C                       1 = NORMAL (GAUSIAN).
C                       (INPUT)
C              ISD(N) = DESIGNATES WHETHER THE KERNEL WIDTH FOR
C                       VARIABLE N (N=1,ND4) IS TO BE TAKEN FROM SD( )
C                       IN THE VARIABLE RECORD OR FROM A PACKED INPUT
C                       RECORD.
C                       0 = COMES FROM PACKED RECORD;
C                       2 = WHEN THERE ARE MULTIPLE ENSEMBLES OR
C                           ONLY ONE ENSEMBLE AND SD( ) > 9, 
C                           CALL KERNELW; OTHERWISE, CALL KERNEL.
C                       3 = CALL SUBROUTINE SCALE3 TO SCALE THE
C                           DISPERSION OF THE KERNEL DENSITY OUTPUT
C                           TO APPROXIMATELY WHAT IT WOULD HAVE BEEN
C                           WITH A SINGLE RUN.
C                       (INPUT)
C               SD(N) = A FACTOR TO USE IN THE SPREAD ADJUSTMENT FOR
C                       MULTIPLE ENSEMBLES FOR THIS VARIABLE N
C                       (N=1,ND4).  (INPUT)
C               DS(N) = SCALING FACTOR FOR THE STANDARD DEVIATION FOR
C                       THIS VARIABLE (N=1,ND4).  (INPUT) 
C                  NN = ON INPUT, THE FIRST VARIABLE IN THE ID LIST NOT
C                       ALREADY USED.  THIS IS THE VARIABLE TO PROCESS.
C                       ON OUTPUT, THE FIRST VARIABLE IN THE ID LIST NOT
C                       USED.  WHEN ALL VARIABLES HAVE BEEN PROCESSED,
C                       NN IS RETURNED = 9999.  (INPUT/OUTPUT)
C                   M = THE NUMBER OF MEMBERS AVERAGED IN DISTAP.
C                       (OUTPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN 
C                       INTEGER VARIABLE (L=1,L3264W) (K=1,ND1).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       NEEDED IN CONST FOR ARGUMENT TO RDTDLM.
C                       EQUIVALENCED TO CCALLD( ).
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5).  EQUIVALENCED
C                       TO ICALLD( , ).  (INTERNAL)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), WORK( ), DATA( ), AND
C                       CALLD( ), AND SECOND DIMENSION OF ICALLD( , ).
C                       (INPUT)
C         LSTORE(L,J) = THE ARRAY TO HOLD INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS US THE RECORD NUMBER WHERE 
C                              THE DATA START.  NOTE THAT WHEN A FIELD 
C                              CANNOT BE STORED IN CORE( ), IT IS PUT
C                              ON DISK.  IT MAY BE THAT A LATER FIELD 
C                              WILL FIT, AND IT IS PUT IN CORE( ).
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDLPACK, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --THE NUMBER IN THE LIST OF INPUT SOURCES
C                              THIS VARIABLE CAME FROM.
C                       L=11 --FOR U715, THIS WILL BE 7777, INDICATING
C                              THE VARIABLE IS ALWAYS STORED IN THE
C                              INTERNAL STORAGE FACILITY.
C                       L=12 --US THE NUMBER OF HOURS THIS VARIABLE
C                              MUST BE KEPT.  LATER SET TO A DATE WHEN
C                              THIS VARIABLE CAN BE DISCARDED.
C                       (INPUT)
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , )
C                       FILLED.  (INPUT)
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA
C                       IDENTIFIED IN LSTORE( , ) (J=1,ND10).  WHEN
C                       CORE( ) IS FULL DATA ARE STORED ON DISK.
C                       (INPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.
C                       GFETCH KEEPS TRACK OF THIS AND RETURNS THE
C                       VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).
C                       (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).
C                       (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).
C                       (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4). 
C                       (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C            XAXIS(J) = THE DATA VALUES ALONG THE X-AXIS, EACH
C                       VALUE CORRESPONDING TO A VALUE IN PDF(J) AND
C                       CDF(J) (J=1,NPCDF).  (OUTPUT) 
C              PDF(J) = THE PDF WRITTEN TO UNIT KFILAO (J=1,NPCDF).
C                       (OUTPUT)
C              CDF(J) = THE CDF WRITTEN TO UNIT KFILAO (J=1,NPCDF).
C                       (OUTPUT) 
C                ND11 = THE MAXIMUM NUMBER OF VALUES IN XAXIS( ),
C                       PDF( ), AND CDF( ).  (INPUT)
C               NPCDF = THE NUMBER OF VALUES IN PDF( ), CDF( ), AND
C                       XAXIS( ).  (OUTPUT)
C            CDFTH(J) = THE THRESHOLDS, OR PROBABILITY LEVELS, FOR
C                       OUTPUTTING THE CDF VALUES (J=1,NCDFTH).
C                       (INPUT)
C           XCDF(K,J) = THE VALUES FOR STATION K (K=1,NSTA) OF THE CDF
C                       FOR EACH OF THE LEVELS IN CDFTH(J) (J=1,NCDFTH)
C                       (OUTPUT)
C              NCDFTH = NUMBER OF VALUES IN CDFTH( ) AND XCDF( ).
C                       (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2). 
C                       CALCULATED BY PARAMETER, BASED ON L3464B.
C                       (INPUT)
C            ISTOP(J) = FOR J=1, ISTOP IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT MAY BE FATAL.
C                       FOR J=2, ISTOP IS INCREMENTED BY 1 WHENEVER AN
C                       INPUT DATA RECORD IS NOT FOUND.
C                       FOR J=3, ISTOP IS INCREMENTED BY 1 WHENEVER AN
C                       AN UNUSUAL CIRCUMSTANCE OCCURS WHICH IS NOT FATAL.
C                       (INPUT/OUTPUT)
C                 IER = STATUS RETURN.
C                         0 = GOOD RETURN.
C                       777 = SD = 0 FOUND IN KERNEL.
C                       OTHER VALUES CAN COME FROM CALLED SUBROUTINES.
C                       (OUTPUT)
C               MDATE = NDATE UPDATED WITH ITAU( ).  NO REASON FOR
C                       ITAU( ) TO BE OTHER THAN ZERO.  NEEDED FOR 
C                       RETVEC.  (INTERNAL)
C            RDATA(J) = HOLDS THE SINGLE VALUE FORECASTS TO FURNISH
C                       TO KERNEL (J=1,ND1).  (AUTOMATIC)  (INTERNAL)
C                  MM = THE NUMBER OF VALUES IN RDATA( ) AND SDATA( ).
C                       THIS IS THE NUMBER OF ENSEMBLE MEMBERS BEING 
C                       PROCESSED.  (INTERNAL)
C                KERN = DETERMINES HOW THE PDF WILL BE ASSESSED
C 			1=TENTHS OF A DEGREE
C                       2=WHOLE DEGREES (INTERNAL)
C                 DIF = WIDTH OF THE BIN IN THE CDF (INTERNAL)
C              NSTART = STARTING POSITION OF THE CDF (INTERNAL)
C                 TID = ID ASSOCIATED WITH THE PARALLEL PROCESS
C			(INTERNAL)
C                RMAX = THE MAXIMUM VALUE OF RDATA() (INTERNAL)
C                RMIN = THE MINIMUM VALUE OF RDATA() (INTERNAL)
C                SMAX = THE MAXIMUM VALUE OF SDATA() (INTERNAL)
C                SMIN = THE MINIMUM VALUE OF SDATA() (INTERNAL)
C                 FAC = THE XAXIS IN XAXIS( ) WILL BE MODIFIED BY
C                       THE FACTOR FAC.  THIS IS TO CORRECT FOR
C                       OVERDISPERSION.  IT COULD BE USED FOR
C                       UNDERDISPERSION IF NEEDED.  (INTERNAL)
C             FMAXVAL = MAXIMUM XAXIS VALUE USED WHEN CALCULATING THE
C			KERNELS (INTERNAL)
C             FMINVAL = MINIMUM XAXIS VALUE USED WHEN CALCULATING THE
C                       KERNELS (INTERNAL)
C                RFAC = USED TO PRESERVE THE TENTHS DIGIT WHEN NECESSARY
C			(INTERNAL)
C            TDATA(J) = ARRAY TO HOLD THE ENSEMBLE VALUES (INTERNAL)
C              TSD(J) = ARRAY TO HOLD THE STANDARD DEVIATIONS (INTERNAL)
C                 LOC = CURRENT LOCATION OF THE PDF (INTERNAL)
C              FACTOR = THE CONSTANT MULTIPLIER FOR THE NORMAL DENSITY.
C			FOR THIS BASIC DENSITY, THE NUMBER OF CASES IS 
C			NOT RELEVANT. (INTERNAL)
C            TWOSIGSQ = THE DIVISION IN THE EXPONENT FOR THE NORMAL
C			DENSITY (INTERNAL)
C 	          TOT = SUMMATION OF THE PDF (INTERNAL)
C		 TOT2 = HALF THE SUMMATION OF THE PDF (INTERNAL)
C                CMED = PERCENT MEDIAN OF THE PDF (INTERNAL)
C              TOTJM1 = PROBABILITY AT THE MEDIAN OF THE PDF
C			(INTERNAL)
C                 X50 = XAXIS LOCATION OF THE MEAN OF THE PDF
C			(INTERNAL)
C                XMED = XAXIS LOCATION OF THE MEDIAN OF THE PDF
C                       (INTERNAL)
C
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES USED 
C            TIMPR, PRSID1, RETVEC
C
C        NONSYSTEM FUNCTIONS USED
C            WCHILL, HTINDX, RELHUM
C
      CHARACTER*8 CCALL(ND1)
      CHARACTER*8 CCALLD(ND5)
      CHARACTER*60 RACESS(5)
C      INTEGER TID, OMP_GET_NUM_THREADS,NTHREADS, OMP_GET_THREAD_NUM
C
      DIMENSION ISDATA(ND1),SDATA(ND2)
      DIMENSION RDATA(ND2)
C        RDATA( ), AND TDATA ( ) ARE AUTOMATIC ARRAYS
      DIMENSION XDATA(ND1,ND2),SDDATA(ND1,ND2)
      DIMENSION WSDATA(ND1,ND2)
      DIMENSION DPDATA(ND1,ND2)
      DIMENSION TDATA(ND2),TSD(ND2)
      DIMENSION ID(4,NVRBL),IDPARS(15,NVRBL),
     1          TRESHL(NVRBL),TRESHU(NVRBL),JD(4,NVRBL),ITAU(NVRBL),
     2          KER(NVRBL),ISD(NVRBL),SD(NVRBL),DS(NVRBL)
      DIMENSION ICALLD(L3264W,ND5),IPACK(ND5),IWORK(ND5),DATA(ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9)
      DIMENSION CORE(ND10)
      DIMENSION CDFTH(NCDFTH),XCDF(ND1,NCDFTH)
      DIMENSION XAXIS(ND11),PDF(ND11),CDF(ND11)
      DIMENSION KFILRA(5),LD(4),LDPARS(15),ISTOP(3)
C
      DATA JFIRST/0/
      SAVE JFIRST,NDATES
C
      XLOW=0
C
C        NDATE IS SAVED IN NDATES ON THE FIRST ENTRY SO THAT
C        DIAGNOSTIC 212 WON'T PRINT AFTER THE FIRST DAY.
C
      IF(JFIRST.EQ.0)THEN
         NDATES=NDATE
         JFIRST=1
      ENDIF
C
C        GET SINGLE VALUE ESTIMATES AND THE STANDARD DEVIATION FOR
C        EACH ENSEMBLE MEMBER (DENOTED BY DD).  THIS CAN BE A SINGLE
C        RUN WITH OR WITHOUT AN ACCOMPANYING STANDARD DEVIATION
C        PACKED RECORD.
C
      IFIRST=0
      NNSAVE=9999
C        INITIALIZE NNSAVE IN CASE ALL DATA RETRIEVES ARE SUCCESSFUL.
      M=1
C        M IS THE COLUMN IN XDATA( , ) RECEIVING THE DATA.
C
      DO 200 N=NN,NVRBL
C
C        NVRBL IS THE NUMBER OF VALUES IN THE ID( , ) LIST.
C        NN IS THE LOCATION OF THE FIRST ONE NOT USED.
      MDATE=NDATE+ITAU(N)
C        I KNOW OF NO CURRENT USE FOR TAU NE 0, BUT IS CARRIED ALONG.
C
C        GET THE SINGLE VALUE FORECAST AND ITS ASSOCIATED
C        STANDARD DEVIATION FOR IDS THAT ARE THE SAME
C        EXCEPT FOR THE DD AND G.
C 
      IF(ID(1,NN)/100.EQ.ID(1,N)/100.AND.
     1   ID(2,NN).EQ.ID(2,N).AND.
     2   IDPARS(8,NN).EQ.IDPARS(8,N).AND.
     3   IDPARS(10,NN).EQ.IDPARS(10,N).AND.
     4   IDPARS(11,NN).EQ.IDPARS(11,N).AND.
     5   IDPARS(12,NN)-IDPARS(9,NN).EQ.IDPARS(12,N)-IDPARS(9,N).AND.
     6   ID(4,NN)/10 .EQ. ID(4,N)/10)THEN
C
C           THE ID OF VARIABLE N AGREES WITH THAT OF THE BASE VARIABLE
C           NN, EXCEPT DD, R, TAU, AND G.  THE TEST ASSURES THAT THE DATES
C           AND PROJECTIONS ARE SUCH THAT THE FORECASTS VERIFY AT THE
C           SAME TIME.  NORMALLY, IDPARS(9,NN) WILL BE ZERO.
C
C           RETRIEVE THE SINGLE VALUE SURFACE TEMPERATURE FORECASTS (deg F).
C
         LD(1)=202000000+(IDPARS(3,N)*100)+IDPARS(4,N)
         LD(2)=ID(2,N)
         LD(3)=ID(3,N)
         LD(4)=ID(4,N)
         CALL PRSID1(KFILDO,LD,LDPARS)
         ITIME=IDPARS(9,N)
C           ITIME IS USED IN GFETCH.  IT IS CALLED ITAU IN RETVEC. 
         IER=0 
         CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,XDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,IER)
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,125)(LD(J),J=1,4),NDATE
  125       FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN DISTAP',
     1             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
C         ELSE
C            IF(LDPARS(8).EQ.4)THEN
C               CALL OPTX(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
C     1               LD,LDPARS,TRESHL(N),JD(1,N),ITAU(N),
C     2               NDATE,MDATE,CCALL,ISDATA,XDATA(1,M),ND1,NCAT,NSTA,
C     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
C     4               LSTORE,ND9,LITEMS,CORE,ND10,
C     5               LASTL,LASTD,NBLOCK,NSTORE,NFETCH,
C     6               IS0,IS1,IS2,IS4,ND7,
C     7               L3264B,L3264W,ISTAB,IER)
C              IF IER IS RETURNED NON-ZERO, THE DATA IN XDATA( ,M)
C              WILL BE SET TO MISSING, BUT THE PROCESS WILL CONTINUE.
C            ENDIF
         ENDIF
         IIER=IER
C
C           EVEN IF THE VARIABLE IS NOT RETRIEVED, THE SE RECORD
C           IS TRIED SO THAT NSTORE( , ) CAN BE INITIALIZED CORRECTLY.
C
C           RETRIEVE THE STANDARD ERRORS.  THE STANDARD ERRORS HAVE
C           THE SAME ID EXCEPT FOR 200 IN THE LLLL PORTION OF WORD 2.
C
         LD(2)=ID(2,N)+002000000
         CALL PRSID1(KFILDO,LD,LDPARS)
         JER=0
         CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,SDDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,JER)
C
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C           NOTE THAT JER RATHER THAN IER IS USED IN THE CALL.
C
C
C	    THE STANDARD DEVIATION MAY NOT HAVE THE SAME FIRST WORD
C	    AS THE RELATED ELEMENT.  CHECK ONE MORE TIME FOR IT.
C
         IF(JER.NE.0)THEN
            LD(1)=ID(1,N)-20000
            CALL PRSID1(KFILDO,LD,LDPARS)
            CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,SDDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,JER)
         ENDIF
C
         IF(JER.NE.0)THEN
            WRITE(KFILDO,135)(LD(J),J=1,4),NDATE
  135       FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN DISTAP',
     1                2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
         ENDIF
         JJER=JER
C
C           RETRIEVE THE SINGLE VALUE WIND SPEED FORECASTS (kts).
C
         LD(1)=204210000+(IDPARS(3,N)*100)+IDPARS(4,N)
         LD(2)=ID(2,N)
         LD(3)=ID(3,N)
         LD(4)=ID(4,N)
         CALL PRSID1(KFILDO,LD,LDPARS)
         ITIME=IDPARS(9,N)
C           ITIME IS USED IN GFETCH.  IT IS CALLED ITAU IN RETVEC. 
         IER=0 
         CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,WSDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,IER)
C
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,126)(LD(J),J=1,4),NDATE
  126       FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN DISTAP',
     1             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
         ENDIF
         IIER=IIER+IER
C
C           RETRIEVE THE SINGLE VALUE DEWPOINT TEMPERATURE FORECASTS (deg F).
C
         LD(1)=203000000+(IDPARS(3,N)*100)+IDPARS(4,N)
         LD(2)=ID(2,N)
         LD(3)=ID(3,N)
         LD(4)=ID(4,N)
         CALL PRSID1(KFILDO,LD,LDPARS)
         ITIME=IDPARS(9,N)
C           ITIME IS USED IN GFETCH.  IT IS CALLED ITAU IN RETVEC. 
         IER=0 
         CALL RETVEC(KFILDO,KFIL10,IP12,KFILRA,RACESS,NUMRA,
     1               LD,LDPARS,JD(1,N),ITIME,
     2               NDATE,MDATE,CCALL,ISDATA,DPDATA(1,M),ND1,NSTA,
     3               ICALLD,CCALLD,IPACK,IWORK,DATA,ND5,
     4               LSTORE,ND9,LITEMS,CORE,ND10,
     5               NBLOCK,NFETCH,
     6               IS0,IS1,IS2,IS4,ND7,
     7               L3264B,L3264W,IER)
C
C           JD( ) IS NOT ACTUALLY USED IN RETVEC.  IT IS USED
C           IN CALL TO CONST, BUT IS NOT USED THERE EITHER.
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,127)(LD(J),J=1,4),NDATE
  127       FORMAT(/,' ****VARIABLE NOT RETRIEVED BY RETVEC IN DISTAP',
     1             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,' FOR DATE',I12)
         ENDIF
         IIER=IIER+IER
C
         IF(IIER.EQ.0.AND.JJER.EQ.0)THEN
            M=M+1
C              UNLESS THE SINGLE VALUE FORECASTS FOR TEMP, DEW, AND WIND SPEED
C              AND THE TEMP STANDARD ERROR CAN BE RETRIEVED FOR ALL INDEPENDENT ELEMENTS, 
C              THE DATA ARE NOT SAVED AND THE COLUMN NUMBER IS NOT UPDATED. 
C              THIS ALLOWS THE USE OF LESS THAN THE FULL SET OF EXPECTED ENSEMBLES.
         ENDIF
      ELSE
         IF(IFIRST.EQ.0)THEN
            NNSAVE=N
C               NNSAVE IS NOW THE FIRST VARIABLE IN THE ID( , ) LIST
C               NOT USED.  LATER, TRANSFER NNSAVE TO NN TO BE USED
C               ON NEXT ENTRY.
            IFIRST=1
         ENDIF
      ENDIF
C
 200  CONTINUE
      M=M-1
C 
C        THERE HAVE BEEN M RECORDS RETRIEVED.  EACH HAS THE SAME
C        ID'S EXCEPT THE DD'S AND POSSIBLY THE RR'S AND TAU'S.
C
      IF(M.EQ.0)THEN
C           THIS IS NORMAL WHEN ALL ENSEMBLE MEMBERS HAVE BEEN 
C           RETRIEVED.  HOWEVER, CALLING PROGRAM OUGHT TO NOT
C           BE CALLING IN THIS CASE.
         NN=9999
         GO TO 300
      ELSE
         IF(IP15.NE.0)THEN
            WRITE(IP15,201)M, NDATE
 201        FORMAT(/' ',I3,' ENSEMBLE MEMBERS HAVE BEEN RETRIEVED',/,
     1                ' FOR TEMPERATURE, DEWPOINT, WIND SPEED,',/,
     2                ' AND THEIR CORRESPONDING STANDARD DEVIATIONS',/,
     3                ' FOR DATE',I12)
            DO 205 K=1,NSTA
C
            WRITE(IP15,202)CCALL(K),
     1         (XDATA(K,L),L=1,M),(SDDATA(K,L),L=1,M),
     2         (DPDATA(K,L),L=1,M),
     3         (WSDATA(K,L),L=1,M)
 202        FORMAT(/,A8,/,4('     ',21F6.1,/))
 205        CONTINUE
         ENDIF
      ENDIF
C
C        CHECK FOR KERNEL USED.
C
      IF(KER(NN).NE.2)THEN
         WRITE(KFILDO,207)KER(NN),(ID(J,NN),J=1,4)
 207     FORMAT(/,' ****KER( ) =',I4,' NE 2',
     1            ' FOR VARIABLE',
     2             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3            ' SUBROUTINE DISTAP',/,
     4            ' ENTERED WITH INCORRECT KERNAL')
         KER(NN)=1
         ISTOP(3)=ISTOP(3)+1
      ENDIF
C
C
C	LOOP THROUGH EACH STATION IN PARALLEL
C
!$OMP PARALLEL DO 
!$OMP& PRIVATE(K,L,I,MM,NPCDF,RDATA,SDATA,KERN,PDF,CDF)
!$OMP& PRIVATE(XAXIS,LD,LL,DIF,F,ISTOP,NSTART,IER,J)
!$OMP& PRIVATE(RMAX,SMAX,RMIN,SMIN,FAC,FMAXVAL,FMINVAL)
!$OMP& PRIVATE(RFAC,TDATA,TSD,LOC,FACTOR,XLOW)
!$OMP& PRIVATE(XBAR,SKEW,SKEWN,SKEWD)
!$OMP& PRIVATE(TWOSIGSQ,TOT,TOT2,CMED,TOTJM1,P,X50,XMED)
      DO 250 K=1,NSTA
C      TID=OMP_GET_THREAD_NUM()
C
C
C  CONSTRUCT ENSEMBLE APPARENT TEMPERATURE
C
C  CALCULATE THE MEAN VALUE OF THE SURFACE TEMPERATURE ENSEMBLE.
C  IF THIS VALUE IS LESS THAN OR EQUAL TO 50 deg F,  THEN THE
C  WIND CHILL FORMULA IS APPLIED TO EACH ENSEMBLE MEMBER REGARDLESS
C  OF THEIR VALUE.
C
      MM=0
      XBAR=0.
      DO 210 L=1,M
         IF(XDATA(K,L).NE.9999.
     1      .AND.WSDATA(K,L).NE.9999.)THEN
            MM=MM+1
            XBAR=XBAR+XDATA(K,L)
         ENDIF
 210  CONTINUE
C
      MMM=MM
      IF(MMM.GT.0)THEN
         XBAR=XBAR/MMM
C      WRITE(*,*) "XBAR: ",XBAR
C
      MM=0
      IF(XBAR.LE.50.)THEN
C        APPLY WIND CHILL TO EACH MEMBER IF THE 
C        SURFACE TEMPERATURE AND WIND SPEED ARE
C        AVAILABLE.
         DO 211 L=1,M
            IF(XDATA(K,L).NE.9999.
     1         .AND.WSDATA(K,L).NE.9999.)THEN
                  MM=MM+1
                  RDATA(MM)=WCHILL(XDATA(K,L),WSDATA(K,L))
                  SDATA(MM)=SDDATA(K,L)
            ENDIF
 211     CONTINUE
      ELSE
C        IF SURFACE TEMPERATURE OF A ENSEMBLE MEMBER IS 
C        AVAILABLE AND LESS THAN 78 deg F, THEN ITS VALUE 
C        TO THE APPARENT TEMPERATURE.  IF THE SURFACE
C        TEMPERATURE IS AVAILABLE AND GREATER THAN OR EQUAL
C        TO 78 deg F AND THE DEWPOINT TEMPERATURE IS 
C        AVAILABLE, THEN APPLY THE HEAT INDEX FORMULA TO
C        OBTAIN THE APPARENT TEMPERATURE.
         DO 212 L=1,M
            IF(XDATA(K,L).NE.9999.)THEN
               IF(XDATA(K,L).LT.78.)THEN
                  MM=MM+1
                  RDATA(MM)=XDATA(K,L)
                  SDATA(MM)=SDDATA(K,L)
               ELSEIF(DPDATA(K,L).NE.9999.)THEN
                  MM=MM+1
                  RDATA(MM)=HTINDX(XDATA(K,L),DPDATA(K,L))
                  SDATA(MM)=SDDATA(K,L)
               ENDIF
            ENDIF
 212     CONTINUE
      ENDIF
C
      DO 213 L=1,ND2
        XDATA(K,L)=9999.
 213  CONTINUE
      DO 214 L=1,MM
        XDATA(K,L)=RDATA(L)
 214  CONTINUE 
C
      ENDIF
C
C        AT THIS POINT, RDATA( ) AND SDATA( ) CONTAIN MM 
C        NON-MISSING FORECASTS.
C
      IF(MM.EQ.0)THEN
         IF(NDATE.EQ.NDATES)THEN
C              THIS DIAGNOSTIC WILL PRINT ON ONLY THE FIRST DAY.
            WRITE(KFILDO,215)CCALL(K),(ID(J,NN),J=1,4),NDATE
 215        FORMAT(/,' NO FORECASTS FOR STATION ',A8,
     1              ' FOR VARIABLE',
     2                2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3               ' FOR DATE',I12,'.  (PRINT ON DAY 1.)')
         ENDIF
C
C              WHEN THERE ARE NO GOOD NON-MISSING FORECASTS
C              FOR STATION K, SET THE XCDF(K,L) VALUES MISSING
C              FOR ALL THRESHOLDS.
C
         DO 216 L=1,NCDFTH
         XCDF(K,L)=9999.
 216     CONTINUE
      ELSEIF(MM.NE.M)THEN
         WRITE(KFILDO,217)MM,CCALL(K),(ID(J,NN),J=1,4),NDATE
 217     FORMAT(/,' ONLY',I4,' FORECASTS FOR STATION ',A8,
     1            ' FOR VARIABLE',
     2             2X,I9.9,1X,I9.9,1X,I9.9,1X,I10.3,
     3            ' FOR DATE',I12)
      ENDIF
C
C 
      FAC=1.
C        FAC IS INITIALIZED TO 1 IN CASE SCALE3 IS NOT CALLED.
C
      IF(ISD(NN).EQ.3)THEN
C
C           COMPUTE FAC, THE SPREAD FACTOR TO USE IN KERNEL.
C           INITIALIZE MAX AND  VALUES.
C
         RMAX=RDATA(1)
         SMAX=SDATA(1)
         RMIN=RDATA(1)
         SMIN=SDATA(1)
C
C           FIND THE MAXIMA RMAX( ) AND SDMAX( ) AND THE MINIMA
C           RMIN( ) AND SDMIN( ).
C
         DO 140 L=1,MM
C
         IF(RDATA(L).GT.RMAX)THEN
            RMAX=RDATA(L)
            SMAX=SDATA(L)
         ELSEIF(RDATA(L).LT.RMIN)THEN
            RMIN=RDATA(L)
            SMIN=SDATA(L)
         ENDIF
C
 140     CONTINUE
C
C           THE SPREAD ADJUSTMENT FAC IS A FACTOR OF SD.  WHEN SD = 0,
C           THE SPREAD IS NOT AFFECTED BY THE SPREAD OF THE MEANS.
C           WHEN SD = 1, THERE IS NO SPREAD ADJUSTMENT AT ALL.
C           SD BETWEEN 0 AND 1 GIVES SPREAD ADJUSTMENT AS A CONTINUOUS
C           RANGE.
C
         FAC=(3*(SMAX+SMIN)+SD(MM)*(RMAX-RMIN))/
     1       (3*(SMAX+SMIN)+(RMAX-RMIN))
      ENDIF
C
C
      KERN=1
      RFAC=10.
      IF(SDATA(MM).GT.12.)THEN
         KERN=2
         RFAC=1.
      ENDIF
C 
C   CONSTRUCT THE KERNEL
C
      FMAXVAL=-9999999
      FMINVAL=+9999999
C
C        CHECK SCALING FACTOR.
C
      IF(DS(NN).EQ.0.)THEN
         WRITE(KFILDO,103) J
 103     FORMAT(/' ****SCALING FACTOR IS INPUT AS ZERO.',
     1           '  ASSUME SCALING OF 1.  PROCEEDING.')
         FDS=1.
         IER=777
      ELSE
         FDS=DS(NN)
      ENDIF
C
C        PUT THE REAL NUMBERS IN DATA( ) INTO TDATA( ) ROUNDED
C        TO TENTHS OF UNITS.
C
      DO 105 J=1,MM
C        IF RFAC=10, IT IS EXPECTED THE DATA IN RDATA( ) ARE TO TENTHS OF
C        UNITS, AND NOTHING IS LOST HERE.  OTHERWISE, TENTHS
C        OF UNITS IS ALL THE PRECISION THAT IS KEPT.
C        IF RFAC=10, THE DATA( ) ARE MULTIPLIED BY 10, SO THE SD'S MUST BE ALSO.
C        THE SD'S ARE SCALED BY DS.
C
      IF(KERN.EQ.1)THEN
         TDATA(J)=NINT(RDATA(J)*RFAC)
         TSD(J)=NINT(FDS*SDATA(J)*RFAC)
      ELSE
         TDATA(J)=RDATA(J)*RFAC
         TSD(J)=FDS*SDATA(J)*RFAC
      ENDIF
C
      IF(TSD(J).LE.0)THEN
         WRITE(KFILDO,104)J
 104     FORMAT(/' ****STANDARD DEVIATION OF THE',I4,'TH VALUE',
     1           ' IN TENTHS OF UNITS ROUNDS TO ZERO.',/,
     2           '     ASSUME 1 SCALED UNIT.  PROCEEDING.')
         TSD(J)=1.
         IER=777
      ENDIF
C
 105  CONTINUE
C
C        FIND MAXIMUM AND MINIMUM EXTENTS OF THE FINAL DENSITY.
C        THIS WILL BE THE SMALLEST AND LARGEST TDATA( ) VALUES
C        EACH EXTENDED TO THE LEFT AND RIGHT, RESPECTIVELY,
C        BY 3 TIMES ITS RESPECTIVE TSD( )
C
      DO 120 N=1,MM
C
      IF(TDATA(N)-3*TSD(N).LT.FMINVAL)THEN
         FMINVAL=TDATA(N)-3*TSD(N)
      ENDIF
C
      IF(TDATA(N)+3*TSD(N).GT.FMAXVAL)THEN
         FMAXVAL=TDATA(N)+3*TSD(N)
      ENDIF
C
 120  CONTINUE
C
C        SET THE X-AXIS VALUES.
C        XAXIS( ) IS THE AXIS IN TERMS OF THE INCOG DATA.  THE
C        DATA HAVE BEEN SCALED*10; SCALING MUST BE TAKEN OUT.  THIS
C        COVERS THE RANGE 3 SIGMA BELOW THE IMUM VALUE AND
C        3 SIGMA ABOVE THE MAXIMUM VALUE IN INCREMENTS OF TENTHS
C        OF UNITS OF THE ORIGINAL DATA.
C
      NPCDF=FMAXVAL-FMINVAL+1
C
      IF(NPCDF.GT.ND11)THEN
         WRITE(KFILDO,139) ND11,NPCDF
 139     FORMAT(/,' ****DIMENSION ND11 =',I8,' TOO SMALL TO',
     1            ' COMPUTE CDF( ) IN KERNEL.  INCREASE TO ',I8,
     2            ' OR MORE.  PROCEEDING.')
         IER=778
      ELSE
C
        IF(KERN.EQ.1)THEN
           DO 141 J=1,NPCDF
C
           XAXIS(J)=(FMINVAL+J-1)/RFAC
C
C        THE X-AXIS WILL COVER 3 STANDARD DEVIATIONS IN TERMS OF
C        TENTHS OF UNITS, LABELED IN WHOLE UNITS, ON EITHER SIDE
C        OF THE MAX AND  VALUE IN DATA( ).
C
 141       CONTINUE
         ELSE
            XAXIS(1)=FMINVAL
            FINC=(FMAXVAL-FMINVAL)/(NPCDF-1)-1
            DO 1415 J=2,NPCDF
            XAXIS(J)=FMINVAL+(J-1)*FINC
 1415       CONTINUE
         ENDIF 
C
C        ZERO THE PDF( ) AND CDF( ) ARRAYS.
C
        DO 142 J=1,NPCDF
        PDF(J)=0.
        CDF(J)=0.
 142    CONTINUE
C
C        COMPUTE THE KERNEL OVER THE RANGE MINUS 3 SIGMA
C        TO PLUS 3 SIGMA AROUND EACH VALUE IN TDATA( ).
C
        DO 160 N=1,MM
C
        FACTOR=1./(TSD(N)*SQRT(2.*3.14159))
C          FACTOR IS THE CONSTANT MULTIPLIER FOR THE NORMAL DENSITY.
C          FOR THIS BASIC DENSITY, THE NUMBER OF CASES IS NOT RELEVANT.
        TWOSIGSQ=2.*TSD(N)*TSD(N)
C         TWOSIG IS THE DIVISION IN THE EXPONENT FOR THE NORMAL
C         DENSITY.
C
C        CALCULATE THE KERNEL.
C
        DO 150 J=-NINT(3*TSD(N)),+NINT(3*TSD(N))
C
        LOC=NINT(TDATA(N)-FMINVAL+J+1)
        PDF(LOC)=PDF(LOC)+FACTOR*EXP(-(FLOAT(J*J))/TWOSIGSQ)
C
 150    CONTINUE
C
 160    CONTINUE
C
C        ADJUST THE DISTRIBUTION BY THE FACTOR FAC.  THIS IS DONE
C        BY MODIFYING THE VALUES IN XAXIS( ).  THIS WILL NOT OVERFLOW
C        ARRAYS UNLESS FAC IS POSITIVE, THEN IT MIGHT.
C
C
        IF(ABS(1.-FAC).GT..001)THEN
C        A FACTOR FAC OF UNITY OR NEARLY SO NEED NOT BE USED.
           TOT=0.
C
           DO 162,J=1,NPCDF
           TOT=TOT+PDF(J)
 162       CONTINUE
C
           TOT2=TOT/2.
           CMED=0.
           XMED=0.
           XLOW=9999.0
C
           DO 164 J=1,NPCDF
           CMED=CMED+PDF(J)
           IF(PDF(J).EQ.0.0.AND.PDF(J-1).NE.0.0)XLOW=XAXIS(J)
C
C
C
           IF(CMED.GE.TOT2.AND.PDF(J-1).GT.0.0)THEN
              CMED=CMED-PDF(J)/2.+.0001
C               FOR A SYMMETRICAL DISTRIBUTION (AS WOULD OCCUR WITH
C               TWO ENSEMBLE MEMBERS WITH THE SAME SD) WITH AN ODD
C               NUMBER OF POINTS ON THE SCALE, THE CENTER POINT
C               VALUE REPRESENTS BOTH HALVES.  THE SMALL ADDITIVE
C               FACTOR IS SO THE CALCULATED MIDDLE WILL STILL BE
C               BETWEEN THE CORRECT POINTS (IT MAY NOT BE NECESSARY).
C               THIS MAY NOT BE EXACTLY CORRECT FOR NON-SYMMETRICAL
C               DISTRIBUTIONS, BUT IS CLOSE ENOUGH.
              TOTJM1=CMED-PDF(J-1)
              IF(CMED.NE.TOTJM1)THEN
                P=(TOT2-TOTJM1)/(CMED-TOTJM1)
C               THE 50 PERCENT MAY NOT FALL EXACTLY ON AN EVEN J.
C               P IS THE FRACTION OF THE WAY THE 50 PERCENT VALUE
C               IS FROM J-1.
              ELSE
C              DROP THROUGH HERE IF THERE IS A GAP BETWEEN ENSEMBLE
C              MEMBERS AND THE PDF VALUE AT THE MEDIAN IS 0.0
               XMED=XAXIS(J)-(XAXIS(J)-XLOW)/2.
               GO TO 165
              ENDIF
              X50=J-1+P
              XMED=XAXIS(J-1)+(XAXIS(J)-XAXIS(J-1))*P
              GO TO 165
           ENDIF
C
 164       CONTINUE
C
 165       CONTINUE
C
           DO 167 J=1,NPCDF
           XAXIS(J)=XMED+(XAXIS(J)-XMED)*FAC
 167       CONTINUE
C
        ENDIF
C
C        NOW COMPUTE THE CDF( ) AND NORMALIZE THE PDF( ) AND CDF( ).
C
        CDF(1)=.0
C        THE AREA BEYOND 3 SIGMA IS IGNORED.
        TOT=0.
        DO 180 J=2,NPCDF
C
        CDF(J)=CDF(J-1)+(PDF(J-1)+PDF(J))/2.
        TOT=TOT+PDF(J)
C
 180    CONTINUE
C
        DO 190 J=1,NPCDF
         PDF(J)=PDF(J)/TOT
         CDF(J)=CDF(J)/TOT
 190    CONTINUE
C
C
        IF(IER.EQ.777)THEN
         WRITE(KFILDO,221)(ID(J,NN),J=1,4),CCALL(K)
 221     FORMAT('     VARIABLE ',4I11,' STATION ',A8)
        ELSEIF(IER.EQ.778)THEN
         DO 2215 L=1,NCDFTH
            XCDF(K,L)=9999.
 2215    CONTINUE
        ENDIF 
C
        IF(KFILAO.NE.0)THEN
C
C           WRITE THE ASCII DATA.  FORM THE ID'S.
C
         LD(1)=ID(1,NN)
C
         IF(M.GT.1)THEN
            LD(1)=(LD(1)/100)*100+76
C              WHEN MORE THAN ONE ENSEMBLE IS INVOLVED, USE DD = 76.
C              OTHERWISE, USE THE DD OF THE MEMBER.
         ENDIF
C
         LD(2)=ID(2,NN)
C           THIS PUTS THE PROBABILITY THRESHOLD INTO LLLL OF WORD 2.
C           IT ASSUMES UUUU = 0, BUT RETAINS THE FIRST DIGIT, V.
         LD(3)=ID(3,NN)
         LD(4)=ID(4,NN)
C
         WRITE(KFILAO,222)CCALL(K),(LD(J),J=1,4),NDATE,NPCDF
 222     FORMAT(/,' ',A8,I12,2X,3I11.9,I11.3,I6)
C
         WRITE(KFILAO,223)(XAXIS(J),PDF(J),CDF(J),J=1,NPCDF)
 223     FORMAT(' ',3F12.6)
        ENDIF
C
C
C        FIND THE DATA VALUE IN XAXIS( ) CORRESPONDING TO THE
C        THRESHOLDS IN CDFTH( ) APPLIED TO CDF( ) AND PUT
C        THEM IN XCDF( , ).
C
        NSTART=2
        DO 230 L=1,NCDFTH
          DO 220 LL=NSTART,NPCDF
            IF(CDF(LL).GT.CDFTH(L))THEN
              DIF=CDF(LL)-CDF(LL-1)
C 
             IF(DIF.LE.0.)THEN
              XCDF(K,L)=XAXIS(LL)
              WRITE(KFILDO,2195)CCALL(K)
 2195         FORMAT(/' ****CDF( ) AT TWO POINTS ALONG THE',
     1              ' AXIS ARE EQUAL FOR STATION ',A8,
     2              '.  PROBABLY AN ERROR.  CONTINUING.')
              ISTOP(3)=ISTOP(3)+1
             ELSE
              F=(CDFTH(L)-CDF(LL-1))/DIF
              XCDF(K,L)=XAXIS(LL-1)+(XAXIS(LL)-XAXIS(LL-1))*F
C              PACKING WILL DO ROUNDING.
             ENDIF
C
             NSTART=LL
             GO TO 230
            ENDIF
  220    CONTINUE
  230   CONTINUE
C        DO 2229 L=1,NCDFTH
C        WRITE(*,*) L,CDFTH(L),XCDF(K,L)
C 2229   CONTINUE
C
        IF(IP15.NE.0)THEN
           WRITE(IP15,232)NCDFTH,(CDFTH(L),XCDF(K,L),L=1,NCDFTH)
 232       FORMAT(/,' VALUES CORRESPONDING TO ',I4,' THRESHOLDS.',/,
     1           (5(3X,2F8.2)))
        ENDIF 
C 
      ENDIF
 250  CONTINUE
!$OMP END PARALLEL DO
C
      NN=NNSAVE
  300 RETURN
      END 
C
C
C   THE FUNCTION HTINDX CALCULATES THE HEAT INDEX IN DEGREES
C   FAHRENHEIT GIVEN THE SURFACE TEMPERATURE IN DEGREES FAHRENHEIT
C   AND THE DEWPOINT TEMPERATURE IN DEGREES FAHRENHEIT.
C
C
      FUNCTION HTINDX(TFAH,DFAH)

      RHPC=RELHUM(TFAH,DFAH)

      HTINDX=-42.379+2.049011523*TFAH+10.14333127*RHPC
     1  -0.22475541*TFAH*RHPC-0.00683783*TFAH*TFAH
     2  -0.05481717*RHPC*RHPC+0.00122874*TFAH*TFAH*RHPC
     3  +0.00085282*TFAH*RHPC*RHPC-0.00000199*TFAH*TFAH*RHPC*RHPC

      IF(RHPC.LT.13..AND.(TFAH.GE.80..AND.TFAH.LT.112.)) THEN
        HTINDX=HTINDX-((13.-RHPC)/4.)*SQRT((17.-ABS(TFAH-95.))/17.)
      ENDIF

      IF(RHPC.GT.85..AND.(TFAH.GE.80..AND.TFAH.LE.87.)) THEN
        HTINDX=HTINDX+((RHPC-85.)/10.)*((87.-TFAH)/5.)
      ENDIF
C      WRITE(*,*) "HTINDX: ",TFAH,DFAH,RHPC,HTINDX

      RETURN
      END
C
C
C   THE FUNCTION RELHUM CALCULATES THE RELATIVE HUMIDITY IN PERCENT
C   FROM THE SURFACE TEMPERATURE IN DEGREES FAHRENHEIT AND THE 
C   DEWPOINT TEMPERATURE IN DEGREES FAHRENHEIT.
C
C
      FUNCTION RELHUM(TFAH,DFAH)
      F=9./5.

      TCEL=(TFAH-32.)/F
      SVP=6.1078*EXP((17.269*TCEL)/(TCEL+237.3))

      DCEL=(DFAH-32.)/F
      VP=6.1078*EXP((17.269*DCEL)/(DCEL+237.3))

      RELHUM=(VP/SVP)*100.
      IF(VP.GE.SVP) RELHUM=0.99

      END
C
C
C   THE FUNCTION WCHILL CALCULATES THE WIND CHILL TEMPERATURE
C   IN DEGREES FAHRENHEIT GIVEN THE SURFACE TEMPERATURE IN DEGREES
C   FAHRENHEIT AND THE WIND SPEED IN KNOTS.
C
C
      FUNCTION WCHILL(TFAH,WSKTS)

      WSMPH=1.15*WSKTS
      IF(WSMPH.GE.1.)THEN
         WCHILL=35.74+0.6215*TFAH-(35.75-0.4275*TFAH)*WSMPH**.16
      ELSE
         WCHILL=TFAH
      ENDIF

      RETURN
      END
