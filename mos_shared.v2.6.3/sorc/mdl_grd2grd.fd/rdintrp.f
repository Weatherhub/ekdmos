      SUBROUTINE RDINTRP(KFILDO,KFILIN,KFILRA,RACESS,ND2X3,ND4,ND5,
     1                   ND6,ND7,ND8,ND11,JP,JSTOP,NAMIN,NUMIN,
     2                   MDATE,NDATES,MINPK,ISCALD,ID,IDPARS,
     3                   NVRBLS,IS0,IS1,IS2,IS4,IPLAIN,PLAIN,
     4                   NGRIDC,MPROJ,NX,NY,XLATLL,YLONLL,
     5                   XMESH,ORIENT,XLAT,IP13,IP16,
     6                   L3264B,L3264W,NTOTBG,NTOTRG,ISTOP,IER)
C
C$$$   SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: DATA_INTRP
C   PRGMMR: RUDACK         ORG: W/OST22          DATE: 2002-08-01
C
C ABSTRACT: TO READ PACKED GRIDDED DATA FROM SEQUENTIAL FILES AND  
C           PERFORM ONE OF FOUR POSSIBLE INTERPOLATIONS ON THE DATA.
C           THE DATA ARE THEN PACKED INTO FILE 'KFILRA'. 
C
C PROGRAM HISTORY LOG:
C   02-08-01  RUDACK
C   05-11-01  MALONEY ADDED NCEP DOCBLOCK.
C   05-11-08  MALONEY REPLACED KFILGO WITH KFILRA; ADDED RACESS TO
C                     SUBROUTINE CALL
C   12-09-24  ENGLE   ADDED CALL TO CKFILEND TO CHECK ENDIAN OF TDLPACK
C                     SEQ FILE, THEN OPEN FILE FORMALLY VIA OPEN
C                     STATEMENT
C
C USAGE:  CALLED BY U365
C
C        DATA SET USE:
C         INPUT FILES:
C       FORT.KFILIN(J) - UNIT NUMBERS FOR INPUT DATA, ALL IN TDLPACK
C                        FORMAT. (J=1,NUMIN).  (INPUT)
C        OUTPUT FILES:
C          FORT.KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C          FORT.KFILRA - UNIT NUMBER OF GRIDPOINT R.ACCESS OUTPUT FILE. (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C           KFILIN(J) = UNIT NUMBERS FOR INPUT DATA, ALL IN TDLPACK
C                       FORMAT. (J=1,NUMIN).  (INPUT)
C              KFILRA = UNIT NUMBER OF GRIDPOINT R.ACCESS OUTPUT FILE. (INPUT)
C               ND2X3 = THE DIMENSION OF SEVERAL ARRAYS (ND2*ND3).  SET 
C                       BY PARAMETER.  (INPUT)
C                 ND4 = THE MAXIMUM NUMBER OF VARIABLES IN A RUN OF U365.
C                       (INPUT)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).
C                       THESE ARE GENERAL PURPOSE ARRAYS, SOMETIMES USED
C                       FOR GRIDS.  TO AVIOD ERRORS IN CERTAIN ROUTINES,
C                       AND TO AVOID CONFUSION, ND5 SHOULD BE SET EQUAL TO
C                       ND2X3.  ALSO, BECAUSE IPACK( ) AND IWORK( ) ARE 
C                       USED AS WORK ARRAYS IN RDSNAM, ND5 SHOULD NOT BE
C                       LT ND12.  (INPUT)
C                 ND6 = MAXIMUM NUMBER OF SEQUENTIAL FILES THAT CAN BE DEALT 
C                       WITH.  (INPUT)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       SHOULD BE GE 54.  (INPUT)
C                 ND8 = MAXIMUM NUMBER OF DATES THAT CAN BE DEALT WITH.
C                       (INPUT)
C                ND11 = MAXIMUM NUMBER OF INPUT GRID COMBINATIONS IN A RUN OF 
C                       U365.  (INPUT)
C             JP(J,N) = JP(1,N) INDICATES WHETHER (>0) OR NOT (=0)
C                       VARIABLE N WILL BE OUTPUT FOR VIEWING.
C                       JP(2,N) INDICATES THE TYPE OF INTERPOLATION
C                       TO BE PERFORMED ON THE INPUT GRID IN OBTAINING
C                       THE OUTPUT GRID.  (N=1,ND4).  (INPUT)
C               JSTOP = THE NUMBER OF ERRORS THAT WILL BE TOLERATED ON
C                       THE TOTAL RUN BEFORE PROGRAM STOPS.  (INPUT)
C            NAMIN(J) = NAME OF THE INPUT FILES BEING PROCESSED.  (INPUT) 
C               NUMIN = THE NUMBER OF VALUES IN KFILIN( ) AND NAMIN( ).
C                       (INPUT)
C            MDATE(M) = HOLDS ALL DATES TO BE PROCESSED IN FORM YYYYMMDDHH
C                       (J=1,NDATES).  (INPUT)
C              NDATES = TOTAL NUMBER OF DATES TO BE PROCESSED.  (INPUT)
C               MINPK = MINIMUM GROUP SIZE WHEN PACKING THE GRIDDED
C                       VALUES.  (INPUT)
C           ISCALD(N) = THE DECIMAL SCALING CONSTANT TO USE WHEN PACKING
C                       THE GRIDDED DATA (N=1,ND4).  NO BINARY 
C                       SCALING IS PROVIDED FOR.  (INPUT)
C             ID(J,N) = THE PREDICTOR ID'S (J=1,4) (N=1,NVRBLS).  (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE PREDICTOR
C                       ID'S CORRESPONDING TO ID( ,N) (J=1,15), (N=1,NVRBLS).
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE), (NOT USED)
C                       J=14--S (SMOOTHING INDICATOR), AND (NOT USED)
C                       J=15--G (GRID INDICATOR).  (NOT USED)
C              NVRBLS = NUMBER OF ID'S IN ID( , ) AND IDPARS( , ).  (INPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).  (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).  (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INTERNAL)
C       IPLAIN(L,J,N) = 32 CHARACTERS (L=1,L3264W) (J=1,4) OF PLAIN
C                       LANGUAGE DESCRIPTION OF VARIABLES (N=1,ND4).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       EQUIVALENCED TO PLAIN( ).  (INPUT)
C            PLAIN(N) = THE PLAIN LANGUAGE DESCRIPTION OF THE VARIABLES
C                       (N=1,ND4).  EQUIVALENCED TO IPLAIN( , , ).
C                       (CHARACTER*32)  (INPUT)
C         NGRIDC(L,M) = HOLDS THE GRID CHARACTERISTICS FOR THE INPUT GRID
C                       BEING PROCESSED (M=1,ND11).  (INTERNAL)
C                       L=1--MAP PROJECTION NUMBER (3=LAMBERT, 5=POLAR
C                            STEREOGRAPHIC AND 7=MERCATOR).  (INTERNAL)
C                       L=2--GRID LENGTH IN MILLIMETERS,
C                       L=3--LATITUDE AT WHICH GRID LENGTH IS CORRECT *10000,
C                       L=4--GRID ORIENTATION IN DEGREES *10000,
C                       L=5--LATITUDE OF LL CORNER IN DEGREES *10000, AND
C                       L=6--LONGITUDE OF LL CORNER IN DEGREES *10000.
C               MPROJ = MAP PROJECTION OF THE OUTPUT GRID.  (INPUT)
C                  NX = X-EXTENT OF THE OUTPUT GRID.  (INPUT)
C                  NY = Y-EXTENT OF THE OUTPUT GRID.  (INPUT)
C              XLATLL = LATITUDE OF LOWER LEFT CORNER POINT OF THE
C                       OUTPUT GRID.  (INPUT)
C              YLONLL = WEST LONGITUDE OF LOWER LEFT CORNER POINT
C                       OF THE OUTPUT GRID.  DO NOT USE NEGATIVE.  (INPUT)  
C               XMESH = MESH LENGTH OF OUTPUT GRID IN KM AT XLAT DEGREES 
C                       NORTH LATITUDE.  (INPUT)
C              ORIENT = ORIENTATION OF OUTPUT GRID IN DEGREES WEST 
C                       LONGITUDE.  DO NOT USE NEGATIVE.  (INPUT)  
C                XLAT = LATITUDE OF OUTPUT GRID IN DEGREES AT WHICH 
C                       XMESH APPLIES. ALSO THE LATITUDE WHERE THE 
C                       PROJECTION CUTS THE EARTH.  DO NOT USE NEGATIVE.
C                       (INPUT)
C                IP13 = THE IP VALUE WHICH DIRECTS THE PRINT OUTPUT OF  
C                       THE INTERPOLATED GRID VALUES.  (INPUT)
C                IP16 = THE IP VALUE WHICH DIRECTS THE PRINT THAT SHOWS
C                       WHICH VARIABLES HAVE BEEN PACKED.  (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  SET BY PARAMETER.  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  (INPUT)
C              NTOTBG = THE TOTAL NUMBER OF BYTES ON THE FILE 
C                       ASSOCIATED WITH UNIT NO. KFILRA (THE GRIDPOINT
C                       R.ACCESS FILE).  IT IS UPDATED WHEN THE DATA IN
C                       IPACK( ) ARE WRITTEN.  (OUTPUT)
C              NTOTRG = THE TOTAL NUMBER OF RECORDS IN THE GRIDPOINT
C                       FILE.  IT IS UPDATED AS NEEDED IN WRITEP.  (OUTPUT) 
C            ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER
C                       AN INPUT DATA RECORD IS NOT FOUND.
C                 IER = STATUS RETURN.
C                        0 = GOOD RETURN.
C                        > 0 VALUES RETURNED FROM OTHER ROUTINES. 
C                       (INTERNAL-OUTPUT)
C            IPACK(J) = HOLDS THE TDLPACK RECORD (J=1,NWORDS).  NWORDS
C                       IS CALCULATED NWORDS=NBYTES*8/L3264B, WHERE NBYTES
C                       IS THE LENGTH IN BYTES READ FROM THE RECORD ITSELF.
C                       (ALLOCATABLE) (INTERNAL)
C            IWORK(J) = ARRAY TO FURNISH TO SUBROUTINE UNPACK (J=1,ND5).  
C                       (ALLOCATABLE) (INTERNAL)
C             DATA(J) = WORK ARRAY (J=1,ND5). (ALLOCATABLE) (INTERNAL)
C        XYDIR(K,J,M) = THE IX (J=1) AND JY (J=2) POSITIONS ON THE OUTPUT
C                       GRID RELATIVE TO A SPECIFIC INPUT GRID 
C                       (K=1,NX*NY) (M=1,NGRID). (ALLOCATABLE) (INTERNAL)
C          IFIND(N,4) = HOLDS THE FOUR WORD MOS-2000 ID OF THOSE VARIABLES 
C                       THAT ALREADY HAVE BEEN PROCESSED FOR A SPECIFIC DATE
C                       (N=1,NVRBLS).  (INTERNAL)
C             ILOCATE = KEEPS TRACK OF THE TOTAL NUMBER OF VARIABLES FOUND
C                       FOR A SPECIFIC DATE.  (INTERNAL)
C               LDATE = COUNTER THAT CORRESPONDS TO THE DATE NUMBER IN THE
C                       DATE LIST.  (INTERNAL)  
C               IDATE = THE CURRENT DATE BEING PROCESSED.  (INTERNAL)         
C               NGRID = THE NUMBER OF GRID COMBINATIONS IN NGRIDC( , ),
C                       MAXIMUM OF ND11.  (INTERNAL) 
C               ISTOP = INCREMENTED BY ONE EACH TIME AN ERROR IS ENCOUNTERED.
C                       (INPUT-OUTPUT)
C               NGRID = THE NUMBER CORRESPONDING TO THE PARTICULAR GRID 
C                       TYPE BEING PROCESSED.  (INTERNAL)
C              NWORDS = NUMBER OF WORDS IN IPACK( ).  NWORDS IS CALCULATED 
C                       NWORDS=NBYTES*8/L3264B, WHERE NBYTES IS THE LENGTH 
C                       IN BYTES READ FROM THE RECORD ITSELF.  (INTERNAL)
C           NBYTES(J) = ARRAY USED TO DEAL WITH DIFFERENT WORD LENGTHS
C                       OF HP AND CRAY WHEN READING DATA (J=1,2).
C              LSTOPC = AN INTERNAL COUNTER TO KEEP AN INFINITE READING
C                       LOOP FROM OCCURRING.  (INTERNAL)
C               LSTOP = THE VALUE TO COMPARE LSTOPC WITH TO STOP THE
C                       READING.  CURRENTLY SET AT 500; THIS ASSUMES
C                       500 READING ERRORS SHOULD NOT OCCUR IN A SINGLE
C                       RUN. (INTERNAL)
C
C        SUBPROGRAMS CALLED:  UNPACK, UNPKBG, GRIDCOMB, INTRP_OUT, W3TAGE
C          UNIQUE: GRIDCOMB, INTRP_OUT
C          LIBRARY:
C           MOSLIB - UNPACK, UNPKBG, 
C            W3LIB - W3TAGE
C        EXIT STATES:
C          COND =    0 - SUCCESSFUL RUN
C                  210 - TOTAL # OF ERRORS EXCEEDS JSTOP
C                  219 - INVALID INPUT GRID TYPE DETECTED
C                  220 - TOTAL # OF ERRORS EXCEEDS JSTOP IN INTRP_OUT
C                  255 - ERRORS OPENING SEQUENTIAL FILE ON KFILIN
C                   SEE OTHER ROUTINES FOR OTHER VALUES.
C
C REMARKS:  NONE
C
C ATTRIBUTES:
C   LANGUAGE:  FORTRAN 90 (xlf90 compiler)
C   MACHINE:  IBM SP
C
C$$$
C
CINTEL
      CHARACTER(LEN=20) :: CONVERTX
CINTEL
      CHARACTER*32 PLAIN(ND4)
      CHARACTER*60 NAMIN(ND6),RACESS
C
      REAL, ALLOCATABLE, DIMENSION(:,:,:) :: XYDIR
      REAL, ALLOCATABLE, DIMENSION(:) :: DATA
      INTEGER, ALLOCATABLE, DIMENSION(:) :: IPACK,IWORK      
C
      DIMENSION ISCALD(ND4),ID(4,ND4),IDPARS(15,ND4),JP(3,ND4)
      DIMENSION IPLAIN(L3264W,4,ND4)
      DIMENSION KFILIN(ND6)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION MDATE(ND8)
      DIMENSION IFIND(ND4,4)
C        NOTE: IFIND IS AN AUTOMATIC ARRAY.
      DIMENSION NGRIDC(6,ND11)
      DIMENSION NBYTES(2),ISTOP(2)
C
      ALLOCATE(XYDIR(ND2X3,2,ND11))
      ALLOCATE(IPACK(ND5),DATA(ND5),IWORK(ND5))
C
      DATA LSTOP/500/,
     1     LSTOPC/0/
      DATA NGRID/0/
      CONVERTX='BIG_ENDIAN'
C
      IER=0
C
      ILOCATE=0
      LDATE=1
C 
C        INITIALIZE 'IPACK' ARRAY.
C
      DO 80 J=1,ND5
         IPACK(J)=0
 80   CONTINUE 
C
      DO 280 IN=1,NUMIN
C
C           INITIALIZE 'IFIND' ARRAY.
         DO 105 J=1,4
            DO 100 N=1,NVRBLS   
               IFIND(N,J)=0
 100        CONTINUE
 105     CONTINUE
C
         ILOCATE=0
C
C           OPEN THE CURRENT FILE TO BE PROCESSED.  
C
CCC         OPEN(UNIT=KFILIN(IN),FILE=NAMIN(IN),FORM='UNFORMATTED',
CCC     1        STATUS='OLD',IOSTAT=IOS,ERR=252)
C
CINTEL
C        THE OPEN STATEMENT IS NEEDED HERE TO OPEN THE FILE
C        WITH THE CORRECT ENDIAN CONVERSION VALUE. REMEMBER,
C        NO FILE NAME IS NEEDED HERE FOR OPERATIONS
C
      CALL CKFILEND(KFILDO,KFILIN(IN),NAMIN(IN),ISYSEND,
     1              IFILEND,CONVERTX,IER)
      OPEN(UNIT=KFILIN(IN),FORM='UNFORMATTED',
     1     CONVERT=CONVERTX,STATUS='OLD',IOSTAT=IOS,ERR=252)
CINTEL
         WRITE(KFILDO,190)KFILIN(IN),NAMIN(IN)
 190     FORMAT(/,' OPENING FILE ON UNIT NO.',I3,', FILE = ',
     1            A60)      
C
 200     READ(KFILIN(IN),IOSTAT=IOS,ERR=201,END=265)
     1                 (NBYTES(J),J=1,L3264W),
     2                 (IPACK(J),J=1,MIN(ND5,NBYTES(L3264W)*8/L3264B))
C           BEGIN THE UNPACKING PROCESS.
         GOTO 205
C
 201     WRITE(KFILDO,202)KFILIN(IN),MDATE(LDATE),IOS,NAMIN(IN)
 202     FORMAT(/,' ****ERROR READING PACKED RECORDS ON UNIT NO.',I3,
     1            ' PROCESSING DATE',I11,' IN RDINTRP AT 202,',
     2            ' IOSTAT =',I5/,'     FILE = ',A60)
C
         ISTOP(1)=ISTOP(1)+1
C
         LSTOPC=LSTOPC+1
         IF(LSTOPC.LT.LSTOP) GOTO 200
C
C           IPACK( ) CONTAINS THE PACKED RECORD.  THE RECORD CONSISTS 
C           OF AN INITIAL 64 BYTES CONTAINING THE NUMBER OF BYTES 
C           FOLLOWING.  FOR A 32-BIT MACHINE, THIS IS TWO WORDS.
C           FOR A 32-BIT MACHINE, IPACK(5) HOLDS THE DATE/TIME OF 
C           THE RECORD.  FIRST CHECK IF THE TRAILER RECORD IS BEING 
C           PROCESSED.
C
 205     IF(L3264B.EQ.32)THEN
            IDATE=IPACK(5)
         ELSE
C              THE LEFT HALF OF IPACK(3) HOLDS THE DATE/TIME OF THE 
C              RECORD FOR A 64-BIT MACHINE.
            LOC=3
            IPOS=1
            CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IDATE,32,L3264B,
     1                  IER,*900)
         ENDIF
C
C           ENSURE THAT THE TOTAL NUMBER OF ERRORS DOES NOT EXCEED
C           JSTOP.
         IF(ISTOP(1).GE.JSTOP) THEN
            WRITE(KFILDO,210) JSTOP
 210        FORMAT(/,' ****AT LEAST A TOTAL OF ',I3,' ERRORS HAVE', 
     1               ' OCCURRED ON THIS RUN.  THIS AMOUNT EXCEEDS',
     2               ' JSTOP.',/,5X,'STOP 210 IN RDINTRP.')
            CALL W3TAGE('MDL_GRD2GRD')
            STOP 210
         ENDIF 
C
C           IF THE DATE ON THE RECORD EQUALS THE CURRENT DATE 
C           BEING PROCESSED, CHECK IF IT IS A DESIRED VARIABLE. 
         IF(MDATE(LDATE).EQ.IDATE) GOTO 214  
C
C           IF THE CURRENT DATE BEING PROCESSED IS LESS THAN THE
C           DATE ON THE RECORD, LOOP AND INCREMENT THE DATE COUNTER 
C           BY ONE AND FIND THE NEXT INPUT DATE THAT MATCHES THE 
C           DATE OF THE CURRENT RECORD.
C
         IF(MDATE(LDATE).LT.IDATE) THEN
C
            DO 213 J=LDATE+1,NDATES
               IF(MDATE(J).EQ.IDATE) THEN
                  LDATE=J
                  ILOCATE=0
C                    INITIALIZE 'IFIND' ARRAY.
                  DO 212 JJ=1,4
                     DO 211 NN=1,NVRBLS   
                        IFIND(NN,JJ)=0
 211                 CONTINUE
 212              CONTINUE
                  GOTO 214
               ENDIF
 213        CONTINUE
C
         ENDIF 
C
C           IF THE DATE BEING PROCESSED IS GREATER THAN THE DATE 
C           OF THE RECORD, READ THE NEXT RECORD.  PERHAPS THE NEXT
C           RECORD HAS THE DATE OF INTEREST. 
         IF(MDATE(LDATE).GT.IDATE) GOTO 200           
C     
C           UNPACK THE IS0, IS1, IS2 AND IS4 ARRAYS.
C
 214     CALL UNPACK(KFILDO,IPACK,IWORK,DATA,ND5,IS0,IS1,IS2,
     1               IS4,ND7,MISSP,MISSS,1,L3264B,IER)
C
	 IF(IER.NE.0) THEN
            ISTOP(1)=ISTOP(1)+1
            GOTO 200
         ENDIF
C
C           ENSURE THAT THIS VARIABLE HAS NOT ALREADY BEEN 
C           PROCESSED FOR THIS DATE.  IF IT HAS BEEN PROCESSED, 
C           SKIP THE RECORD AND READ THE NEXT RECORD ON THE FILE.
C
         DO 217 N=1,NVRBLS
C
            IF((IS1(9).EQ.IFIND(N,1)).AND.
     1         (IS1(10).EQ.IFIND(N,2)).AND.
     2         (IS1(11).EQ.IFIND(N,3)).AND.
     3         (IS1(12).EQ.IFIND(N,4)).AND.
     4         (MDATE(LDATE).EQ.IDATE)) THEN 
C           
               WRITE(KFILDO,216) (ID(J,N),J=1,4),IDATE
 216           FORMAT(/,' ****VARIABLE ',3(I9.9,1X),I10.10,1X,
     1                  'FOR DATE ',I10,' HAS ALREADY BEEN PACKED.',
     2                  ' CONTINUE PROCESSING NEXT VARIABLE.')
               ISTOP(1)=ISTOP(1)+1
C                 READ ANOTHER RECORD.
               GOTO 200
C
            ENDIF
C
 217     CONTINUE
C
         DO 245 N=1,NVRBLS
C              
C              IF ANY ONE OF THE INPUT VARIABLES MATCHES THE VARIABLE 
C              IN THE CURRENT RECORD, PROCESS THAT VARIABLE.
C                 
            IF((IS1(9).EQ.ID(1,N)).AND.
     1         (IS1(10).EQ.ID(2,N)).AND.
     2         (IS1(11).EQ.ID(3,N)).AND.
     3         (IS1(12).EQ.ID(4,N)).AND.
     4         (MDATE(LDATE).EQ.IDATE))THEN          
C
C                 ACCUMULATE THE NUMBER OF VARIABLES FOUND FOR A 
C                 SPECIFIC DATE.
C               
               ILOCATE=ILOCATE+1
C
C                 SAVE THE ID'S THAT ARE PROCESSED FOR THE
C                 CURRENT DATE.
C
               IFIND(N,1)=ID(1,N)
               IFIND(N,2)=ID(2,N)
               IFIND(N,3)=ID(3,N)
               IFIND(N,4)=ID(4,N)
C
               CALL UNPACK(KFILDO,IPACK,IWORK,DATA,ND5,IS0,IS1,
     1                     IS2,IS4,ND7,MISSP,MISSS,2,L3264B,IER)
C
               IF(IER.NE.0) THEN 
                  WRITE(KFILDO,218) (ID(J,N),J=1,4),IDATE,IER
 218              FORMAT(/, '****ERROR UNPACKING DATA FOR ID',
     1                      4I10,' FOR DATE',I10,'.',' IER = ',
     2                      I3)
                  ISTOP(2)=ISTOP(2)+1
                  GOTO 200
               ENDIF
C
C                 ENSURE THAT THE INPUT GRID IS OF VALID TYPE.
C
               IF((IS2(2).NE.3).AND.
     1            (IS2(2).NE.5).AND.
     2            (IS2(2).NE.7)) THEN
                  WRITE(KFILDO,219) IS2(2),IDATE,(ID(J,N),J=1,4)
 219              FORMAT(/,' ****AN INVALID INPUT GRID OF VALUE',I3,
     1                     ' FOR DATE ',I10,' HAS BEEN ENCOUNTERED FOR', 
     2                     ' VARIABLE ',3(I9.9,1X),I10.10,'.',/,4X,
     3                     ' VALUES OF 3,5 AND 7 ARE SUPPORTED. ',
     4                     ' STOP 219 IN RDINTRP.')
                  CALL W3TAGE('MDL_GRD2GRD')
                  STOP 219
               ENDIF
C            
C                 CALCULATE THE 'XI' AND 'YJ' POINTS FOR THE 
C                 OUTPUT GRID.  NOTE: IF MORE THAN ONE VARIABLE
C                 POSSESSES THE SAME INPUT GRID CHARACTERISTICS,
C                 THE 'XI' AND 'YJ' COORDINATES ARE TAKEN FROM
C                 THE FIRST VARIABLE HAVING THE SAME GRID
C                 CHARACTERISITC AS THE CURRENT ONE BEING 
C                 PROCESSED.
C
               CALL GRIDCOMB(KFILDO,ND2X3,ND7,ND11,IS2,
     1                       XYDIR,NGRIDC,NGRID,NX,NY,MPROJ,
     2                       XLATLL,YLONLL,XMESH,ORIENT,XLAT)
C
C                 INTERPOLATE THE DATA TO THE OUTPUT GRID.
C
               CALL INTRP_OUT(KFILDO,KFILRA,RACESS,ND2X3,ND4,ND5,ND7,
     1                        N,IDATE,MINPK,ISCALD,
     2                        ID,IDPARS,IPACK,IWORK,DATA,
     3                        IS0,IS1,IS2,IS4,IPLAIN,PLAIN,
     4                        XYDIR(1,1,NGRID),MPROJ,NX,NY,
     5                        XLATLL,YLONLL,XMESH,ORIENT,XLAT,
     6                        IP13,IP16,JP,L3264B,L3264W,
     7                        NTOTBG,NTOTRG,ISTOP,IER)  
C
C                 IF THE TOTAL NUMBER OF ERRORS EXCEEDS JSTOP, 
C                 TERMINATE THE PROGRAM.
C
               IF(ISTOP(1).GE.JSTOP) THEN
                  WRITE(KFILDO,220) JSTOP
 220              FORMAT(/,' ****AT LEAST A TOTAL OF ',I3, 
     1                     'ERRORS HAVE OCCURED ON THIS RUN.',
     2                     ' THIS AMOUNT EXCEEDS JSTOP.',/,5X,
     3                     'STOP 220 IN RDINTRP.')
                  CALL W3TAGE('MDL_GRD2GRD')
                  STOP 220
               ENDIF
C
            ENDIF
C
C              IF ALL VARIABLES HAVE BEEN FOUND, INCREMENT TO
C              THE NEXT DATE AND INITIALIZE 'ILOCATE'.
C
            IF(ILOCATE.EQ.NVRBLS) THEN
               LDATE=LDATE+1
               ILOCATE=0
C                 INITIALIZE 'IFIND' ARRAY.
               DO 235 JJ=1,4
                  DO 234 NN=1,NVRBLS   
                     IFIND(NN,JJ)=0
 234              CONTINUE
 235           CONTINUE
            ENDIF
C
 245     CONTINUE
C
C           READ THE NEXT RECORD SINCE THE INPUT VARIABLES DID 
C           NOT CORRESPOND TO THE PARTICULAR RECORD JUST READ.           
C                 
         GOTO 200
C
C           PROBLEMS OPENING THE CURRENT SEQUENTIAL FILE.
C
 252     WRITE(KFILDO,255)KFILIN(IN),IOS,NAMIN(IN)
 255     FORMAT(/,' ****TROUBLE OPENING FILE ON UNIT NO.',I3,
     1            '.  IOSTAT =',I5,3X,A60,/,5X,'STOP 263 IN ',
     2            'RDINTRP.')
         CALL W3TAGE('MDL_GRD2GRD')
         STOP 255
C      
 265     CLOSE(KFILIN(IN))
         WRITE(KFILDO,268)KFILIN(IN),NAMIN(IN)
 268     FORMAT(/,' CLOSING FILE ON UNIT NO.',I3,', FILE = ',A60)
C
 280  CONTINUE
C
      GOTO 950
C
 900  WRITE(KFILDO,901)IER
 901  FORMAT(/,' ****ERROR IN UNPKBG IN RDINTRP.  IER =',I4)
C 
C        DEALLOCATE THE DYNAMIC ARRAYS.
 950  DEALLOCATE(XYDIR,DATA,IPACK,IWORK)
C
      RETURN
      END
 
