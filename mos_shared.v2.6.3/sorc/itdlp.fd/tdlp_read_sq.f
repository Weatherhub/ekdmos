      SUBROUTINE TDLP_READ_SQ(KFILDO,KFILIN,CFILP,ND1,ND5,IVECT,
     1                        L3264B,NBYWD,NREC,IPACK,CCALL,NSTA,
     2                        IRECTYPE,IOCTET,IER)
C
C        HISTORY
C
C        MAY       2013   ENGLE       CREATED.
C
C        PURPOSE
C
C            TO READ TDLPACK DATA RECORDS FROM A SEQUENTIAL FILE.
C            THE ROUTINE CAN ALSO READ STATION CALL LETTERS.
C
C        VARIABLES (INPUT/OUTPUT)
C
C              KFILDO = UNIT NUMBER OF DEFAULT PRINT FOR MOS-2000
C                       ROUTINES. HERE KFILDO IS A SCRATCH FILE.
C              KFILIN = UNIT NUMBER OF THE INPUT TDLPACK FILE.
C               CFILP = CHARACTER*60 VARIABLE THAT CONTAINS THE NAME OF
C                       THE TDLPACK FILE (SEQ OR RA).
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE READ.
C                 ND5 = MAXIMUM SIZE OF RECORD. USED TO DIMENSION IPACK( ).
C               IVECT = FLAG FOR WHETHER THE '-invect' COMMAND LINE OPTION IS GIVEN.
C              L3264B = DEFAULT BIT SIZE OF INTEGERS.
C               NBYWD = WORD SIZE OF INTEGERS.
C                NREC = NUMBER OF RECORDS READ FROM INPUT TDLPACK FILE.
C            IPACK(I) = INTEGER ARRAY (I=1,ND5) TO HOLD TDLPACK DATA IN PACKED FORMAT.
C            CCALL( ) = CHARACTER*8 VARIABLE ARRAY OF SIZE ND1 TO HOLD
C                       STATION CALL LETTERS.
C                NSTA = NUMBER OF STATIONS READ FROM INPUT TDLPACK FILE.
C            IRECTYPE = VALUE FOR EACH TYPE OF RECORD FOUND IN A TDLPACK FILE.
C                       1 = STATION CALL LETTERS
C                       2 = TDLPACK DATA
C                       3 = TRAILER RECORD
C              IOCTET = NUMBER OF BYTES A RECORD CONTAINS. THIS VALUE COMES FROM THE
C                       TDLPACK FILE.
C                 IER = ERROR RETURN VALUE FROM SUBROUTINES.
C
C        VARIABLES (INTERNAL)
C
C                 IOS = HOLDS THE IOSTAT VALUE FROM FORTRAN I/O STATEMENTS.
C        IRECTPE_PREV = SAVED INTEGER THAT HOLDS IRECTYPE FROM THE PREVIOUS
C                       ENTRY INTO TDLP_READ_RA.
C               ITEMP = HOLDS THE FIRST 4 BYTES OF THE TDLPACK RECORD (IPACK(1)).
C               JD(I) = ID TO SEARCH FOR. (I=1,4)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).
C              NTRASH = JUNK VARIABLE.
C
C        MOS-2000 SUBROUTINES CALLED
C           BSWAP
C
      IMPLICIT NONE
C        INPUT/OUTPUT VARIABLES
      INTEGER, INTENT(IN) :: KFILDO,KFILIN,ND1,ND5,L3264B
      INTEGER, INTENT(IN) :: IVECT,NBYWD,NREC
      INTEGER, INTENT(INOUT) :: IPACK(ND5),IER,NSTA,IRECTYPE,IOCTET
      CHARACTER*8, INTENT(INOUT) :: CCALL(ND1)
      CHARACTER*60, INTENT(IN) :: CFILP
C        INTERNAL VARIABLES
      CHARACTER*4 :: CTEMP
      INTEGER :: II,IOS,NTRASH,ITEMP
      INTEGER,  SAVE :: IRECTYPE_PREV
C        INITIALIZE VARIABLES
      CTEMP='    '
      IER=0
C
C        READ FROM TDLPACK SEQUENTIAL FILE. HERE WE ARE READING
C        INTO IPACK( ), SO BYTE-SWAPPING IS OCCURRING.
C
      IF(NBYWD.EQ.4)THEN
         READ(KFILIN,IOSTAT=IOS,ERR=900,END=910)NTRASH,IOCTET,
     1       (IPACK(II),II=1,IOCTET/NBYWD)
      ELSEIF(NBYWD.EQ.8)THEN
         READ(KFILIN,IOSTAT=IOS,ERR=900,END=910)IOCTET,
     1       (IPACK(II),II=1,IOCTET/NBYWD)
      ENDIF
C
C        BASED OF RECORD SIZE AND IPACK(1), DETERMINE
C        TDLPACK RECORD TYPE, IRECTYPE.
C
      IF(IOCTET.LT.24)THEN
         IRECTYPE=1
      ELSEIF(IOCTET.EQ.24)THEN
         IF(IPACK(1).EQ.0)THEN
C              MUST BE A TRAILER RECORD
            IRECTYPE=3
         ELSE
C              ONLY RECORD TYPE THAT IS 24 BYTES AND NOT
C              THE TRAILER WOULD BE A STATION CALL LETTER
C              RECORD OF 2 STATIONS.
            IRECTYPE=1
         ENDIF
      ELSEIF(IOCTET.GT.24)THEN
         ITEMP=IPACK(1)
         CTEMP=TRANSFER(ITEMP,CTEMP)
         IF(CTEMP.EQ.'TDLP')THEN
            IRECTYPE=2
         ELSEIF(CTEMP.EQ.'PLDT')THEN
            CALL BSWAP(ITEMP)
            CTEMP=TRANSFER(ITEMP,CTEMP)
            IF(CTEMP.EQ.'TDLP')THEN
               IRECTYPE=2
            ENDIF
         ELSE
            IRECTYPE=1
         ENDIF
      ENDIF
C
C        ONLY NEED TO CHECK IF IRECTYPE=1. THE INTITAL READ ABOVE
C        READS INTO IPACK( ), AN INTEGER ARRAY. SINCE THE FILE IS
C        OPENED WITH CONVERT='BIG_ENDIAN', READING INTO AN INTEGER
C        WILL BYTE SWAP, BUT READING INTO A CHARACTER WILL NOT.
C
      IF(IRECTYPE.EQ.1)THEN
         BACKSPACE(KFILIN)
         IF(NBYWD.EQ.4)THEN
            READ(KFILIN,IOSTAT=IOS,ERR=900,END=910)NTRASH,IOCTET,
     1          (CCALL(II),II=1,IOCTET/8)
         ELSEIF(NBYWD.EQ.8)THEN
            READ(KFILIN,IOSTAT=IOS,ERR=900,END=910)IOCTET,
     1          (CCALL(II),II=1,IOCTET/8)
         ENDIF
         NSTA=IOCTET/8
         IF(NSTA.GT.ND1)THEN
            WRITE(6,190)
 190        FORMAT(/' error: maximum number of stations exceeded.'/)
            CALL ITDLP_STOP
         ENDIF
      ENDIF
C
C        CHECK SOME SPECIAL CONDITIONS BASED OFF OF IVECT
C
      IF(IVECT.EQ.1.AND.NREC.EQ.1.AND.IRECTYPE.NE.1)THEN
         WRITE(6,200)
 200     FORMAT(/' error: data in first record are not station ',
     1           'call letters.'/)
         CALL ITDLP_STOP
      ENDIF
      GO TO 990
C
C        ERROR HANDLING
C
 900  WRITE(6,9001)CFILP,IOS
 9001 FORMAT(/' error: trouble reading input file: ',A,
     1       /'        iostat = ',I0.0/) 
      CALL ITDLP_STOP
 910  IER=910
C
 990  IRECTYPE_PREV=IRECTYPE
      RETURN
      END SUBROUTINE TDLP_READ_SQ
