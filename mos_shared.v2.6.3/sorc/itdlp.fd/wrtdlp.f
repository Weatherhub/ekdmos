      SUBROUTINE WRTDLP(KFILDO,KFILIO,FSIZE,L3264B,L3264W,NBYWD,ND1,ND5,
     1                  NSTA,NCALL,CCALL,IPACK,IOCTET,NEWDD,CNEWDDFILE,
     2                  IRECTYPE,ICHDD,ITDLPOUT,CTDLPOUT,
     3                  NTOTBY,NTOTRC,IER)
C
C        HISTORY
C
C        APRIL     2013   ENGLE       CREATED.
C
C        PURPOSE
C
C            TO WRITE A TDLPACK DATA TO AN OUTPUT FILE
C
C        VARIABLES (INPUT/OUTPUT)
C
C              KFILDO = UNIT NUMBER OF DEFAULT PRINT FOR MOS-2000
C                       ROUTINES. HERE KFILDO IS A SCRATCH FILE.
C              KFILIO = UNIT NUMBER OF OUTPUT TDLPACK FILE.
C               FSIZE = INPUT TDLPACK FILE SIZE.
C              L3264B = DEFAULT BIT SIZE OF INTEGERS.
C               NBYWD = WORD SIZE OF INTEGERS.
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE READ.
C                 ND5 = MAXIMUM SIZE OF RECORD. USED TO DIMENSION IPACK( ).
C                NSTA = NUMBER OF STATIONS READ FROM INPUT TDLPACK FILE.
C               NCALL = COUNTER FOR THE NUMBER OF STATION CALL LETTER RECORDS READ
C                       FROM INPUT.
C            CCALL( ) = CHARACTER*8 VARIABLE ARRAY OF SIZE ND1 TO HOLD
C                       STATION CALL LETTERS.
C            IPACK(I) = INTEGER ARRAY (I=1,ND5) TO HOLD TDLPACK DATA IN PACKED FORMAT.
C              IOCTET = NUMBER OF BYTES A RECORD CONTAINS. THIS VALUE COMES FROM THE
C                       TDLPACK FILE.
C               NEWDD = THE NEW DD VALUE GIVEN IN THE COMMAND LINE OPTION '-change-dd'.
C          CNEWDDFILE = CHARACTER*256 VARIABLE THAT CONTAINS THE NAME OF
C                       THE OUTPUT TDLPACK FILE WITH A NEW DD.
C            IRECTYPE = VALUE FOR EACH TYPE OF RECORD FOUND IN A TDLPACK FILE.
C                       1 = STATION CALL LETTERS
C                       2 = TDLPACK DATA
C                       3 = TRAILER RECORD
C               ICHDD = FLAG FOR WHETHER THE COMMAND LINE OPTION '-change-dd' IS GIVEN
C            ITDLPOUT = FLAG FOR WHEHTER THE '-tdlp' OPTION HAS BEEN INVOKED.
C            CTDLPOUT = CHARACTER*256 VARIABLE THAT CONTAINS THE FILENAME OF
C                       OUTPUT TDLPACKFILE USING THE '-tdlp' OPTION.
C              NTOTBY = THE TOTAL NUMBER OF BYTES WRITTEN TO THE OUTPUT
C                       TDLPACK FILE.
C              NTOTRC = THE TOTAL NUMBER OF RECORDS WRITTEN TO THE OUTPUT
C                       TDLPACK FILE.
C                 IER = ERROR RETURN VALUE FROM SUBROUTINES.
C
C        VARIABLES (INTERNAL)
C
C               CTEMP = CHARACTER*4 THAT HOLDS THE STRING 'TDLP'
C                ICCC = THE CCC PORTION OF WORD 1 OF THE MOS-2000 ID.
C              IPACK1 = CONTENTS OF IPACK(1) WHICH CONTAINS THE
C                       INTEGER REPRESENTATION OF 'TDLP'.
C              IPACK6 = CONTENTS OF IPACK(6) WHICH CONTAINS THE FIRST
C                       WORD OF THE MOS-2000 ID.
C             IPACK10 = CONTENTS OF IPACK(10) WHICH CONTAINS THE 
C                 IOS = HOLDS THE IOSTAT VALUE FROM FORTRAN I/O STATEMENTS.
C              ISOPEN = LOGICAL VARIABLE THAT IS .TRUE. WHEN THE OUTPUT
C                       TDLPACK FILE IS OPEN AND .FALSE. WHEN NOT.
C              NBYTES = THE NUMBER OF BYTES WRITTEN TO THE TDLPACK
C                       WHEN WRITING THE STATION CALL LETTER RECORD.
C              NTOTBY = THE TOTAL NUMBER OF BYTES WRITTEN TO THE OUTPUT
C                       TDLPACK FILE.
C              NTOTRC = THE TOTAL NUMBER OF RECORDS WRITTEN TO THE OUTPUT
C                       TDLPACK FILE.
C
C        MOS-2000 SUBROUTINES CALLED 
C            BSWAP, TRAIL, WRITEP
C
      IMPLICIT NONE
C        INPUT/OUTPUT VARIABLES
      CHARACTER(LEN=8) :: CCALL(ND1)
      INTEGER, INTENT(IN) :: KFILDO,KFILIO,FSIZE,L3264B,NBYWD,ND5,IOCTET
      INTEGER, INTENT(IN) :: NEWDD,IRECTYPE,ND1,NSTA,ICHDD,ITDLPOUT
      INTEGER, INTENT(IN) :: NCALL
      INTEGER, INTENT(INOUT) :: IPACK(ND5),NTOTBY,NTOTRC,IER
      CHARACTER(LEN=*) :: CNEWDDFILE,CTDLPOUT
C        INTERNAL VARIABLES
      CHARACTER*4 :: CTEMP
      CHARACTER*256, SAVE :: CFILNEW
      INTEGER :: J,K,NBYTES(2),IFIRST,L3264W
      INTEGER :: IPACK1,IPACK6,IPACK10,ICCC,NWORDS,IOS
      INTEGER,SAVE :: NCALL_PREV
      LOGICAL :: ISOPEN
C
      DATA IFIRST/0/,NCALL_PREV/1/
C        INITIALIZE VARIABLES
      IPACK1=0
      IPACK6=0
      IPACK10=0
      ICCC=0
      L3264W=64/L3264B
      NBYTES(:)=0
C
C        OPEN OUTPUT TDLPACK FILE
C
      IF(IFIRST.EQ.0)THEN
         IF(ITDLPOUT.EQ.1) CFILNEW=CTDLPOUT
         IF(ICHDD.EQ.1) CFILNEW=CNEWDDFILE
         INQUIRE(UNIT=KFILIO,OPENED=ISOPEN)
         IF(ISOPEN)THEN
            WRITE(6,100)
 100        FORMAT(/'error: File already open.'/)
            CALL ITDLP_STOP
         ENDIF
         OPEN(UNIT=KFILIO,FILE=CFILNEW,FORM="UNFORMATTED",
     1        CONVERT="BIG_ENDIAN",STATUS="NEW",IOSTAT=IOS)
      ELSE
         OPEN(UNIT=KFILIO,FILE=CFILNEW,FORM="UNFORMATTED",
     1        CONVERT="BIG_ENDIAN",STATUS="UNKNOWN",
     2        ACCESS="SEQUENTIAL",POSITION="APPEND",IOSTAT=IOS)
      ENDIF
C
      IF(IOS.NE.0)THEN
         WRITE(6,105)IOS
 105     FORMAT(/' error: Trouble opening new DD file. ios = ',I3/)
         CALL ITDLP_STOP
      ENDIF
C
C        WRITE TRAILER RECORD IF NCALL IS DIFFERENT THAN THE
C        PREVIOUS THROUGH HERE AND TDLPACK RECORDS ARE STATION (VECTOR)
C        (I.E. NSTA .GT. 0)
C
      IF(NSTA.GT.0)THEN
         IF(IFIRST.EQ.0)THEN
            NBYTES(8/NBYWD)=NSTA*8
            WRITE(KFILIO)(NBYTES(J),J=1,8/NBYWD),(CCALL(K),K=1,NSTA)
            NTOTRC=NTOTRC+1
            NTOTBY=NTOTBY+(NSTA*8)+8
         ELSEIF(IFIRST.GT.0)THEN
            IF(NCALL.GT.NCALL_PREV)THEN
               CALL TRAIL(KFILDO,KFILIO,L3264B,L3264W,NTOTBY,NTOTRC,IER)
               NBYTES(8/NBYWD)=NSTA*8
               WRITE(KFILIO)(NBYTES(J),J=1,8/NBYWD),(CCALL(K),K=1,NSTA)
               NTOTRC=NTOTRC+1
               NTOTBY=NTOTBY+(NSTA*8)+8
            ENDIF
         ENDIF
      ENDIF
C
C        IRECTYPE = 2 SIGNALS A TDLPACK RECORD. 
C
      IF(IRECTYPE.EQ.2)THEN
C
C           ASSUME THAT IPACK(1)='TDLP' INTERNALLY WHEN THE RECORD CONTAINS
C           A TDLPACK DATA RECORD; ELSE, HERE WE WILL ASSUME THE RECORD ARE 
C           STATION CALL LETTERS. THIS ASSUMPTION IS PRETTY SAFE BECAUSE
C           ITDLP WOULD NOT EVEN MAKE INTO THIS ROUTINE IF THE INPUT FILE
C           WAS NOT TDLPACK.
C
         IPACK1=IPACK(1)
         CTEMP=TRANSFER(IPACK1,CTEMP)
         IF(CTEMP.EQ.'TDLP')THEN
C              THE DATA IN THE RECORD IS TDLPACK, THEREFORE
C              MANAULLY SWAP THE IPACK1 AND GET ID AND DD
C              INFORMATION
            CALL BSWAP(IPACK1)
            IPACK(1)=IPACK1
         ENDIF
C           PERFORM THE FOLLOWING ONLY WHEN CHANGING THE DD.
         IF(ICHDD.EQ.1)THEN
            IPACK6=IPACK(6)
            IPACK10=IPACK(10)
            ICCC=INT(IPACK6/1E+06)
C
            IF((ICCC.GE.001.AND.ICCC.LE.099).OR.
     1         (ICCC.GE.200.AND.ICCC.LE.299))THEN
C                 CHANGE THE DD
               IPACK6=((IPACK6/100)*100)+NEWDD
               CALL MVBITS(NEWDD,0,8,IPACK10,0)
               IPACK(6)=IPACK6
               IPACK(10)=IPACK10
            ENDIF
C
         ENDIF
C
C        WRITE THE MODIFIED TDLPACK DATA RECORD TO THE NEW
C        SEQUENTIAL FILE
C
      NWORDS=IOCTET/NBYWD
      CALL WRITEP(KFILDO,KFILIO,IPACK,NWORDS,NTOTBY,NTOTRC,
     1            L3264B,IER) 
      IF(IER.NE.0)THEN
         WRITE(6,190)
 190     FORMAT(/' error: Trouble writing TDLPACK record to file'/)
         CALL ITDLP_STOP
      ENDIF
      ENDIF ! ON IRECTYPE
C
C        COMPARE THE NUMBER OF BYTES WRITTEN TO THE NEW FILE
C        WITH THE FILE SIZE OF THE ORIGINAL INPUT FILE.
C
C 200  IF(NTOTBY+(NTOTRC*8).EQ.FSIZE)THEN
C         CLOSE(21)
C      ENDIF
C
  200 NCALL_PREV=NCALL
      IFIRST=IFIRST+1
      RETURN
      END SUBROUTINE WRTDLP
