      SUBROUTINE U130(KFILDI,KFILDO,ID,IDPARS,JD,JP,
     1                PLAIN,ISCALD,SMULT,SADD,ORIGIN,
     2                CINT,UNITS,THRESH,ND4,
     3                IPACK,IWORK,DATA,ND5,
     4                JFOPEN,MODNUM,KFILIN,NAMIN,KFILIX,
     5                NAMIX,ND6,IS0,IS1,IS2,IS4,ND7,
     6                IDATE,NWORK,ND8,LDATES,ND9,ND10,L3264B)
C
C$$$   SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: U130
C   PRGMMR: RUDACK          ORG: W/OSD21          DATE: 2003-06-01
C
C ABSTRACT: PROGRAM U130 IS DESIGNED TO PACK GRIB1 OR GRIB2 DATA
C           INTO TDLPACK FORMAT.  A BITMAP CAN BE USED
C           PROVIDED THAT IT IS A TDLPACKED EXTERNAL GRIDDED
C           RANDOM ACCESS FILE.  THIS PROGRAM SHOULD BE RUN ON
C           NCEP'S IBM PLATFORM BECAUSE U130 UTILIZES SOME OF
C           NCEP'S LIBRARY ROUTINES.  U130 MAY BE RUN USING
C           32-BIT INTEGERS OR 64-BIT INTEGERS.  HOWEVER,
C           IF 64-BIT INTEGERS ARE USED, ALL RELEVANT LIBRARY
C           ROUTINES MUST ALSO BE IN 64-BIT INTEGER FORM.
C           THE BIT PREFERENCE IS CHOSEN IN THE DRIVER AND IS
C           COMPILED WITH THE PARAMETER STATEMENT:
C              PARAMETER (L3264B=32) FOR THE 32-BIT MACHINE AND
C              PARAMETER (L3264B=64) FOR THE 64-BIT MACHINE.
C
C PROGRAM HISTORY LOG:
C    JUNE       2003   RUDACK  MDL   MOS-2000
C    OCTOBER    2004   RUDACK  TURNED ON IP11 TO ALLOW FOR  
C                              THE CAPABILITY OF WRITING
C                              THE RAW GRIB VALUES TO IP11
C                              FOR DATA CHECKOUT PURPOSES.
C                              DATA IS WRITTEN AT THE GRID
C                              SPECIFICATIONS SET IN THE
C                              GRID LIST FILE.
C    OCTOBER    2004   RUDACK  ADDED CAPABILITY TO PROCESS
C                              GRIB2 DATA. 
C    SEPTEMBER  2005   RUDACK  MODIFIED CODE TO MEET
C                              OPERATIONAL REQUIREMENTS.
C    NOVEMBER   2007   WIEDENFELD FINISHED OPERATIONAL REQUIREMENTS.
C    OCTOBER    2012   ENGLE   INTIALIZED NPRED=0
C
C USAGE: CALLED BY GRIBTOMDLPK
C
C DATA SET USE
C    INPUT FILES:
C       FORT.KFILDI    - UNIT NUMBER OF INPUT FILE.  (INPUT)
C       FORT.KFILDT    - UNIT NUMBER WHERE THE DATE LIST IS LOCATED.
C                        (INPUT)
C       FORT.KFILIN(J) - UNIT NUMBERS FOR INPUT DATA (J=1,NUMIN).  (INPUT) 
C       FORT.KFILIX(J) - UNIT NUMBERS OF GRIB INDEX FILES CORRESPONDING 
C                        TO DATA INPUT FILES(J=1,NUMIN).  (INPUT) 
C       FORT.KFILRA    - UNIT NUMBER OF GRIDDED RANDOM ACCESS FILE. (INPUT)
C       FORT.KFILIC    - UNIT NUMBER OF FILE CONTAINING THE GRID LIST
C                        TABLE.  (INPUT)
C       FORT.KFILIE    - UNIT NUMBER OF FILE CONTAINING THE ELEMENT 
C                        LIST.  (INPUT)
C       FORT.KFILP     - UNIT NUMBER OF FILE CONTAINING THE MOS-2000 
C                        BITMAP VARIABLE ID.  (INPUT)
C       FORT.KFILCP    - UNIT NUMBER FOR THE VARIABLE CONSTANTS DIRECTORY.
C                        (INPUT)
C    OUTPUT FILES:
C       FORT.KFILDO    - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C       FORT.KFILIO    - UNIT NUMBER OF GRIDDED TDLPACK OUTPUT FILE.
C                        (OUTPUT)
C            IP(J)     - UNIT NUMBERS FOR OPTIONAL OUTPUT (SEE IP( )
C                        UNDER "VARIABLES" BELOW.)  (J=1,25)  (OUTPUT)
C VARIABLES:
C              KFILDI = UNIT NUMBER TO READ INPUT FILE 'U130.CN'.
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  INITIALLY,
C                       THIS IS SET BY DATA STATEMENT.  LATER, IN 
C                       IPOPEN, IF IP(1) NE 0, KFILDO IS SET = IP(1).
C                       THIS ALLOWS CHANGING THE "DEFAULT" PRINT FILE ON 
C                       THE FLY.  OTHERWISE, ON SOME SYSTEMS, THE OUTPUT
C                       FILE MIGHT HAVE THE SAME NAME AND BE
C                       OVERWRITTEN.  WHEN THE OUTPUT FILE IS NOT THE
C                       ORIGINAL DEFAULT, THE NAME IS GENERATED AND CAN
C                       BE DIFFERENT FOR EACH RUN.
C             ID(J,N) = THE INTEGER VARIABLE BITMAP ID (J=1,4) (N=1,ND4).
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE
C                       BITMAP VARIABLE ID CORRESPONDING TO ID( ,N)
C                       (J=1,15), (N=1,ND4).
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 
C                            1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK 
C                            IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID'S (J=1,4) 
C                       (N=1,ND4).
C                       THIS IS THE SAME AS ID(J,N), EXCEPT THAT THE
C                       PORTIONS PERTAINING TO PROCESSING ARE OMITTED:
C                       B = IDPARS(3, ),
C                       T = IDPARS(8,),
C                       I = IDPARS(13, ),
C                       S = IDPARS(14, ),
C                       G = IDPARS(15, ), AND
C                       THRESH( ).
C                       JD( , ) IS USED TO IDENTIFY THE BASIC MODEL
C                       FIELDS AS READ FROM THE ARCHIVE.
C             JP(J,N) = JP( ,N) INDICATES WHETHER (>0) OR NOT (=0)
C                       VARIABLE N WILL BE OUTPUT FOR VIEWING 
C                       (N=1,ND4).
C                       J=1--GRIDPOINT VALUES,
C                       J=2--GRIDPRINT WITH CONTOURS, AND
C                       J=3--INTERPOLATED VALUES.
C                       (NOT USED)
C            PLAIN(N) = THE PLAIN LANGUAGE DESCRIPTION OF THE BITMAP 
C                       VARIABLE (N=1,ND4).  (CHARACTER*32)
C           ISCALD(N) = THE DECIMAL SCALING FOR THE BITMAP VARIABLE 
C                       RETRIEVED BY 'RDPRED'.  NO BINARY SCALING IS 
C                       PROVIDED FOR.
C            SMULT(N) = THE MULTIPLICATIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (NOT USED)
C             SADD(N) = THE ADDITIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (NOT USED)
C           ORIGIN(N) = THE CONTOUR ORIGIN, APPLIES TO THE UNITS IN
C                       UNITS(N) (N=1,ND4).  (NOT USED)
C             CINT(N) = THE CONTOUR INTERVAL, APPLIES TO THE UNITS IN
C                       UNITS(N) (N=1,ND4).  (NOT USED)
C            UNITS(N) = THE UNITS OF THE DATA THAT APPLY AFTER
C                       MULTIPLYING BY SMULT(N) AND ADDING SADD(N) 
C                       (N=1,ND4).  (CHARACTER*12)  (NOT USED)
C           THRESH(N) = THE BINARY THRESHOLD ASSOCIATED WITH 
C                       IDPARS( ,N), N=1,ND4).  (NOT USED)
C                 ND4 = THE NUMBER OF BITMAP VARIABLES IN THE VARIABLE 
C                       LIST. SINCE U130 IS DESIGNED TO USE ONLY ONE 
C                       BITMAP VARIABLE, ND4 SHOULD BE SET TO A VALUE 
C                       OF ONE IN THE DRIVER.  
C            IPACK(J) = WORK ARRAY THAT STORES THE METADATA AND DATA 
C                       IN TDLPACK FORM (J=1,ND5). 
C            IWORK(J) = A WORK ARRAY (J=1,ND5).
C             DATA(J) = CONTAINS THE BITMAP FIELD (J=1,ND5). 
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ) AND DATA( ).  
C                       SINCE IT CANNOT BE KNOWN THE SIZE OF EACH 
C                       RECORD BEFORE READING IT, ND5 SHOULD BE AT 
C                       LEAST AS LARGE AS THE GRID DIMENSION 
C                       (I.E., NX*NY) OF THE DATA ON THE GRIB FILE.  
C                       SET BY PARAMETER IN DRU130.  
C           JFOPEN(J) = FOR EACH FILE IN KFILIN(J), JFOPEN(J) IS 1 WHEN
C                       THE FILE IS OPEN, IS 0 WHEN IT HAS ALREADY BEEN
C                       USED AND IS 2 WHEN THE FILE HAS NOT BEEN OPENED 
C                       (J=1,NUMIN).
C           MODNUM(J) = THE "MODEL" NUMBER CORRESPONDING TO KFILIN(J),
C                       AND NAMIN(J) (J=1,NUMIN).  (NOT USED)
C           KFILIN(J) = UNIT NUMBERS FOR INPUT DATA, ALL IN GRIB 
C                       FORMAT (J=1,NUMIN).
C            NAMIN(J) = HOLDS DATA SET NAMES FOR THE UNIT NUMBERS IN 
C                       KFILIN(J) (J=1,NUMIN).  (CHARACTER*60)
C           KFILIX(J) = UNIT NUMBERS OF GRIB INDEX FILES CORRESPONDING
C                       TO DATA INPUT FILES(J=1,NUMIN). 
C            NAMIX(J) = HOLDS DATA SET NAMES FOR UNIT NUMBERS KFILIX(J)
C                       (J=1,NUMIN). 
C                 ND6 = MAXIMUM NUMBER OF INPUT FILES THAT CAN BE DEALT
C                       WITH IN ONE RUN. DIMENSION OF KFILIN( ) AND
C                       NAMIN( ).  SET BY PARAMETER IN DRU130.
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,4).
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,21+).
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  MAXIMUM SIZE IS FOR
C                       IS1( ) = 22 PLUS 32 CHARACTERS (ONE CHARACTER
C                       PER WORD) OF PLAIN TEXT = 54.  SET BY PARAMETER.
C            IDATE(J) = INITIAL DATE LIST (J=1,NDATES) WHICH MAY CONTAIN
C                       NEGATIVE VALUES INDICATING A DATE SPAN.
C                       THIS IS MODIFIED IN DATPRO TO CONTAIN THE
C                       COMPLETE DATE LIST WITH THE DATES IN THE SPANS
C                       FILLED IN (J=1,NDATES), WHERE NDATES HAS BEEN
C                       INCREASED IF NECESSARY.  DATES ARE INPUT AS
C                       YYMMDDHH AND MODIFIED TO YYYYMMDDHH.  ZEROS IN 
C                       THE INPUT ARE ELIMINATED.  TERMINATOR IS 
C                       99999999.  MAXIMUM NUMBER OF DATES IS ND8.
C            NWORK(J) = A WORK ARRAY (J=1,ND8).
C                 ND8 = DIMENSION OF IDATE( ).  SET BY PARAMETER IN DRU130.
C           LDATES(J) = CONTAINS ALL THE DATES ON THE GRIB FILE IN
C                       CHRONOLOGICAL ORDER (J=1,ND9).  
C                 ND9 = MAXIMUM NUMBER OF RECORDS THAT ARE ANTICIPATED 
C                       TO BE ON A PARTICULAR GRIB FILE.  SET BY 
C                       PARAMETER IN DRU130.
C                ND10 = MAXIMUM NUMBER OF ELEMENTS THAT CAN BE PROCESSED  
C                       IN THE ELEMENT LIST FILE.  SET BY PARAMETER 
C                       IN DRU130.  
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING
C                       USED (EITHER 32 OR 64).  SET BY PARAMETER.
C               NUMIN = THE NUMBER OF VALUES IN KFILIN( ), NAMES IN
C                       NAMIN( ), ETC.  MAXIMUM OF ND6.  THIS IS REDUCED
C                       IF THERE IS NO VARIABLE WITH A PARTICULAR
C                       MODEL NUMBER.
C              KFILDT = THE UNIT NUMBER FOR WHERE THE DATE LIST IS
C                       LOCATED.
C              DATNAM = HOLDS DATA SET NAME FOR THE UNIT NUMBER IN
C                       KFILDT.  (CHARACTER*60) 
C               IP(J) = EACH VALUE (J=1,25) INDICATES WHETHER (>1)
C                       OR NOT (=0) CERTAIN INFORMATION WILL BE WRITTEN.
C                       WHEN IP( ) > 0, THE VALUE INDICATES THE UNIT
C                       NUMBER FOR OUTPUT.  THESE VALUES SHOULD NOT BE
C                       THE SAME AS ANY KFILX VALUES EXCEPT POSSIBLY
C                       KFILDO, WHICH IS THE DEFAULT OUTPUT FILE.  THIS
C                       IS ASCII OUTPUT, GENERALLY FOR DIAGNOSTIC
C                       PURPOSES. THE FILE NAMES WILL BE 4 CHARACTERS
C                       'U130', THEN 4 CHARACTERS FROM IPINIT, THEN 
C                       2 CHARACTERS FROM IP(J) (E.G., 'U130DER130').
C                       THE ARRAY IS INITIALIZED TO ZERO IN CASE LESS
C                       THAN THE EXPECTED NUMBER OF VALUES ARE READ IN.
C                       (1) = ALL ERRORS AND OTHER INFORMATION NOT
C                             SPECIFICALLY IDENTIFIED WITH OTHER IP( )
C                             NUMBERS.  WHEN IP(1) IS READ AS NONZERO,
C                             KFILDO, THE DEFAULT OUTPUT FILE UNIT NUMBER,
C                             WILL BE SET TO IP(1).  WHEN IP(1) IS READ
C                             AS ZERO, KFILDO WILL BE USED UNCHANGED.
C                       (2) = THE INPUT DATES IN IDATE( ).  WHEN THERE
C                             ARE ERRORS, PRINT WILL BE TO UNIT KFILDO AS 
C                             WELL AS TO UNIT IP(2).
C                       (3) = THE OUTPUT DATES IN IDATE( ).  WHEN THERE
C                             ARE ERRORS, OUTPUT WILL BE TO UNIT KFILDO AS 
C                             WELL AS TO UNIT IP(3).
C                       (4) = THE CORRESPONDING MOS-2000 IDS THAT ARE TO
C                             BE TDLPACKED.
C                       (6) = THE BITMAP VARIABLE AS IT IS READ IN.  
C                             THIS IS GOOD FOR CHECKOUT; 
C                             FOR ROUTINE OPERATION, IP(7), IP(8), AND/OR 
C                             IP(9), MAY BE BETTER.  
C                       (7) = THE BITMAP VARIABLE LIST IN SUMMARY FORM.
C                             IF THERE ARE ERRORS, THE BITMAP VARIABLE LIST  
C                             WILL BE WRITTEN TO THE DEFAULT OUTPUT FILE 
C                             UNIT KFILDO AS WELL AS TO UNIT IP(7).
C                             THIS LIST INCLUDES THE PARSED ID'S IN IDPARS( , ).
C                       (8) = THE BITMAP VARIABLE LIST IN SUMMARY FORM AFTER 
C                             AFTER REORDERING.  THIS LIST INCLUDES THE PARSED 
C                             ID'S IN IDPARS( , ).
C                       (9) = THE BITMAP VARIABLE LIST IN SUMMARY FORM AFTER
C                             REORDERING.  THIS DIFFERS FROM (8) IN THAT (9)
C                             DOES NOT INCLUDE THE PARSED ID'S IN IDPARS( , ),
C                             BUT RATHER INCLUDES THE INFORMATION TAKEN
C                             FROM THE CONSTANT FILE ON UNIT KFILCP.
C                      (11) = GRIB GRIDDED VALUES PRINTED TO THE NEAREST 
C                             THOUSANDTHS PLACE.   
C                      (12) = PRINT OF THE BITMAP VALUE AS READ FROM THE
C                             EXTERNAL GRIDDED RANDOM ACCESS FILE.
C              OUTNAM = NAME OF TDLPACK OUTPUT FILE (CHARACTER*60)
C              KFILIO = UNIT NUMBER OF TDLPACK OUTPUT FILE.
C              KFILRA = UNIT NUMBER OF TDLPACK GRIDDED RANDOM ACCESS
C                       FILE; MAXIMUM NUMBER OF FILES IS ONE. 
C              RACESS = NAME OF TDLPACK GRIDDED RANDOM ACCESS FILE 
C                       DATA SET.  (CHARACTER*60)  
C              KFILIE = UNIT NUMBER OF ELEMENT LIST FILE.  
C              ELENAM = NAME OF ELEMENT LIST FILE (CHARACTER*60)  
C              KFILIC = UNIT NUMBER OF GRID LIST FILE. 
C              CORNAM = NAME OF GRID LIST FILE.  (CHARACTER*60)            
C               KFILP = UNIT NUMBER OF FILE CONTAINING THE MOS-2000 
C                       BITMAP VARIABLE ID LIST.
C              PRENAM = NAME OF FILE CONTAINING THE MOS-2000 
C                       BITMAP VARIABLE ID LIST. (CHARACTER*60)
C              KFILCP = UNIT NUMBER FOR THE VARIABLE CONSTANTS DIRECTORY 
C                       FILE.
C              CONNAM = NAME OF FILE CONTAINING THE VARIABLE CONSTANTS 
C                       DIRECTORY.  (CHARACTER*60)
C               RUNID = INFORMATION INPUT TO IDENTIFY THE OUTPUT.
C                       (CHARACTER*72)
C              NTOTBY = THE TOTAL NUMBER OF BYTES ON THE FILE ASSOCIATED
C                       WITH UNIT NUMBER KFILIO (THE OUTPUT TDLPACK FILE).
C                       IT IS UPDATED WHEN THE DATA IN IPACK( ) ARE
C                       WRITTEN.
C              NTOTRC = THE TOTAL NUMBER OF RECORDS IN THE FILE.  IT IS
C                       UPDATED AS NEEDED IN WRITEP.  
C              NDATES = NUMBER OF VALUES IN IDATE( ).  MODIFIED AS 
C                       NECESSARY IN DATPRO.
C              IPINIT = 4 CHARACTERS, USUALLY A USER'S INITIALS PLUS
C                       A RUN NUMBER, TO APPEND TO 'U130' TO 
C                       IDENTIFY A PARTICULAR SEGMENT OF OUTPUT
C                       INDICATED BY A SUFFIX IP(J).  THE RUN NUMBER
C                       ALLOWS MULTIPLE RUNS OF U130 AND WRITING OF 
C                       UNIQUELY NAMED FILES, PROVIDED THE USER USES A 
C                       DIFFERENT RUN NUMBER FOR EACH RUN.
C             IDUM(J) = SCRATCH ARRAY (J=1,2).
C            ITEMP(J) = WORK ARRAY (J=1,14).
C                 IER = STATUS RETURN.
C                       0 = GOOD RETURN.  SEE CALLED ROUTINES FOR OTHER
C                       VALUES.
C                       OTHER VALUES RETURNED FROM SUBROUTINES.
C               STATE = VARIABLE SET TO STATEMENT NUMBER TO INDICATE
C                       WHERE AN ERROR OCCURRED.  (CHARACTER*4)
C               BLANK = 8 BLANKS.  (CHARACTER*8)
C               MINPK = MINIMUM GROUP SIZE WHEN PACKING THE GRIDDED DATA
C                       VALUES.  SET IN DATA STATEMENT.
C              PXMISS = VALUE ASSIGNED TO MISSING DATA IN THE GRIB MESSAGE.
C              XMISSP = VALUE TO PACK AS A PRIMARY MISSING. 
C                       (SET IN DATA STATEMENT, XMISSP=9999.). 
C              XMISSS = VALUE ASSIGNED TO A MASKED GRIDPOINT. 
C                       (SET IN U130.CN).                 
C            ISTOP(1) = ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT IS NOT FATAL.
C            ISTOP(2) = ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       A DATA RECORD WAS NOT FOUND.
C               JFLAG = 1 INDICATES THAT AN EXTERNAL GRIDDED RANDOM
C                       ACCESS FILE IS BEING USED TO MASK THE DATA.
C             JCONVRT = FLAG INDICATING IF GRIB1 (=1) OR GRIB2 (=2) DATA 
C                       IS TO BE TDLPACKED.
C
C EXIT STATES:   0 - SUCCESSFUL RUN
C              128 - INCORRECT CONVERSION VALUE, MUST BE 1 OR 2.
C              134 - CANNOT READ NCEP DATE FILE.
C              141 - NO MODEL INPUT DATA SETS.
C             1415 - NO GRIB INDEX FILE.
C             1416 - NUMBER OF GRIB INPUT DOESNOT EQUAL THE NUMBER
C                    OF GRIB INDEX FILES.
C             1425 - NO OUTPUT DATASET PROVIDED.
C             1430 - NO GRIB ELEMENT LIST PROVIDED.
C             1457 - NO GRID LIST FILE PROVIDED.
C              161 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C              183 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C             1901 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C             1910 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C             1920 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C             1930 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C             1940 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C             1950 - INCONSISTENCY IN INPUT UNIT NUMBERS.
C              210 - VARIABLE LIST HAS BEEN ENTERED AS INPUT 
C                    HOWEVER A GRIDDED RANDOM ACCESS FILE IS NOT
C                    STIPULATED IN THE CONTROL FILE.
C              220 - A VARIABLE LIST IS NOT PRESENT IN THE BUT A 
C                    GRIDDED RANDOM ACCESS FILE IS.
C              225 - THE NUMBER OF BITMAP VARIABLES EXCEEDS ONE.
C             9999 - ERROR READING CONTROL FILE.
C 
C REMARKS:  REMOVED THE SUBROUTINE CALLS THAT PROCESS THE DATE
C           LIST AND REPLACED IT WITH SUBROUTINE 'GET_NCEPDATE'. 
C
C ATTRIBUTES:
C   LANGUAGE:  FORTRAN 90 (xlf90 compiler)
C   MACHINE:  IBM SP
C
C   SUBROUTINES CALLED: 
C      IPOPEN, IPRINT, TIMPR, RDSNAM,
C      RDPRED, RDGRIB1, RDGRIB2, W3TAGE, 
C      GET_NCEPDATE, IERX
C
C$$$
C
      CHARACTER*4 STATE,IPINIT
      CHARACTER*8 BLANK
      CHARACTER*12 UNITS(ND4)
      CHARACTER*32 PLAIN(ND4)
      CHARACTER*60 NAMIN(ND6),NAMIX(ND6)
      CHARACTER*60 OUTNAM,DATNAM,CORNAM,ELENAM,
     1             CONNAM,PRENAM,RACESS
      CHARACTER*72 RUNID/' '/
C
      DIMENSION ISCALD(ND4),SMULT(ND4),SADD(ND4),
     1          ORIGIN(ND4),CINT(ND4),THRESH(ND4)
      DIMENSION JP(3,ND4),ID(4,ND4),JD(4,ND4),IDPARS(15,ND4)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5)
      DIMENSION KFILIN(ND6),MODNUM(ND6),JFOPEN(ND6),KFILIX(ND6)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION IDATE(ND8),NWORK(ND8)
      DIMENSION LDATES(ND9)
      DIMENSION ITEMP(14),IP(25),IUSE(25),IDUM(2),ISTOP(2)
C 
      DATA ISTOP/2*0/
      DATA MINPK/14/
      DATA BLANK/' '/
      DATA IP/25*0/
      DATA INCCYL/0/
      DATA NTOTBY/0/,
     1     NTOTRC/0/
      DATA XMISSP/9999./
      DATA JFLAG/0/
      DATA IUSE/1,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0/
CINTEL
      NPRED=0
CINTEL
C
C        READ AND PROCESS THE PRINT UNIT NUMBERS.  THE INPUT UNIT
C        KFILDI HAS BEEN OPENED IN THE DRIVER OR BY SOME OTHER
C        MECHANISM SUCH AS A SCRIPT OR AN ASSIGN STATEMENT ON THE 
C        IBM.
C     
C        NOTE THAT IF KFILDO NE IP(1) (READ BELOW), THE OUTPUT FROM
C        TIMPR (IN THE DRIVER) WILL BE ON UNIT KFILDO, BUT ALL OTHER 
C        "DEFAULT" PRINT ON UNIT IP(1), UNLESS THERE IS AN ERROR ON 
C        THE OPEN STATEMENT BELOW OR THE FOLLOWING READ.
C
      STATE='108 ' 
      READ(KFILDI,108,IOSTAT=IOS,ERR=900,END=109)IPINIT,(IP(J),J=1,25) 
 108  FORMAT(A4,25I3)
C        LESS THAN 25 IP( ) VALUES WILL NOT BE INDICATED AS AN ERROR.
C        SOME IP( ) VALUES ARE NOT USED; SEE IUSE( ).
      CALL IPOPEN(KFILDO,'U130',IPINIT,IP,IER)
C        WHEN IP(1) NE 0, KFILDO HAS BEEN SET TO IP(1).
C        A FILE WILL BE OPENED FOR EVERY DIFFERENT VALUE IN IP( ).
C        THE FILE NAMES WILL BE 4 CHARACTERS 'U130' THEN 4 CHARACTERS
C        FROM IPINIT, THEN 2 CHARACTERS FROM IP(J).  IPINIT MIGHT BE
C        'DER1' INDICATING THE PERSONS INITIALS PLUS A SEQUENCE NUMBER.
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
 109  WRITE(KFILDO,110)IPINIT
 110  FORMAT(/' IPINIT = ',A4)
      CALL IPRINT(KFILDO,IP,IUSE)
C
C        TIME STAMP ALL ASCII OUTPUT OTHER THAN KFILDO.
C        THIS IS NOT DONE IN IPOPEN BECAUSE SOME PROGRAMS
C        MIGHT NOT WANT SOME FILE TO BE TIME STAMPED.
C
      DO 113 J=1,25
      IF(IP(J).EQ.0.OR.IP(J).EQ.KFILDO)GO TO 113
      IF(J.EQ.1)GO TO 112
C
      DO 111 I=1,J-1
      IF(IP(J).EQ.IP(I))GO TO 113
 111  CONTINUE
C
 112  CALL TIMPR(IP(J),IP(J),'START U130          ')
 113  CONTINUE
C
C        READ AND PRINT THE RUN IDENTIFICATION.
C
      STATE='115 '
      READ(KFILDI,115,IOSTAT=IOS,ERR=900,END=116) RUNID 
C        LESS THAN 72 CHARACTERS IS NOT CONSIDERED AN ERROR.
 115  FORMAT(A72)  
 116  WRITE(KFILDO,117)RUNID
 117  FORMAT(/' ',A72)
C
C        PRINT TO MAKE SURE USER KNOWS WHAT MACHINE IS BEING USED.
C 
      WRITE(KFILDO,119) L3264B
 119  FORMAT(/' RUNNING ON A',I3,'-BIT MACHINE.')
C
C        READ AND PRINT CONTROL INFORMATION.
C
      STATE='125 ' 
      READ(KFILDI,125,IOSTAT=IOS,ERR=900,END=1250) INCCYL,JCONVRT,
     1                                             PXMISS,XMISSS
 125  FORMAT(I10,/,I10,/,F10.0,/,F10.0)
      GO TO 1255
C        INCOMPLETE CONTROL INFORMATION SHOULD BE CONSIDERED AN ERROR.
C        HOWEVER, A SHORT RECORD DOES NOT CAUSE AN "END" CONDITION.
 1250 WRITE(KFILDO,1251)
 1251 FORMAT(/' ****CONTROL INFORMATION NOT COMPLETE.')
      ISTOP(1)=ISTOP(1)+1
C
 1255 WRITE(KFILDO,127)INCCYL,JCONVRT,PXMISS,XMISSS,MINPK,L3264B
 127  FORMAT( ' INCCYL',I10,'   INCREMENT IN HOURS BETWEEN DATE/TIMES'/,
     1        ' JCONVRT',I9,'   CONVERT DATA FROM GRIB1 (=1) OR GRIB2',
     2        ' (=2) TO TDLPACK'/,
     3        ' PXMISS',F10.0,'   VALUE ASSIGNED TO MISSING DATA IN',
     4        ' THE GRIB DATA SET'/,
     5        ' XMISSS',F10.0,'   PACKED VALUE ASSIGNED TO THE',
     6        ' MASKED DATA'/,
     7        ' MINPK ',I10,'   MINIMUM GROUP SIZE WHEN PACKING (SET',
     8        ' IN SUBROUTINE U130)',/,
     9        ' L3264B',I10,'   INTEGER WORD SIZE OF MACHINE')
C
C        CHECK THAT 'JCONVRT' IS AN ACCEPTABLE VALUE.
C
      IF((JCONVRT.NE.1).AND.(JCONVRT.NE.2)) THEN
         WRITE(KFILDO,128) JCONVRT
 128     FORMAT(/' ****THE CONVERSION VALUE OF ',I2,' IS NOT AN', 
     1           ' ACCEPTABLE VALUE.  ONLY A VALUE OF 1 OR 2 MAY',
     2           ' BE USED.',/,5X,'STOP 128 IN U130.')
         CALL W3TAGE('U130')
         STOP 128
      ENDIF 
C 
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR READING
C        DATE LIST.  FILE WILL BE OPENED AS 'OLD', UNLESS THE FILE
C        IS THE DEFAULT INPUT FILE.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILDT,DATNAM,IDUM,IDUM,1,
     1            N,'OLD','FORMATTED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,130)KFILDT,DATNAM
 130  FORMAT(/' DATE INPUT DATA SET, UNIT AND NAME.'/
     1      (' ',I4,2X,A60))
C
C        READ AND PRINT THE DATE TO BE PROCESSED.
C
      CALL GET_NCEPDATE(KFILDT,IYR,IMO,IDA,IHR,NDATE,IER)
C
      IF(IER.NE.0)THEN
         WRITE(KFILDO,134)
 134     FORMAT(/' ****ERROR: CAN NOT READ NCEP DATE FILE - ',
     1           'CATASTROPHIC ERROR IN U130.  STOP AT 134.')
         CALL W3TAGE('U130')
         STOP 134
      ENDIF
      NDATES = 1
      IDATE(1) = NDATE
      WRITE(KFILDO,135)NDATES,(IDATE(J),J=1,NDATES)
 135  FORMAT(/,' ',I4,' INPUT DATE AS READ',/,(1X,10I12))
C
C        PROCESS THE UNIT NUMBERS AND FILE NAMES FOR ALL TDLPACK 
C        INPUT.  FILES WILL NOT BE OPENED BY "RDSNAM" BUT RATHER BY
C        "BAOPEN."
C
      CALL RDSNAM(KFILDI,KFILDO,KFILIN,NAMIN,MODNUM,JFOPEN,ND6,
     1            NUMIN,'NOT','NOTOPENED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(NUMIN.GT.0)THEN
         WRITE(KFILDO,140)NUMIN,(KFILIN(M),NAMIN(M),M=1,NUMIN)
 140     FORMAT(/,I2,' MODEL INPUT DATA SETS, UNITS, MODEL NUMBERS,',
     1           ' AND NAMES.'/(' ',I3,2X,A60))
      ELSE 
         WRITE(KFILDO,141)
 141     FORMAT(/,' ****NO MODEL INPUT DATA SETS HAVE BEEN',
     1            ' STIPULATED.  FATAL ERROR.  STOP 141 IN U130.')
         CALL W3TAGE('U130')
         STOP 141
      ENDIF
C
C        PROCESS THE UNIT NUMBERS AND FILE NAMES FOR ALL GRIB INDEX
C        FILES TO BE CREATED.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILIX,NAMIX,MODNUM,JFOPEN,ND6,
     1            NUMIN1,'NOT','NOTOPENED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(NUMIN1.GT.0)THEN
         WRITE(KFILDO,1405)NUMIN1,(KFILIX(M),NAMIX(M),M=1,NUMIN1)
 1405    FORMAT(/,I2,' GRIB INDEX FILE DATA SETS, UNITS, MODEL', 
     1           ' NUMBERS AND NAMES.'/(' ',I3,2X,A60))
      ELSE
         WRITE(KFILDO,1415)
 1415    FORMAT(/,' ****NO GRIB INDEX FILE INPUT DATA SETS HAVE',
     1            ' BEEN STIPULATED.  FATAL ERROR.',
     2            '  STOP 1415 IN U130.')
         CALL W3TAGE('U130')
         STOP 1415
      ENDIF
C
C        ENSURE THAT THE NUMBER OF GRIB INPUT FILES EQUALS THE NUMBER
C        OF GRIB INDEX FILES STIPULATED IN THE CN FILE.
C
      IF(NUMIN.NE.NUMIN1) THEN
         WRITE(KFILDO,1416)
 1416    FORMAT(/,' ****THE NUMBER OF GRIB INPUT FILES DOES',
     1            ' NOT EQUAL THE NUMBER OF GRIB INDEX INPUT',
     2            ' FILES.',/,5X,'FATAL ERROR.  STOP 1416 IN U130.')
         CALL W3TAGE('U130')
         STOP 1416
      ENDIF
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR THE 
C        MOS-2000 EXTERNAL RANDOM ACCESS FILE.  THE FILE WILL 
C        BE OPENED AND READ IN "RDGRIB1" OR "RDGRIB2" BY "CONSTG".
C
      CALL RDSNAM(KFILDI,KFILDO,KFILRA,RACESS,IDUM,IDUM,1,
     1            NUMRA,'NOT','NOTOPENED',IP,IER)
C        IDUM( ) IS USED AS A SCRATCH ARRAY. 
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C  
      IF(NUMRA.NE.0)THEN
         WRITE(KFILDO,142) KFILRA,RACESS
 142     FORMAT(/' MOS-2000 EXTERNAL GRIDDED RANDOM ACCESS',
     1           ' DATA SET, UNIT, AND NAME.',/,(' ',I3,2X,A60))
      ELSE
         WRITE(KFILDO,1420) 
 1420    FORMAT(/,' NO MOS-2000 EXTERNAL GRIDDED RANDOM ACCESS',
     1            ' DATA SET PROVIDED.')
C           THE ABOVE PRINT IS FOR THE EMPTY SET.
      ENDIF
C
C        OPEN THE UNIT NUMBER AND FILE NAME FOR THE TDLPACK 
C        OUTPUT.  FILE WILL BE OPENED AS 'NEW'.  IF THE FILE
C        ALREADY EXITS, THE PROGRAM WILL TERMINATE IN 'RDSNAM'.  
C
      CALL RDSNAM(KFILDI,KFILDO,KFILIO,OUTNAM,IDUM,IDUM,1,
     1            IOUT,'NEW','UNFORMATTED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(KFILIO.NE.0)THEN
         WRITE(KFILDO,143)KFILIO,OUTNAM
 143     FORMAT(/' TDLPACK OUTPUT DATA SET, UNIT AND NAME.'/
     1         (' ',I3,2X,A60))
      ELSE
         WRITE(KFILDO,1425)
 1425    FORMAT(/' ****NO OUTPUT DATA SET PROVIDED; FATAL ERROR.',
     1           '  STOP 1425 IN U130.')
         CALL W3TAGE('U130')
         STOP 1425
      ENDIF
C
C        OPEN THE UNIT NUMBER AND FILE NAME FOR THE GRIB ELEMENT LIST.  
C
      CALL RDSNAM(KFILDI,KFILDO,KFILIE,ELENAM,IDUM,IDUM,1,
     1            IOUT,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,1440)KFILIE,ELENAM
 1440 FORMAT(/' GRIB ELEMENT DATA SET, UNIT AND NAME.'/
     1       (' ',I3,2X,A60))
C
C        ENSURE THAT AN ELEMENT LIST HAS BEEN SUPPLIED BY THE USER.
C        IF A LIST IS NOT PRESENT, TERMINATE THE PROGRAM.
C   
      IF(KFILIE.EQ.0) THEN
         WRITE(KFILDO,1431) 
 1431    FORMAT(/,' ****U130 REQUIRES A GRIB ELEMENT LIST FOR',
     1            ' PROCESSING.  STOP 1431 IN U130.')
         CALL W3TAGE('U130')
         STOP 1431
      ENDIF
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR GRID LIST
C        TABLE.
C      
      CALL RDSNAM(KFILDI,KFILDO,KFILIC,CORNAM,IDUM,IDUM,1,
     1            N,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      IF(KFILIC.EQ.0) THEN
         WRITE(KFILDO,1457)
 1457    FORMAT(/,' ****U130 REQUIRES A GRID LIST FILE FOR PROCESSING.',
     1            '  STOP 1457 IN U130.')
         CALL W3TAGE('U130')
         STOP 1457
      ENDIF
C
      WRITE(KFILDO,1458)KFILIC,CORNAM
 1458 FORMAT(/' GRID LIST DATA SET, UNIT AND NAME.'/
     1       (' ',I3,2X,A60))
C
C        READ AND PROCESS UNIT NUMBER AND FILE NAME FOR READING
C        MOS-2000 BITMAP DATA ID.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILP,PRENAM,IDUM,IDUM,1,
     1            N,'OLD','FORMATTED',IP,IER)
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
C
      IF(KFILP.EQ.0)THEN
         WRITE(KFILDO,1460)
 1460    FORMAT(/' NO MOS-2000 BITMAP ID DATA SET PROVIDED.')
      ELSE
         WRITE(KFILDO,1465)KFILP,PRENAM
 1465    FORMAT(/' MOS-2000 BITMAP ID DATA SET, UNIT AND NAME.'/
     1         (' ',I3,2X,A60))
      ENDIF
C
C        READ AND PROCESS UNIT NUMBER FOR THE VARIABLE CONSTANTS DIRECTORY.
C
      CALL RDSNAM(KFILDI,KFILDO,KFILCP,CONNAM,IDUM,IDUM,1,
     1            N,'OLD','FORMATTED',IP,IER)
C
      IF(IER.NE.0)ISTOP(1)=ISTOP(1)+1
      WRITE(KFILDO,156)KFILCP,CONNAM
 156  FORMAT(/' VARIABLE CONSTANT DIRECTORY DATA SET, UNIT AND',
     1        ' NAME.',/,(' ',I3,2X,A60))
C
C        CHECK POSSIBLE INCONSISTENCY OF INPUT UNIT NUMBERS WITH
C        OTHERS USED BY THE PROGRAM. 
C
C        NOTE: THE CHECK OF IP( ) VERSUS ALL OTHER UNIT NUMBERS IS 
C        NOT PERFORMED HERE.  A CHECK IN 'RDSNAM' ENSURES THAT THERE
C        ARE NO CONFLICT BETWEEN UNIT NUMBERS.  IF A CONFLICT IS
C        FOUND, THE IP( ) VALUE IS SET BACK TO THE DEFAULT VALUE
C        OF KFILDO (WHICH IS USUALLY 12). 
C
      IF(KFILDO.EQ.KFILDT.OR.
     1   KFILDO.EQ.KFILIO.OR.
     2   KFILDO.EQ.KFILRA.OR.
     3   KFILDO.EQ.KFILIC.OR.
     4   KFILDO.EQ.KFILIE.OR.
     5   KFILDO.EQ.KFILP.OR.
     6   KFILDO.EQ.KFILCP) THEN
         WRITE(KFILDO,160)
 160     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1            ' IN KFILDO WITH EITHER KFILDT',
     2            ' KFILIO,',/,5X,'KFILRA, KFILIC',
     3              ' KFILIE, KFILP OR KFILCP.',1X, 
     4              ' STOP IN U130 AT 161.')
         WRITE(KFILDO,161) KFILDO,KFILDT,KFILIO,KFILRA,KFILIC,
     1                     KFILIE,KFILP,KFILCP
 161     FORMAT(/,5X,'KFILDO = ',I2,/,5X,'KFILDT = ',I2,/,5X,
     1          'KFILIO = ',I2,/,5X,'KFILRA = ',I2,/,5X,
     2          'KFILIC = ',I2,/,5X,'KFILIE = ',I2,/,5X,
     3          'KFILP  = ',I2,/,5X,'KFILCP = ',I2)
         CALL W3TAGE('U130')
         STOP 161
      ENDIF
C
C        THIS SHOULD PROTECT THE LARGE DATA SETS IN NAMIN( ) 
C        FROM BEING OVERWRITTEN.
C
      DO 185 J=1,NUMIN
         IF(KFILIN(J).EQ.KFILDI.OR.
     1      KFILIN(J).EQ.KFILDO.OR.
     2      KFILIN(J).EQ.KFILDT.OR.
     3      KFILIN(J).EQ.KFILIO.OR.
     4      KFILIN(J).EQ.KFILRA.OR.
     5      KFILIN(J).EQ.KFILIC.OR.
     6      KFILIN(J).EQ.KFILIE.OR.
     7      KFILIN(J).EQ.KFILP.OR.
     8      KFILIN(J).EQ.KFILCP) THEN
            WRITE(KFILDO,182)
 182        FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1              ' IN KFILIN( ) WITH EITHER KFILDI, KFILDO,',/,4X,
     2              ' KFILDT, KFILIO, KFILRA, KFILIC,',
     3              ' KFILIE, KFILP OR KFILCP.',1X, 
     4              ' STOP IN U130 AT 183.')
            WRITE(KFILDO,183) KFILIN(J),KFILDI,KFILDO,KFILDT,KFILIO,
     1                        KFILRA,KFILIC,KFILIE,KFILP,KFILCP
 183        FORMAT(/,5X,'KFILIN = ',I2,/,5X,'KFILDI = ',I2,/,5X,
     1              'KFILDO = ',I2,/,5X,'KFILDT = ',I2,/,5X,
     2              'KFILIO = ',I2,/,5X,'KFILRA = ',I2,/,5X,
     3              'KFILIC = ',I2,/,5X,'KFILIE = ',I2,/,5X,
     4              'KFILP  = ',I2,/,5X,'KFILCP = ',I2)
            CALL W3TAGE('U130')
            STOP 183
         ENDIF
 185  CONTINUE
C
      IF(KFILRA.NE.0) THEN
         IF(KFILRA.EQ.KFILDI.OR.
     1      KFILRA.EQ.KFILIO.OR.
     2      KFILRA.EQ.KFILDT.OR.
     3      KFILRA.EQ.KFILIC.OR.
     4      KFILRA.EQ.KFILIE.OR.
     5      KFILRA.EQ.KFILP.OR.
     6      KFILRA.EQ.KFILCP) THEN
            WRITE(KFILDO,190)
 190        FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1              ' IN KFILRA WITH EITHER KFILDI,',
     2              ' KFILIO,',/,5X,'KFILDT, KFILIC,',
     3              ' KFILIE, KFILP OR KFILCP.',1X,
     4              ' STOP IN U130 AT 1901.')
            WRITE(KFILDO,1901) KFILRA,KFILDI,KFILIO,KFILDT,KFILIC,
     1                         KFILIE,KFILP,KFILCP
 1901       FORMAT(/,5X,'KFILRA = ',I2,/,5X,'KFILDI = ',I2,/,5X,
     1              'KFILIO = ',I2,/,5X,'KFILDT = ',I2,/,5X,
     2              'KFILIC = ',I2,/,5X,'KFILIE = ',I2,/,5X,
     3              'KFILP  = ',I2,/,5X,'KFILCP = ',I2)
            CALL W3TAGE('U130')
            STOP 1901
         ENDIF
      ENDIF
C
         IF(KFILIO.EQ.KFILDI.OR.
     1      KFILIO.EQ.KFILDT.OR.
     2      KFILIO.EQ.KFILIC.OR.
     3      KFILIO.EQ.KFILIE.OR.
     4      KFILIO.EQ.KFILP.OR.
     5      KFILIO.EQ.KFILCP) THEN
            WRITE(KFILDO,191)
 191        FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1               ' IN KFILIO WITH EITHER KFILDI,',
     2               ' KFILDT,',/,5X,'KFILIC, KFILIE, KFILP',
     3               ' OR KFILCP.  STOP IN U130 AT 1910.')
            WRITE(KFILDO,1910) KFILIO,KFILDI,KFILDT,KFILIC,
     1                         KFILIE,KFILP,KFILCP
 1910       FORMAT(/,5X,'KFILIO = ',I2,/,5X,'KFILDI = ',I2,/,5X,
     1              'KFILDT = ',I2,/,5X,'KFILIC = ',I2,/,5X,
     2              'KFILIE = ',I2,/,5X,'KFILP  = ',I2,/,5X,
     3              'KFILCP = ',I2)
            CALL W3TAGE('U130')
            STOP 1910
         ENDIF
C
      IF(KFILIC.EQ.KFILDI.OR.
     1   KFILIC.EQ.KFILDT.OR.
     2   KFILIC.EQ.KFILIE.OR.
     3   KFILIC.EQ.KFILP.OR.
     4   KFILIC.EQ.KFILCP) THEN
         WRITE(KFILDO,192)
 192     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1              ' IN KFILIC WITH EITHER KFILDI,',
     2              ' KFILDT,',/,5X,'KFILIE, KFILP OR KFILCP.',1X,
     3              ' STOP IN U130 AT 1920.')
         WRITE(KFILDO,1920) KFILIC,KFILDI,KFILDT,KFILIE,
     1                      KFILP,KFILCP
 1920    FORMAT(/,5X,'KFILIC = ',I2,/,5X,'KFILDI = ',I2,/,5X,
     1          'KFILDT = ',I2,/,5X,'KFILIE = ',I2,/,5X,
     2          'KFILP  = ',I2,/,5X,'KFILCP = ',I2)
         CALL W3TAGE('U130')
         STOP 1920
      ENDIF
C
      IF(KFILIE.EQ.KFILDI.OR.
     1   KFILIE.EQ.KFILDT.OR.
     2   KFILIE.EQ.KFILP.OR.
     3   KFILIE.EQ.KFILCP) THEN
         WRITE(KFILDO,193)
 193     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1              ' IN KFILIE WITH EITHER KFILDI,',
     2              ' KFILDT,',/,5X,'KFILP OR KFILCP.',1X, 
     3              ' STOP IN U130 AT 1930.')
         WRITE(KFILDO,1930) KFILIE,KFILDI,KFILDT,KFILP,KFILCP
 1930    FORMAT(/,5X,'KFILIE = ',I2,/,5X,'KFILDI = ',I2,/,5X,
     1          'KFILDT = ',I2,/,5X,'KFILP  = ',I2,/,5X,
     2          'KFILCP = ',I2)
         CALL W3TAGE('U130')
         STOP 1930
      ENDIF
C
      IF((KFILP.GT.0).AND.(KFILP.NE.KFILDI)) THEN
         IF(KFILP.EQ.KFILDT.OR.
     1      KFILP.EQ.KFILCP) THEN
            WRITE(KFILDO,194)
 194        FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1               ' IN KFILP WITH EITHER KFILDT OR KFILCP.',/,
     2               4X,' STOP IN U130 AT 1940.')
            WRITE(KFILDO,1940) KFILP,KFILDT,KFILCP
 1940       FORMAT(/,5X,'KFILP   = ',I2,/,5X,'KFILDT  = ',I2,/,5X,
     1             'KFILCP  = ',I2)
            CALL W3TAGE('U130')
            STOP 1940
         ENDIF
      ENDIF
C
      IF(KFILCP.EQ.KFILDT.OR.
     1   KFILCP.EQ.KFILDI) THEN
         WRITE(KFILDO,195)
 195     FORMAT(/,' ****INCONSISTENCY IN INPUT UNIT NUMBERS',
     1              ' IN KFILCP WITH EITHER KFILDT',/,5X,
     2              ' OR KFILDI.  STOP IN U130 AT 1950.')
         WRITE(KFILDO,1950) KFILCP,KFILDT,KFILDI
 1950    FORMAT(/,5X,'KFILCP = ',I2,/,5X,'KFILDT = ',I2,
     1            5X,'KFILDI = ',I2)
         CALL W3TAGE('U130')
         STOP 1950
      ENDIF
C
C        IF A GRIDDED RANDOM ACCESS FILE IS PRESENT, A VARIABLE 
C        MOS-2000 ID MUST ALSO BE PRESENT IN THE VARIABLE LIST.  
C        THE CONVERSE IS ALSO TRUE.   
C
      IF((KFILRA.NE.0).AND.(KFILP.NE.0)) THEN
C           A RANDOM ACCESS FILE IS PRESENT WITH A MOS-2000 ID
C           IN THE VARIABLE LIST.  
         JFLAG=1
      ELSEIF((KFILRA.EQ.0).AND.(KFILP.NE.0)) THEN
        WRITE(KFILDO,210) 
 210    FORMAT(/,' ****A VARIABLE LIST HAS BEEN ENTERED AS INPUT',
     1            ' HOWEVER A GRIDDED RANDOM ACCESS FILE IS NOT',/,4X,
     2            ' STIPULATED IN THE CONTROL FILE.  INCONSISTENCY.',1X,
     3            ' STOP IN U130 AT 210.')
         CALL W3TAGE('U130')
         STOP 210
      ELSEIF((KFILRA.NE.0).AND.(KFILP.EQ.0)) THEN
         WRITE(KFILDO,220) 
 220     FORMAT(/,' ****A VARIABLE LIST IS NOT PRESENT IN THE',
     1            ' CONTROL FILE WHILE A GRIDDED RANDOM ACCESS',/4X,
     2            ' HAS BEEN STIPULATED IN THE CONTROL FILE.',1X,
     3            ' INCONSISTENCY.  STOP IN U130 AT 220.')
         CALL W3TAGE('U130')
         STOP 220
      ENDIF    
C
C        READ THE BITMAP VARIABLE LIST.  
C 
      IF(KFILP.NE.0) THEN
         CALL RDPRED(KFILDO,IP(6),IP(7),IP(8),IP(9),KFILP,KFILCP,
     1               ID,IDPARS,THRESH,JD,JP,ISCALD,SMULT,SADD,
     2               ORIGIN,CINT,PLAIN,UNITS,ND4,NPRED,ISTOP(1),IER)
         IF(KFILP.NE.KFILDI)CLOSE(UNIT=KFILP)
C        FILE KFILP IS CLOSED WHEN IT IS NOT THE SAME AS
C        THE DEFAULT INPUT FILE.
      ENDIF   
C
C        ENSURE THAT ONLY ONE BITMAP VARIABLE IS IN THE VARIABLE 
C        LIST.  IF MORE THAN ONE VARIABLE EXISTS, TERMINATE THE PROGRAM.
C
      IF(NPRED.GT.1) THEN
         WRITE(KFILDO,225) 
 225     FORMAT(/,' ****THE NUMBER OF BITMAP VARIABLES IN THE',
     1            ' VARIABLE LIST EXCEEDS ONE.  ONLY ONE BITMAP',
     2            /,5X,' VARIABLE ENTRY IS PERMITTED.  STOP 225',
     3            ' IN U130.')
         CALL W3TAGE('U130')
         STOP 225
      ENDIF
C
C        CHOOSE THE APPROPRIATE SUBROUTINE TO PROCESS THE GRIB DATA.
C        IF GRIB1 DATA IS TO BE PROCESSED, 'RDGRIB1' IS CALLED.
C        IF GRIB2 IS TO BE PROCESSED 'RDGRIB2' IS CALLED.
C
      IF(JCONVRT.EQ.1) THEN
C
C           PROCESS ALL INPUT GRIB1 FILES FOR ALL DATES AND TDLPACK
C           THE DATA SEQUENTIALLY.
C
         CALL RDGRIB1(KFILDO,KFILIN,KFILIO,KFILIE,KFILIC,
     1                KFILRA,RACESS,ID,IPACK,IWORK,DATA,ND5,
     2                NAMIN,NUMIN,KFILIX,NAMIX,ND6,IS0,IS1,IS2,IS4,
     3                ND7,IDATE,ND8,NDATES,LDATES,ND9,ND10,
     4                L3264B,MINPK,NTOTBY,NTOTRC,PXMISS,
     5                XMISSP,XMISSS,JFLAG,IP(4),IP(11),IP(12),
     6                JCONVRT,ISTOP)
C
      ELSEIF(JCONVRT.EQ.2) THEN
C
C           PROCESS ALL INPUT GRIB2 FILES FOR ALL DATES AND TDLPACK
C           THE DATA SEQUENTIALLY.
C
         CALL RDGRIB2(KFILDO,KFILIN,KFILIO,KFILIE,KFILIC,
     1                KFILRA,RACESS,ID,IPACK,IWORK,DATA,ND5,
     2                NAMIN,NUMIN,KFILIX,NAMIX,ND6,IS0,IS1,IS2,IS4,
     3                ND7,IDATE,ND8,NDATES,LDATES,ND9,ND10,
     4                L3264B,MINPK,NTOTBY,NTOTRC,PXMISS,
     5                XMISSP,XMISSS,JFLAG,IP(4),IP(11),IP(12),
     6                JCONVRT,ISTOP)
C
      ENDIF
C
C        PRINT THE FINAL DIAGNOSTICS.
C
      WRITE(KFILDO,309)NTOTBY,NTOTRC,OUTNAM
 309  FORMAT(/' A TOTAL OF ',I11,' BYTES IN ',I7,' RECORDS NOW',
     1        ' EXIST ON FILE ',A60)
 310  IF(ISTOP(1).NE.0)WRITE(KFILDO,311)ISTOP(1)
 311  FORMAT(/' AT LEAST ISTOP(1) =',I6,
     1        ' ERRORS HAVE OCCURRED ON THIS RUN.')
      IF(ISTOP(2).NE.0) WRITE(KFILDO,312) ISTOP(2)
 312  FORMAT(/' AT LEAST ISTOP(2) =',I6,
     1        ' DATA RECORDS NOT FOUND ON THIS RUN.')
      IF((ISTOP(1).EQ.0).AND.(ISTOP(2).EQ.0)) WRITE(KFILDO,314)
 314  FORMAT(/' NO ERRORS HAVE BEEN DETECTED ON THIS RUN.')
      WRITE(KFILDO,315)
 315  FORMAT(' ')
C
      RETURN
C 
C        ERROR STOP BELOW IS FOR ERRORS OF CONTROL INFORMATION INPUT.
C
 900  CALL IERX(KFILDO,KFILDO,IOS,'U130  ',STATE)
      CALL W3TAGE('U130')
      STOP 9999
      END
