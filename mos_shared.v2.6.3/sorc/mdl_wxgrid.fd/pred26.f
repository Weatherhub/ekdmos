      SUBROUTINE PRED26(KFILDO,KFIL10,KFILVO,KFILGO,KFILIN,NAMIN,
     1                  JFOPEN,NFIRST,ID,IDPARS,THRESH,JD,INDEX,JP,
     2                  IFIND,ISTAV,ITIME,ISCALD,
     3                  SMULT,SADD,ORIGIN,CINT,IPLAIN,PLAIN,UNITS,
     4                  NPRED,MODNUM,ND6,NUMIN,
     5                  LDATB,LDATE,LKHERE,MSDATE,
     6                  NDATE,KFILRA,RACESS,NUMRA,
     7                  ICALL,CCALL,ICALLD,CCALLD,NAME,NSTA,NGRID,DIR,
     8                  NGRIDC,ISDATA,SDATA,SDATA1,L1DATA,
     9                  NELEV,STALAT,STALON,ITIMEZ,INDEXC,ND1,ND11,
     A                  IPACK,IWORK,DATA,ND5,MINPK,
     B                  LSTORE,MSTORE,ND9,LITEMS,MITEMS,CORE,ND10,LASTL,
     C                  NBLOCK,LASTD,NSTORE,NFETCH,
     D                  IS0,IS1,IS2,IS4,ND7,
     E                  FD1,FD2,FD3,FD4,FD5,FD6,FD7,
     F                  FDA,FDVERT,FDTIME,FDSINS,FDMS,ND2X3,
     G                  KFILAC,ASCIFL,
     H                  IP12,IP13,IP14,IP15,IP16,IP19,IP20,IP21,IP23,
     I                  NTOTBV,NTOTRV,NTOTBG,NTOTRG,
     J                  LTOTBV,LTOTRV,LTOTBG,LTOTRG,
     K                  N19TBY,N19TRC,
     L                  PXMISS,L3264B,L3264W,MISTOT,ISTOP,
     M                  THRPHS,THRQPF,THRTRW,THRSVR,
     N                  IPHSBC,PHSTMP,NSVRLOC,NX,NY,IER)
C
C        FEBRUARY  2010   GLAHN   MDL   MOS-2000
C                                 ADAPTED FROM PRED22
C        OCTOBER   2010   HUNTEMANN   ADDED KFILAC, IP20 TO CALL
C        JULY      2011   HUNTEMANN   ADDED IP21
C        NOVEMBER  2011   HUNTEMANN   ADDED PLAIN( ) TO ALL CALLS
C                                     TO PACKGR.
C
C        PURPOSE
C           TO OBTAIN FOR U201 ALL VARIABLES IDENTIFIED IN ID( , ),
C           IDPARS( , ), AND THRESH( ).  "BASIC" VARIABLES (THE
C           VARIABLES SANS "PROCESSING" INFORMATION) ARE IN JD( , ),
C           RESPECTIVELY.  A RECORD IS READ AND PROCESSED INTO
C           VARIABLES IF POSSIBLE.  ALSO, IF IT WILL BE NEEDED
C           LATER (THROUGH OPTION), IT IS STORED WITH ITS KEYS
C           IN LSTORE( , ).  THE PROCESSED VARIABLES ARE
C           WRITTEN TO THE OUTPUT FILE.  PRED26 IS ENTERED ONCE FOR
C           EACH DATE/TIME AFTER THE FIRST.  CUMULATIVE FROM BELOW 
C           OR DISCRETE BINARIES ARE NOT SUPPORTED.  GRIDPOINT
C           AND VECTOR DATA MUST BE HANDLED SOMEWHAT DIFFERENTLY.
C           FOR GRIDPOINT DATA, THE BASIC ID IN JD( ) IS USED 
C           AND ALL PROCESSING OPERATORS (B, T, I, S) APPLY.
C           FOR VECTOR DATA, IT IS EXPECTED THAT THE PROCESSING 
C           WILL BE DONE IN OPTION, EXCEPT THAT VECTOR DATA 
C           OUT OF OPTION CAN HAVE THE TRANSFORMATION AND BINARY
C           OPERATORS (T, B) APPLY.  NOTE THAT BINARIES CANNOT
C           BE MADE DIRECTLY ON INPUT VECTOR DATA.  
C
C           NOTE:  ANY CCC = 799 VARIABLE SHOULD HAVE DD EQUAL TO 
C           TO THE MODEL IT APPLIES.  IF DD = 0, THEN IT WILL
C           APPLY TO VECTOR DATA, AND LOTS OF HOURLY DATA COULD BE
C           NEEDLESSLY SAVED.  MORE THAN ONE 799 VARIABLE CAN BE
C           USED IF NEEDED.
C   
C        DATA SET USE
C            KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10 - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                     (INPUT-OUTPUT) 
C            KFILVO - UNIT NUMBER OF VECTOR OUTPUT FILE.  (OUTPUT)
C            KFILGO - UNIT NUMBER OF GRIDDED OUTPUT FILE.  (OUTPUT)
C            KFILAC - UNIT NUMBER OF ASCII WEATHER KEY LIST FILE. 
C                     (OUTPUT)
C         KFILRA( ) - UNIT NUMBERS OF RANDOM ACCESS FILES.
C                     (INPUT/OUTPUT)
C         KFILIN( ) - UNIT NUMBERS OF SEQUENTIAL FILES.  (INPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              KFILVO = UNIT NUMBER OF VECTOR OUTPUT FILE.  (INPUT)
C              KFILGO = UNIT NUMBER OF GRIDDED OUTPUT FILE.  (INPUT)
C              KFILAC = UNIT NUMBER OF ASCII WEATHER KEY LIST FILE. 
C                     (OUTPUT)
C              ASCIFL = FILE NAME THAT CORRESPONDS TO THE UNIT NUMBER IN
C                       KFILAC. (CHARACTER*60)  (INTERNAL)
C           KFILIN(J) = UNIT NUMBERS FOR INPUT DATA, ALL IN TDLPACK FORMAT.
C                       INPUT CAN INCLUDE GRIDPOINT (FILES) DATA, PREDICTAND
C                       (OBSERVATIONS) DATA, VARIOUS CONSTANTS, OR MOS FORECASTS
C                       (FOR 2ND GENERATION MOS, POSSIBLY FOR LOCAL IMPLEMENTATION
C                       (J=1,NUMIN).  (INPUT)
C            NAMIN(J) = NAME OF THE INPUT FILES BEING PROCESSED (J=1,NUMIN).
C                       (CHARACTER*60)  (INPUT)
C           JFOPEN(J) = FOR EACH FILE IN KFILIN(J), JFOPEN(J) IS 1 WHEN
C                       THE FILE IS OPEN, IS 0 WHEN IT HAS ALREADY BEEN
C                       USED AND IS 2 WHEN THE FILE HAS NOT BEEN OPENED 
C                       (J=1,NUMIN).  (INPUT/OUTPUT)
C              NFIRST = 1 FOR FIRST DAY, 2 FOR SECOND, 3 OTHERWISE.  
C                       FOR PRED26, NFIRST WILL NEVER BE 1.  (INPUT)  
C             ID(J,N) = THE INTEGER VARIABLE ID'S (J=1,4) (N=1,NPRED).
C                       (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE VARIABLE
C                       ID CORRESPONDING TO ID( ) (J=1,15) (N=1,NPRED).
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C           THRESH(N) = THE BINARY THRESHOLD ASSOCIATED WITH IDPARS( ,N)
C                       (N=1,NPRED).  (INPUT)
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID (J=1,4) (N=1,NPRED).
C                       THIS IS THE SAME AS ID(J,N), EXCEPT THAT THE PORTIONS
C                       PERTAINING TO PROCESSING ARE OMITTED:
C                       B = IDPARS(3, ),
C                       T = IDPARS(8, ),
C                       I = IDPARS(13, ),
C                       S = IDPARS(14, ),
C                       G = IDPARS(15, ), AND
C                       THRESH( ).
C                       JD( , ) IS USED TO IDENTIFY THE BASIC MODEL FIELDS
C                       AS READ FROM THE ARCHIVE.  (INPUT)
C            INDEX(N) = USED TO KEEP TRACK OF WHICH VARIABLES HAVE
C                       BEEN DEALT WITH FOR A PARTICULAR DATE.  THIS ALLOWS
C                       A DIAGNOSTIC IF A BASIC VARIABLE IS DEALT WITH MORE
C                       THAN ONCE.  (INTERNAL-OUTPUT)
C             JP(J,N) = JP( ,N) INDICATES WHETHER (>0) OR NOT (=0) VARIABLE N
C                       WILL BE OUTPUT FOR VIEWING (N=1,NPRED).
C                       J=1--GRIDPOINT VALUES,
C                       J=2--GRIDPRINT WITH CONTOURS, AND
C                       J=3--VECTOR VALUES.
C                       THIS ALLOWS INDIVIDUAL VARIABLE CONTROL ON THE PRINT
C                       PARAMETERS IP12, IP13, IP14, AND IP15.  (INPUT)
C            IFIND(N) = 1 = WHEN THE VARIABLE CAN BE FOUND DIRECTLY
C                           FROM GFETCH (DOESN'T HAVE TO GO THRU OPTION).
C                       2 = WHEN ID( , ) HAS BEEN FOUND IN OPTION, BUT
C                           GOOD DATA WERE NOT RETURNED.  THEREFORE, IT 
C                           IS UNKNOWN WHERE THE DATA ARE TO COME FROM.
C                       0 = WHEN ID( , ) HAS BEEN FOUND IN OPTION AND
C                           THE DATA WILL BE COMPUTED THERE.
C                       (INPUT/OUTPUT)
C            ISTAV(N) = INDICATES FOR EACH VARIABLE (N=1,NPRED) WHETHER 
C                       DATA ARE CURRENTLY VECTOR (=1) OR GRIDPOINT (=0).
C                       (INPUT)
C            ITIME(N) = FOR EACH VARIABLE (N=1,NPRED) INDICATES WHETHER (=1)
C                       OR NOT (=0) THE RR IS TO BE USED BY GFETCH WHEN
C                       FETCHING DATA.  (INPUT)
C           ISCALD(N) = THE DECIMAL SCALING CONSTANT TO USE WHEN PACKING THE 
C                       VECTOR DATA (N=1,ND4).  THE BINARY SCALING
C                       CONSTANT IS USED AS ZERO.  (INPUT)
C            SMULT(N) = THE MULTIPLICATIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C             SADD(N) = THE ADDITIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C           ORIGIN(N) = THE CONTOUR ORIGIN, APPLIES TO THE UNITS IN IUNITS( ,J)
C                       (N=1,ND4).  (INPUT)
C             CINT(N) = THE CONTOUR INTERVAL, APPLIES TO THE UNITS IN
C                       IUNITS( ,J) (N=1,ND4).  (INPUT)
C       IPLAIN(L,J,N) = 32 CHARACTERS (L=1,L3264W) (J=1,4) OF PLAIN LANGUAGE
C                       DESCRIPTION OF VARIABLES (N=1,ND4).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       EQUIVALENCED TO PLAIN( ).  (INPUT)
C            PLAIN(N) = THE PLAIN LANGUAGE DESCRIPTION OF THE VARIABLES
C                       (N=1,ND4).  EQUIVALENCED TO IPLAIN( , ).
C                       (CHARACTER*32)  (INPUT)
C            UNITS(N) = THE UNITS OF THE DATA THAT APPLY AFTER MULTIPLYING
C                       BY SMULT(N) AND ADDING SADD(N) (N=1,ND4).
C                       (CHARACTER*12)  (INPUT)
C               NPRED = THE NUMBER OF VARIABLES NEEDED AND IDENTIFIED IN 
C                       ID( , ), ETC.  ALSO TREATED AS THE DIMENSION OF THE
C                       VARIABLES ID( , ), ETC.  THIS NAME IS A HOLDOVER,
C                       AS IS THE NAME OF THE ROUTINE ITSELF, TO WHEN 
C                       U201 WAS WRITTEN ONLY FOR PREDICTORS.  (INPUT)
C           MODNUM(J) = THE "MODEL" NUMBER CORRESPONDING TO KFILIN(J)
C                       (J=1,NUMIN).  THIS MAY NOT HAVE MEANING FOR
C                       SOME INPUTS, BUT IS NEEDED FOR THE MODEL DATA.
C                       (INPUT)
C                 ND6 = THE MAXIMUM OF NUMIN.  DIMENSION OF KFILIN( ),
C                       NAMIN( ), JFOPEN( ), MODNUM( ), LKHERE( ), 
C                       LDATB( ), AND LDATE( ) AND THE SECOND DIMENSION
C                       OF INDEXC( , ).  (INPUT)
C               NUMIN = THE NUMBER OF VALUES IN KFILIN( ),
C                       NAMIN( ), JFOPEN( ),MODNUM( ), LKHERE( ),
C                       LDATB( ), AND LDATE( ).  (INPUT)
C            LDATB(J) = BEGINNING DATE NEEDED FOR THE MODEL CORRESPONDING
C                       TO NAMIN(J), ETC. (J=1,NUMIN).  THIS IS NOT OVERALL,
C                       BUT IS VALID FOR THE DAY BEING PROCESSED.
C                       (INTERNAL-OUTPUT)
C            LDATE(J) = ENDING DATE NEEDED FOR THE MODEL CORRESPONDING
C                       TO NAMIN(J), ETC. (J=1,NUMIN).  THIS IS NOT OVERALL,
C                       BUT IS VALID FOR THE DAY BEING PROCESSED. 
C                       (INTERNAL-OUTPUT) 
C           LKHERE(J) = KEEPS TRACK OF WHICH FILES AN EOF HAS BEEN 
C                       REACHED (J=1,NUMIN).  INITIALLY SET TO 1; SET
C                       TO ZERO WHEN AN EOF HAS BEEN REACHED.
C           MSDATE(J) = KEEPS TRACK OF WHETHER ANY DATA ARE AVAILABLE
C                       FOR A PARTICULAR DATE ON AN INPUT FILE 
C                       (J=1,NUMIN).  USED FOR DIAGNOSTIC PRINT.  (INTERNAL)
C               NDATE = THE DATE/TIME FOR WHICH VARIABLES ARE TO BE
C                       FURNISHED ON THIS CALL TO PRED26.  (INPUT)
C           KFILRA(J) = HOLDS THE UNIT NUMBERS FOR ACCESSING THE MOS-2000
C                       EXTERNAL RANDOM ACCESS FILES (J=1,NUMRA).  (INPUT)
C           RACESS(J) = THE FILE NAMES CORRESPONDING TO KFILRA(J) (J=1,NUMRA).
C                       (CHARACTER*60)  (INPUT)
C               NUMRA = THE NUMBER OF UNIT NUMBERS AND NAMES IN KFILRA( )
C                       AND RACESS( ).  (INPUT)
C        ICALL(L,K,J) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,NSTA) (J=1,6).
C                       EQUIVALENCED TO CCALL( , )  (INPUT/OUTPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST, EXCEPT POSSIBLY 
C                       CCALLD( ).  EQUIVALENCED TO ICALL( , ). 
C                       (CHARACTER*8)  (INPUT/OUTPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,ND5).
C                       EQUIVALENCED TO CCALLD( ).  (INTERNAL)
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5).  THIS LIST IS USED 
C                       IN L1D1 TO READ THE REGION LISTS.  EQUIVALENCED
C                       TO ICALLD( , ).  (CHARACTER*8)  (INTERNAL)
C             NAME(K) = NAMES OF STATIONS (K=1,NSTA).  USED FOR PRINTOUT
C                       ONLY.  (CHARACTER*20)  (INPUT)
C                NSTA = THE NUMBER OF STATIONS IN ICALL( , , ) AND CCALL( , ).
C                       (INPUT)
C               NGRID = THE NUMBER OF GRID COMBINATIONS IN DIR( , , ),
C                       MAXIMUM OF ND11.  (INPUT)
C          DIR(K,J,M) = THE IX (J=1) AND JY (J=2) POSITIONS ON THE GRID
C                       FOR THE COMBINATION OF GRID CHARACTERISTICS M
C                       (M=1,NGRID) AND STATION K (K=1,NSTA) IN NGRIDC( ,M).
C                       (INPUT)
C         NGRIDC(L,M) = HOLDS THE GRID CHARACTERISTICS (L=1,6) FOR EACH GRID
C                       COMBINATION (M=1,NGRID).  THIS CAN BE UPDATED IF A
C                       NEW GRID IS ENCOUNTERED.  (INPUT-OUTPUT)
C                       L=1--MAP PROJECTION NUMBER (3=LAMBERT, 5=POLAR
C                            STEREOGRAPHIC). 
C                       L=2--GRID LENGTH IN MILLIMETERS,
C                       L=3--LATITUDE AT WHICH GRID LENGTH IS CORRECT *10000,
C                       L=4--GRID ORIENTATION IN DEGREES *10000,
C                       L=5--LATITUDE OF LL CORNER IN DEGREES *10000,
C                       L=6--LONGITUDE OF LL CORNER IN DEGREES *10000.
C           ISDATA(K) = USED IN PACK1D VIA PACKV (K=1,NSTA).  (INTERNAL)
C            SDATA(K) = VECTOR DATA FOR WRITING (K=1,NSTA).
C                       (INTERNAL)
C           SDATA1(K) = WORK ARRAY RESERVED FOR USE IN L2D2 (K=1,NSTA).
C                       (INTERNAL)
C           L1DATA(K) = THE ARRAY RESERVED FOR USE BY LINEARIZATION
C                       ROUTINES (K=1,NSTA).  (INTERNAL)  
C            NELEV(K) = ELEVATION OF STATIONS (K=1,NSTA).  (INPUT)
C           STALAT(K) = LATITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           STALON(K) = LONGITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           ITIMEZ(K) = TIME ZONE INDICATOR.  THE NUMBER OF HOURS
C                       THE STATION IS DIFFERENT FROM UTC (K=1,NSTA).
C                       (INPUT)
C         INDEXC(K,J) = LOCATIONS OF THE STATIONS CORRESPONDING TO 
C                       CCALL(K, ) (K=1,NSTA) FOR EACH MODEL J (J=1,NUMIN).
C                       FOR GRIDPOINT DATA, INDEXC( , ) WILL BE EMPTY
C                       FOR THAT MODEL J.  IF A STATION'S LOCATION IS
C                       UNKNOWN, INDEXC( , ) = 99999999.  (OUTPUT)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT WITH.
C                       (INPUT)
C                ND11 = MAXIMUM NUMBER OF GRID COMBINATIONS THAT CAN BE
C                       DEALT WITH ON THIS RUN.  LAST DIMENSION OF
C                       NGRIDC( , ) AND DIR( , , ).  (INPUT)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = PRIMARY ARRAY FOR HOLDING GRIDPOINT DATA FOR
C                       PROCESSING (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).  
C                       SHOULD BE GE ND2X3 IN CALLING PROGRAM.  (INPUT)
C               MINPK = MINIMUM GROUP SIZE WHEN PACKING THE VECTOR
C                       VALUES OR GRID.  (INPUT)
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE DATA 
C                       STORED (L=1,11) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDLPACK, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR( , ,L) AND
C                              IN NGRIDC( ,L) DEFINING THE CHARACTERISTICS
C                              OF THIS GRID.
C                       L=11 --THE NUMBER OF THE FIRST VARIABLE IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NPRED) FOR WHICH THIS
C                              VARIABLE IS NEEDED, WHEN IT DOES NOT NEED
C                              TO BE STORED AFTER DAY 1.  WHEN THE VARIABLE
C                              MUST BE STORED (TO BE ACCESSED THROUGH OPTION)
C                              FOR ALL DAYS, ID(11,N) IS 7777 + THE NUMBER
C                              OF THE FIRST VARIABLE IN THE SORTED LIST
C                              FOR WHICH THIS VARIABLE IS NEEDED.
C                       L=12 --USED INITIALLY IN ESTABLISHING MSTORE( , ).
C                              LATER USED AS A WAY OF DETERMINING WHETHER
C                              TO KEEP THIS VARIABLE.
C         MSTORE(L,J) = THE ARRAY HOLDING THE VARIABLES NEEDED AS INPUT, AFTER
C                       DAY 1, AND ASSOCIATED INFORMATION (L=1,7) (J=1,MITEMS).
C                       (INPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --INDICATES WHETHER OR NOT TO STORE THE
C                              VARIABLE AND THE FIRST VARIABLE TO USE IT FOR.
C                       L=6  --THE CYCLE TIME FOR WHICH THIS VARIABLE
C                              IS NEEDED FOR THE DATE BEING PROCESSED.  A
C                              VARIABLE NEEDED FOR MORE THAN ONE CYCLE TIME
C                              WILL HAVE AN ENTRY FOR EACH CYCLE TIME NEEDED.
C                       L=7  --THE MAXIMUM TIME OFFSET RR (SEE IDPARS(9, )
C                              CORRESPONDING TO MSTORE(6, )
C                       NOTE THAT MSTORE IN U201 AND PRED26 IS NOT EXACTLY
C                       THAT IN U600 AND RDVECT.  U201 DOES NOT USE RDVECT.
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ) AND MSTORE( , ).
C                       (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , ) THAT 
C                       HAVE BEEN USED IN THIS RUN.
C              MITEMS = THE NUMBER OF ITEMS (COLUMNS) IN MSTORE( , ).
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA IDENTIFIED IN
C                       LSTORE( , ) (J=1,ND10).  WHEN CORE( ) IS FULL
C                       DATA ARE STORED ON DISK.  (INPUT-OUTPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C               LASTL = THE LAST LOCATION IN CORE( ) USED.  THIS IS THE
C                       MAXIMUM VALUE THAT HAS BEEN USED, EVEN THOUGH
C                       THE SLOT(S) AT THE END HAVE BEEN RELEASED.  THIS
C                       IS MODIFIED, ALONG WITH LITEMS, IF COMPACTION IS
C                       DONE OR IF THE ITEM RELEASED IS THE LAST ITEM
C                       IN THE LIST.  INITIALIZED TO 0 ON FIRST ENTRY TO
C                       GSTORE.  THE USER NEED NOT WORRY ABOUT THIS.  (INTERNAL)
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK FOR MOS-2000
C                       INTERNAL STORAGE.
C              NSTORE = THE NUMBER OF TIMES GSTORE HAS BEEN ENTERED.  GSTORE
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  (OUTPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.  GFETCH
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).  (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).  (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C  FD1(J),FD2(J), ETC = WORK ARRAYS (J=1,ND2X3).  THESE MAY BE USED IN
C                       ROUTINES AS 2-DIMENSIONAL ARRAYS, WHERE THE
C                       TOTAL ARRAY SIZE IS ND2*ND3=ND2X3 AS DECLARED IN
C                       THE CALLING PROGRAM.  (INTERNAL)
C              FDA(J) = USED TO RETAIN A VARIABLE WITHIN PRED26 SO THAT IT
C                       WON'T HAVE TO BE ACCESSED AGAIN WITH GFETCH.  THIS
C                       IS MAINLY SO THAT THE NUMBER OF GRIDS STORED WILL
C                       FIT WITHIN CORE.  IT ALSO ELIMINATES MULTIPLE 
C                       UNPACKING OF THE DATA.  (INTERNAL)
C           FDVERT(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE VERTP
C                       (J=1,ND2X3).
C           FDTIME(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE TEMEP
C                       (J=1,ND2X3).
C       FDSINS(IX,JY) = USED TO SAVE THE SIN OF THE LATITUDE IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C         FDMS(IX,JY) = USED TO SAVE THE MAP FACTOR IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C               ND2X3 = DIMENSION OF FD1( ), FD2( ), ETC.   MUST BE
C                       AT LEAST AS LARGE AS THE LARGEST GRID AND AS
C                       LARGE AS NSTA.  (INPUT)
C                IP12 = INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                       STATIONS AND THEIR I,J POSITIONS ON THE
C                       GRID WILL BE PRINTED TO THE TO THE FILE WHOSE UNIT
C                       NUMBER IS IP12.  ALSO USED IN THE SAME MANNER
C                       TO PRINT STATIONS IN THE DIRECTORY RECORD
C                       OF VECTOR INPUT FILES.  (INPUT)
C                IP13 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE WRITTEN TO UNIT IP13 FOR VIEWING.  (INPUT)
C                IP14 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE CONTOURED AND WRITTEN TO UNIT IP14 FOR
C                       VIEWING.  (INPUT)
C                IP15 = INDICATES WHETHER (>1) OR NOT (=0) VECTOR
C                       VALUES WILL BE WRITTEN TO UNIT IP15 FOR VIEWING.
C                       (INPUT)
C                IP16 = INDICATES WHETHER (>0) OR NOT (=0) DIAGNOSTICS
C                       WILL BE WRITTEN TO UNIT IP16 FOR LINEARIZATION
C                       AND CONSTANT ROUTINES (E.G., STATIONS IN 
C                       THRESHOLD LISTS THAT ARE NOT BEING DEALT WITH
C                       IN THIS RUN).  (INPUT)
C                IP19 = INDICATES WHETHER (>0) OR NOT (=0) THE GRIDDED
C                       VARIABLES WILL BE WRITTEN TO IP19.
C                       GRIDDED VARIABLES WRITTEN PACKED.  THIS
C                       CAPABILITY WAS INSERTED FOR VIEWING THE
C                       GRIDS WITH GMOS_PLOT.  IT ALSO CONTROLS THE
C                       WRITING OF ASCII DATA FOR THE LAST VARIABLE
C                       DEALT WITH FOR THE LAST DAY.  IF LEFT ON,
C                        OTS OF DATA MIGHT BE NEEDLESSLY PACKED AND
C                       WRITTEN.  NORMALLY, U720 WOULD BE RUN FOR
C                       ONE VARIABLE FOR ONE DATE WHEN IP(19) NE.0.
C                       (INPUT)
C                IP20 = INDICATES WHETHER (>0) OR NOT (=0) A DIAGNOSTIC
C                       WEATHER KEY LIST PRINTED WITH CORRESPONDING
C                       INDICES FROM THE GRID WILL BE WRITTEN TO IP20.
C                       SAME OUTPUT AS KFILAC, EXCEPT WITH INDICES FOR 
C                       CHECKOUT. (INPUT)
C                IP21 = STATION VALUES OF WEATHER KEYS FOR STATIONS
C                       IN STATION LIST. (INPUT)
C                IP23 = INDICATES WHETHER (>0) OR NOT (=0) STATEMENTS
C                       ABOUT EOF AND FILE OPENINGS AND CLOSINGS WILL
C                       BE OUTPUT FOR PRINTING ON UNIT IP23.  (INPUT)
C              NTOTBV = THE TOTAL NUMBER OF BYTES IN THE SEQUENTIAL
C                       VECTOR FILE ASSOCIATED WITH UNIT NO. KFILVO.
C                       IT IS UPDATED WHEN THE DATA IN IPACK( ) ARE
C                       WRITTEN. (INPUT/OUTPUT)
C              NTOTRV = THE TOTAL NUMBER OF RECORDS IN THE SEQUENTIAL
C                       VECTOR FILE ASSOCIATED WITH UNIT NO. KFILVO. 
C                       IT IS UPDATED AS NEEDED IN WRITEP.
C                       (INPUT/OUTPUT)
C              NTOTBG = THE TOTAL NUMBER OF BYTES IN THE SEQUENTIAL
C                       GRIDDED FILE ASSOCIATED WITH UNIT NO. KFILGO.
C                       IT IS UPDATED WHEN THE DATA IN PACKG( ) ARE
C                       WRITTEN. (INPUT/OUTPUT)
C              NTOTRG = THE TOTAL NUMBER OF RECORDS IN THE SEQUENTIAL
C                       GRIDDED FILE ASSOCIATED WITH UNIT NO. KFILGO.
C                       IT IS UPDATED AS NEEDED IN PACKG. (INPUT/OUTPUT)
C              LTOTBV = THE TOTAL NUMBER OF BYTES OF VECTOR DATA WRITTEN
C                       TO THE EXTERNAL RANDOM ACCESS FILE, UNIT NO. 49.
C                       (INPUT/OUTPUT)
C              LTOTRV = THE TOTAL NUMBER OF RECORDS OF VECTOR DATA
C                       WRITTEN TO THE EXTERNAL RANDOM ACCESS FILE, UNIT
C                       NO. 49. (INPUT/OUTPUT)
C              LTOTBG = THE TOTAL NUMBER OF BYTES OF GRIDDED DATA
C                       WRITTEN TO THE EXTERNAL RANDOM ACCESS FILE, UNIT
C                       NO. 42 OR 43. (INPUT/OUTPUT)
C              LTOTRG = THE TOTAL NUMBER OF RECORDS OF GRIDDED DATA
C                       WRITTEN TO THE EXTERNAL RANDOM ACCESS FILE, UNIT
C                       NO. 42 OR 43.  (INPUT-OUTPUT)
C              N19TBY = TOTAL BYTES WRITTEN TO IP19.  (INPUT-OUTPUT)
C              N19TRC = TOTAL RECORDS WRITTEN TO IP19.  (INPUT-OUTPUT)
C              PXMISS = THE VALUE OF A SECONDARY MISSING VALUE TO INSERT
C                       WHEN THE SECONDARY MISSING VALUE IS 9997.
C                       THIS ALLOWS MAINTAINING A 9997 OR TREATING IT AS 
C                       ZERO, OR EVEN SOME OTHER VALUE SUCH AS 9999.
C                       (INPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING USED
C                       (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  (INPUT)  
C              MISTOT = TOTAL NUMBER OF TIMES A PRIMARY MISSING INDICATOR
C                       HAS BEEN ENCOUNTERED IN UNPACKING GRIDS.  NOTE 
C                       THAT THIS IS LIMITED TO GRIDS AND DOES NOT
C                       INCLUDE VECTORS.  (INPUT-OUTPUT)
C            ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT MAY BE FATAL.
C                       FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER AN
C                       INPUT DATA RECORD IS NOT FOUND.  (INPUT-OUTPUT)
C                 IER = STATUS RETURN.
C                         0 = GOOD RETURN.
C                        31 = TROUBLE OPENING OR SWITCHING FILE.
C                        38 = ND5 TO SMALL.
C                       127 = NO MORE DATA AVAILABLE.
C                       138 = 500 ERRORS HAVE OCCURRED.
C                       SEE ROUTINE GSTORE, GFETCH, AND GRCOMB FOR FOR
C                       OTHER VALUES.  (INTERNAL-OUTPUT)
C               LSIZE = NUMBER OF WORDS IN IPACK( ).  THIS IS THE SIZE OF
C                       THE PACKED RECORD READ.  (INTERNAL)
C               NSIZE = THE NUMBER OF WORDS RETURNED FROM GFETCH.  THIS
C                       IS THE GRID SIZE FOR GRIDDED DATA OR THE NUMBER
C                       OF STATIONS FOR VECTOR DATA.  (INTERNAL)
C              NSTORE = RUNNING COUNT OF NUMBER OF TIMES DATA ARE STORED BY 
C                       GSTORE.  INITIALIZED TO ZERO THE FIRST TIME GSTORE
C                       IS CALLED.  THE USER NEED NOT WORRY ABOUT THIS; THE
C                       COUNT IS KEPT WITHIN GSTORE.  (INTERNAL)
C               NSLAB = THE NUMBER OF THE SLAB IN DIR( , , ) AND
C                       IN NGRIDC( , ) DEFINING THE CHARACTERISTICS
C                       OF THIS GRID.  SEE LSTORE(10, ).  (INTERNAL) 
C                 NYR = YEAR, 4 DIGITS.  (INTERNAL)
C                 NMO = MONTH.  (INTERNAL)
C                 NDA = DAY OF MONTH.  (INTERNAL)
C                 NHR = HOUR, 2 DIGITS.  (INTERNAL)
C               LD(K) = HOLDS THE 3 ID WORDS OF THE DATA IN FDA( ).  
C                       (INTERNAL)
C               LPARS = HOLDS THE VALUE OF IDPARS(15, ) OF THE DATA IN FDA( ).
C                       INITIALIZED TO 9999 FOR SAFETY.  (INTERNAL)
C               MISSP = PRIMARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C               MISSS = SECONDARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C              XMISSP = PRIMARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C              XMISSS = SECONDARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C           NBYTES(J) = ARRAY USED TO DEAL WITH DIFFERENT WORD LENGTHS
C                       WHEN READING DATA (J=1,2).
C              LSTOPC = AN INTERNAL COUNTER TO KEEP AN INFINITE READING
C                       LOOP FROM OCCURRING.  (INTERNAL)
C               LSTOP = THE VALUE TO COMPARE LSTOPC WITH TO STOP THE
C                       READING.  CURRENTLY SET AT 500; THIS ASSUMES
C                       500 READING ERRORS SHOULD NOT OCCUR IN A SINGLE
C                       RUN.  NOTE THAT THIS COUNT IS SEPARATE FROM
C                       ISTOP(1) IN CASE ISTOP(1) HAS TO BE LARGE WHEN
C                       DEALING WITH HOURLY DATA AND MISSING STATIONS.
C              NGOMIS = SWITCH TO KEEP FROM PROCESSING A MISSING GRID.
C                       1 = MISSING GRIDPOINT DATA,
C                       0 = GOOD GRID DATA.
C                       (INTERNAL)
C              NWORDS = NUMBER OF WORDS IN IPACK( ) RETURNED FROM PACKV.
C                       (INTERNAL)
C              NODATA = COUNTS THE NUMBER OF TIMES THERE HAS BEEN NO 
C                       DATA ON A FILE.  A DIAGNOSTIC ON KFILDO IS
C                       PRINTED ONLY WHEN NODATA LE.3.  (INTERNAL)
C              IFIRST = 0 FOR FIRST VARIABLE AND = 1 OTHERWISE.  SET BY
C                       DATA STATEMENT.  (INTERNAL)
C           THRPHS(I) = REAL VECTOR OF LENGTH (4) CONTAINING THE PHASE
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE FOUR 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS 
C                       (INPUT).  ELEMENTS WITHIN THRPHS MUST BE 
C                       BETWEEN 0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (I=1,4)
C           THRQPF(I) = REAL VECTOR OF LENGTH (2) CONTAINING THE QPF6 
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE TWO 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS. 
C                       ELEMENTS WITHIN THRQPF MUST BE BETWEEN 
C                       0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (INPUT)  (I=1,2)
C           THRTRW(I) = REAL VECTOR OF LENGTH (4) CONTAINING THE THUNDER
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE FOUR 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS 
C                       (INPUT).  ELEMENTS WITHIN THRTRW MUST BE 
C                       BETWEEN 0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (I=1,4)
C           THRSVR(I) = REAL VECTOR OF LENGTH (4) CONTAINING THE SEVERE 
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE FOUR 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS 
C                       (INPUT).  ELEMENTS WITHIN THRSVR MUST BE 
C                       BETWEEN 0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (I=1,4)
C              PHSTMP = PRECIPITATION PHASE CUTOVER TEMPERATURE
C                       THRESHOLD TO LIQUID.  IF THE MOS FORECAST
C                       TEMPERATURE IS AT OR ABOVE PHSTMP, THE 
C                       PRECIPITATION PHASE IS INITIALIZED TO 
C                       LIQUID. (INPUT)
C              IPHSBC = FLAG FOR USING CONDITIONAL PRECIPITATION TYPE
C                       BEST CATEGORY THRESHOLDS:
C                       1 = USE THRESHOLDS
C                       ELSE = DON'T USE THRESHOLDS
C                       (INPUT) 
C             NSVRLOC = FLAG TO DETERMINE ORDER OF ASCII WEATHER SUBKEYS.
C                       1 = SEVERE ALWAYS FIRST
C                       2 = SCT,NUM,DEF SEVERE ALWAYS FIRST
C                       3 = SHOW LESS SEVERE AT LATER PROJECTIONS
C                       (INPUT) 
C                  NX = NUMBER OF GRIDPOINTS IN X DIRECTION. (INPUT)
C                  NY = NUMBER OF GRIDPOINTS IN Y DIRECTION. (INPUT)
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES USED 
C            GFETCH, OPTION, GRIDB, SMTH5, SMTH9, SMTH25, SMTH2X, SMTH3X,
C            INTRP, INTRPA, INTRPB, INTRPC, INTRPD, TRANS, BINARY,
C            PREDX1, PACKV, UNPACK, UNPKBG, UPDAT, GRCOMB, GSTORE,TIMPR
C
      CHARACTER*8 CCALL(ND1,6),
     1            CCALLD(ND5)
      CHARACTER*12 UNITS(NPRED)
      CHARACTER*20 NAME(ND1)
      CHARACTER*32 PLAIN(NPRED)
      CHARACTER*60 RACESS(NUMRA),NAMIN(ND6)
C
      DIMENSION ICALL(L3264W,ND1,6),
     1          NELEV(ND1),STALAT(ND1),STALON(ND1),ITIMEZ(ND1),
     2          ISDATA(ND1),SDATA(ND1),SDATA1(ND1),L1DATA(ND1)
      DIMENSION DIR(ND1,2,ND11),NGRIDC(6,ND11)
      DIMENSION ID(4,NPRED),IDPARS(15,NPRED),THRESH(NPRED),
     1          JD(4,NPRED),INDEX(NPRED),JP(3,NPRED),IFIND(NPRED),
     2          ISTAV(NPRED),ITIME(NPRED),ISCALD(NPRED),
     3          SMULT(NPRED),SADD(NPRED),ORIGIN(NPRED),CINT(NPRED)
      DIMENSION IPLAIN(L3264W,4,NPRED)
      DIMENSION FD1(ND2X3),FD2(ND2X3),FD3(ND2X3),FD4(ND2X3),
     1          FD5(ND2X3),FD6(ND2X3),FD7(ND2X3),FDA(ND2X3),
     2          FDVERT(ND2X3),FDTIME(ND2X3),FDSINS(ND2X3),FDMS(ND2X3)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5),ICALLD(L3264W,ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9),MSTORE(7,ND9)
      DIMENSION CORE(ND10)
      DIMENSION KFILIN(ND6),MODNUM(ND6),LDATB(ND6),LDATE(ND6),
     1          LKHERE(ND6),MSDATE(ND6),JFOPEN(ND6)
      DIMENSION INDEXC(ND1,ND6)
      DIMENSION KFILRA(NUMRA)
      DIMENSION LD(3),NBYTES(2),ISTOP(2)
      DIMENSION THRPHS(4),THRTRW(4),THRQPF(2),THRSVR(4)
C
      DATA LPARS/9999/
      DATA LSTOP/500/,
     1     LSTOPC/0/,
     2     NGOMIS/0/
      DATA NODATA/0/
      DATA IFIRST/0/
C
D     CALL TIMPR(KFILDO,KFILDO,'START PRED26        ')
      IER=0
      LD(1)=0
C        ABOVE STATEMENT NECESSARY BECAUSE A FIELD COULD HAVE BEEN
C        LEFT OVER FROM A PREVIOUS DATE.
C
C        SET UP SOME VALUES FOR LOADING IS1( ).
C
      NYR=NDATE/1000000
      NMO=NDATE/10000-NYR*100
      NDA=NDATE/100-NYR*10000-NMO*100
      NHR=NDATE-NYR*1000000-NMO*10000-NDA*100
C
C        ZERO THE ARRAY THAT INDICATES VARIABLES HAVE BEEN DEALT WITH.
C
      DO 101 N=1,NPRED
      INDEX(N)=0
 101  CONTINUE
C
C        SET UP INITIAL SEARCH LIMITS FOR MSTORE( , ).  THE ENTRIES
C        IN MSTORE( , ) WILL BE IN THE SAME ORDER AS THE DATA ARE
C        ENCOUNTERED IN THE INPUT FOR DAY 1.  THEREFORE, IF THE ORDER
C        OF THE DATA ON THE INPUT FILES IS CONSTANT, THE NEXT RECORD
C        TO BE FOUND SHOULD BE THE NEXT ITEM IN MSTORE( , ), SO THE
C        SEARCH STARTS WITH THE LAST ITEM FOUND.  THE WHOLE MSTORE( , )
C        HAS TO BE SEARCHED IF THE RECORD READ IS NOT WANTED.
C
      KSTART=1
      KEND=MITEMS
C
      IF(NUMIN.EQ.0)GO TO 405
C        WHEN THE ABOVE TEST IS MET, INPUT FILES ARE NOT NEEDED.
C
C        DETERMINE DATE RANGE OF DATA FOR EACH MODEL FOR THE DATE IN NDATE.
C        THIS IS DONE EVEN FOR FILES NOT OPEN IN CASE ONE OR MORE HAS
C        TO BE OPENED DURING PROCESSING OF DAY 1; FILES ALREADY CLOSED
C        ARE NOT CONSIDERED.
C
      DO 105 IN=1,NUMIN
      MSDATE(IN)=0
      IF(JFOPEN(IN).EQ.0)GO TO 105
      MODELX=MODNUM(IN)
      INCDTL=9999
      INCDTH=0
C        INCDTH INITIALIZED TO ZERO SO THAT HIGH END DATE WILL NOT BE
C        LESS THAN THE CURRENT DATE
C          
      DO 103 N=1,NPRED
C
C        TAKE CARE OF GRIDPOINT DATA.  THE RR IN THE ID IS OPERATIVE.
C
      IF(MODELX.GT.0)THEN
         IF(MODELX.EQ.IDPARS(4,N))THEN
            INCDTL=MIN(INCDTL,-IDPARS(9,N))
            INCDTH=MAX(INCDTH,-IDPARS(9,N))
         ENDIF
C 
C        NOW TAKE CARE OF VECTOR DATA THAT DID NOT ORIGINATE IN
C        U201 AND WILL NOT HAVE A MODEL NUMBER (E.G. HOURLY DATA).
C        THE RR IN THE ID IS OPERATIVE.
C  
      ELSEIF(IDPARS(4,N).EQ.0)THEN
         INCDTL=MIN(INCDTL,-IDPARS(9,N))
         INCDTH=MAX(INCDTH,-IDPARS(9,N))
C
C        FINALLY, TAKE CARE OF VECTOR DATA THAT MIGHT HAVE COME
C        FROM A PREVIOUS RUN OF U201 AND HAVE A MODEL NUMBER
C        THAT WILL NOT MATCH MODELX.  THE RR IN THE ID IS NOT
C        OPERATIVE.  (THIS WAS CHANGED FROM NOT OPERATIVE 10/4/03
C        BY GLAHN TO ACCOMMODATE MOS FORECASTS.  THIS MAY CAUSE
C        SAVING SOME DATA UNNECESSARILY.  HOWEVER, IT WILL AFFECT
C        ONLY DATA COMING THROUGH U201 THAT HAVE RR GT 0, WHICH
C        SHOULD NOT BE VOLUMINOUS.  BEING ABLE TO USE PAST MOS
C        FORECASTS MAKES MIXING MOS FORECASTS FROM PREVIOUS
C        RUNS OF THE SAME MODEL POSSIBLE, POSSIBLY TO REDUCE
C        VARIATION AND OSCILLATION.  THIS REDUCES THE NEED FOR
C        THE CCC=799 DUMMY VARIABLE.)
C
      ELSEIF(IDPARS(1,N)/100.EQ.2)THEN
C           THIS TAKES CARE OF MOS (CCC = 2XX) FOR PAST DATES (RUNS)
C           IN CASE ONE WANTS TO MIX THEM, POSSIBLY TO REDUCE 
C            OSSIBLE OSCILLATION.  ADDED 10/4/03.
         INCDTL=MIN(INCDTL,-IDPARS(9,N))
         INCDTH=MAX(INCDTH,-IDPARS(9,N))
C
      ELSE
         INCDTL=MIN(INCDTL,0)
         INCDTH=MAX(INCDTH,0)
      ENDIF
C         
 103  CONTINUE
C
      IF(INCDTL.EQ.9999)INCDTL=0
C        WHEN NO VARIABLE MODEL NUMBER MATCHES MODEL INPUT, IT WILL
C        HAVE BEEN NOTED IN RDSTR2 AND A DIAGNOSTIC PRINTED.  IT IS
C        NOT REPEATED HERE.
      CALL UPDAT(NDATE,INCDTL,LDATB(IN)) 
      CALL UPDAT(NDATE,INCDTH,LDATE(IN))
C        ACTUAL DATES ARE NOW IN LDATB(IN) AND LDATE(IN).  THESE ARE 
C        THE FIRST AND LAST DATE/TIMES, RESPECTIVELY, NEEDED FOR THIS
C        DAY.
 105  CONTINUE
C
D     ICOUNT=0
C
D     DO 108 IN=1,NUMIN
D     IF(JFOPEN(IN).EQ.0)GO TO 108
C
D     IF(ICOUNT.EQ.0)THEN
D        WRITE(KFILDO,106)NDATE
D106     FORMAT(/' BEGINNING AND ENDING DATES FOR EACH MODEL FOR DATE',
D    1             I11)
D        ICOUNT=ICOUNT+1
D     ENDIF
C
D     WRITE(KFILDO,107)MODNUM(IN),KFILIN(IN),LDATB(IN),LDATE(IN)
D107  FORMAT('    MODEL NO.',I3,'  ON UNIT NO.',I3,2I12)
D108  CONTINUE
C
D     WRITE(KFILDO,109)
D109  FORMAT(' ')
C
C        FIND/COMPUTE ALL VARIABLES FOR THE DATE IN NDATE.  THIS
C        IS DONE FILE BY FILE, STORING WHAT IS NECESSARY FOR
C        FUTURE COMPUTATIONS.
C
      DO 400 IN=1,NUMIN
C***D     WRITE(KFILDO,1090)
C***D    1      LITEMS,NUMIN,IN,JFOPEN(IN),MSDATE(IN),LKHERE(IN)
C***D1090 FORMAT(' PRED26 AT 1090--LITEMS,NUMIN,IN,JFOPEN,MSDATE,LKHERE',
C***D    1         6I4)
      IER=0
      IF(LKHERE(IN).EQ.0)GO TO 400
C        WHEN LKHERE(IN) = 0, AN END OF FILE HAS BEEN REACHED.
      IF(JFOPEN(IN).NE.1)GO TO 400
C        JFOPEN(IN) MUST BE 1 FOR THE FILE TO BE OPEN.
 110  READ(KFILIN(IN),IOSTAT=IOS,ERR=1101,END=1106)
     1           (NBYTES(J),J=1,L3264W),
     2           (IPACK(J),J=1,MIN(ND5,NBYTES(L3264W)*8/L3264B))
C        IPACK( ) CONTAINS THE PACKED RECORD.
C        THE RECORD CONSISTS OF AN INITIAL 64 BITS CONTAINING THE NUMBER
C        OF BYTES FOLLOWING.  FOR A 32-BIT MACHINE, THIS IS TWO WORDS.
C        FOR A 32-BIT MACHINE, IPACK(5) HOLDS THE DATE/TIME OF THE RECORD.
C        AN EOF MAY BE REACHED HERE FOR GRIDPOINT DATA. FOR VECTOR
C        DATA, NORMALLY THERE WOULD BE A TRAILER BEFORE THE EOF.
C
      GO TO 1104
 
 1101 WRITE(KFILDO,1102)KFILIN(IN),NDATE,IOS,NAMIN(IN)
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)WRITE(IP23,1102)KFILIN(IN),
     1                                NDATE,IOS,NAMIN(IN)
 1102 FORMAT(/' ****ERROR READING PACKED RECORD ON UNIT NO.',I3,
     1        ' PROCESSING DATE',I11,' IN PRED26 AT 1102, IOSTAT =',I5/
     2        '     FILE = ',A60)
      ISTOP(1)=ISTOP(1)+1
      LSTOPC=LSTOPC+1
      IF(LSTOPC.LT.LSTOP)GO TO 110
C        THIS CHECK IS TO STOP AN INFINITE LOOP THAT MIGHT OCCUR.
      WRITE(KFILDO,1103)LSTOP
      IF(IP23.NE.0.AND.IP23.NE.KFILDO)WRITE(IP23,1103)LSTOP
 1103 FORMAT('     A TOTAL OF',I6,' READING ERRORS HAVE OCCURRED.',
     1       '  RETURN FROM PRED26 AT 1103.')
      IER=138
      GO TO 800
C
 1104 IF(L3264B.EQ.32)THEN
C           FOR A 32-BIT MACHINE, IPACK(5) HOLDS THE DATE/TIME OF THE
C           RECORD.
         IDATE=IPACK(5)
C
      ELSE
C           FOR A 64-BIT MACHINE, THE LEFT HALF OF IPACK(3) HOLDS
C           THE DATE/TIME OF THE RECORD.
         LOC=3
         IPOS=1
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IDATE,32,L3264B,IER,*396)
      ENDIF
C
      LSIZE=NBYTES(L3264W)*8/L3264B
C
      IF(LSIZE.GT.ND5)THEN
         WRITE(KFILDO,1105)ND5,LSIZE,KFILIN(IN),NDATE,NAMIN(IN)
 1105    FORMAT(/' ****ERROR IN PRED26 AT 1105.',
     1           '  ND5 MUST BE INCREASED FROM',I8,' TO GE',I8/
     2           '     READING ON UNIT NO.',I3,' PROCESSING DATE',I11,
     3           '    FILE = ',A60)
         ISTOP(1)=ISTOP(1)+1
         IER=38
         GO TO 800
C
      ENDIF
C
      GO TO 115
C
 1106 IF(IP23.NE.0)WRITE(IP23,1107)KFILIN(IN),NDATE,NAMIN(IN)
 1107 FORMAT(/' END OF  FILE ON UNIT NO.',I3,
     1        ' PROCESSING DATE',I11,
     2        '    FILE = ',A60)
 1108 CALL SWITCH(KFILDO,IN,KFILIN,NAMIN,JFOPEN,LKHERE,MSDATE,
     1            NUMIN,ND6,NDATE,IRD,IP23,ISTOP(1),IER)
      IF(IER.NE.0)GO TO 400
C        ISTOP(1) INCREMENTED IN SWITCH ON ERROR.
      IF(IRD.EQ.0)GO TO 400
C        IRD NE 0 FROM SWITCH WHEN KFILIN( ) GE 80.  PRESUMABLY,
C        THIS WILL NOT HAPPEN, BUT TAKES CARE OF THE POSSIBILITY
C        THAT A TRAILER DOES NOT FOLLOW THE LAST DATA BEFORE 
C        AN EOF.  JFOPEN( ) AND LKHERE( ) ARE TAKEN CARE OF IN
C        SWITCH.
C
C        FALL THROUGH HERE MEANS THE DATA ARE VECTOR, ANOTHER
C        FILE EXISTS WITH THE SAME UNIT NUMBER, AND THE OPEN
C        WAS MADE OK.  DIRECTORY HAS TO BE READ, ETC.
C
      CALL RDDIR(KFILDO,KFILIN(IN+1),IP12,NAMIN(IN+1),NDATE,
     1           CCALL,INDEXC(1,IN+1),ND1,NSTA,CCALLD,ND5,MSTA,
     2           L3264B,L3264W,IER)
C
      IF(IER.EQ.0)GO TO 400
      IF(IER.NE.146)ISTOP(1)=ISTOP(1)+1
C        EVEN IER = 120 FOR ONE OR MORE STATIONS MISSING WILL
C        BE COUNTED AS AN ERROR.  HOWEVER, IER = 146 SIGNIFYING
C        AN EOF IS NOT UNEXPECTED AND IS NOT COUNTED AS AN ERROR.
      IF(IER.EQ.140.OR.
     1   IER.EQ.145.OR.
     2   IER.EQ.146)THEN
         CLOSE(UNIT=KFILIN(IN+1),IOSTAT=IOS,ERR=1110)
C           CERTAIN ERRORS ARE TREATED AS IF AN END OF FILE
C           HAS BEEN REACHED.
         IF(IP23.NE.0)WRITE(IP23,1109)KFILIN(IN+1),
     1             NDATE,NAMIN(IN+1)
 1109    FORMAT(' CLOSING FILE ON UNIT NO.',I3,
     1          ' PROCESSING DATE',I11,'    FILE = ',A60)
         GO TO 1114
C
 1110    WRITE(KFILDO,1111)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)
     1       WRITE(IP23,1111)KFILIN(IN+1),NDATE,IOS,NAMIN(IN+1)
 1111    FORMAT(/' ****ERROR CLOSING FILE ON UNIT NO.',I3,
     1           ' PROCESSING DATE',I11,' IN PRED26 AT 1111,',
     2           ' IOSTAT =',I5/
     3           '     FILE = ',A60)
         ISTOP(1)=ISTOP(1)+1
 1114    LKHERE(IN+1)=0
         JFOPEN(IN+1)=0
      ENDIF
C
C        DROP THROUGH HERE WHEN IER = 0 OR 120.
      GO TO 400
C
 115  IF(IDATE.NE.9999)GO TO 1155
C        THE ABOVE TEST IS FOR A TRAILER RECORD ON VECTOR DATA.
C        IF FOUND, AN ATTEMPT IS MADE TO READ A DIRECTORY RECORD
C        ON THE SAME FILE.
C
      CALL RDDIR(KFILDO,KFILIN(IN),IP12,NAMIN(IN),NDATE,
     1           CCALL,INDEXC(1,IN),ND1,NSTA,CCALLD,ND5,MSTA,
     2           L3264B,L3264W,IER)
C
      IF(IER.EQ.0)GO TO 110
C        THE ABOVE WOULD OCCUR WHEN A DIRECTORY RECORD FOLLOWS
C        A TRAILER ON THE SAME FILE.
C
      IF(IER.EQ.146)GO TO 1106
C           IER = 146 HERE MEANS AN END OF FILE WAS FOUND AFTER
C           A TRAILER.  THIS IS EXPECTED AND IS NOT COUNTED
C           AS AN ERROR.  SWITCH FILES.
C
      ISTOP(1)=ISTOP(1)+1
C        EVEN IER = 120 FOR ONE OR MORE STATIONS MISSING WILL
C        BE COUNTED AS AN ERROR.
      IF(IER.EQ.120)GO TO 110
C        OTHER VALUES OF IER ARE LIKELY UNRECOVERABLE ERRORS;
C        SWITCH FILES ANYWAY, BUT DO NOT PRINT AN EOF MESSAGE.
      GO TO 1108
C
 1155 IF(IDATE.LT.LDATB(IN))THEN
         GO TO 110
C           THE ABOVE SPACES UP TO THE DAY WANTED.
      ELSE IF(IDATE.GT.LDATE(IN))THEN
         BACKSPACE KFILIN(IN)
C           THE READ ABOVE HAS GONE BEYOND THE DATE WANTED BY 1 RECORD;
C           THEREFORE, THE BACKSPACE.  (NOTE:  TO ELIMINATE BACKSPACE,
C           THE NUMBER OF VARIABLES NEEDED FROM EACH MODEL WOULD BE
C           NEEDED.  THIS COULD BE GOTTEN FROM THE DAY ONE PROCESSING.
C           BUT WITH DISK, RATHER THAN TAPE, READING AND MODERN
C           BUFFERING, IS NOT WORTH THE EFFORT.)
C***D     WRITE(KFILDO,1156)KFILIN(IN),NDATE
C***D1156 FORMAT(' BACKSPACING INPUT FILE ON UNIT NO.',I3,
C***D    1       ' PROCESSING DATE',I11,' IN PRED26 AT 1156')
         GO TO 400
      ENDIF
C
C        THIS IS A DATE TO USE FOR THIS MODEL FOR THIS DAY.
C        DOES IT HAVE THE NEEDED ID'S?  NOTE THAT IS1(9-11) =
C        IPACK(6-8) ON A 32-BIT MACHINE.  ON A 64-BIT MACHINE,
C        THE 3 ID'S HAVE TO BE UNPACKED.  STILL HAVE TO CHECK
C        THE TIME (CYCLE) OR ALL INTERMEDIATE CYCLES ON THE
C        INPUT WILL BE SAVED WHEN NOT NEEDED.
C
      MSDATE(IN)=1
C        MSDATE(IN) = 1 INDICATES SOME DATA WERE AVAILABLE ON THIS FILE
C        FOR THIS DATE.
      JCYL=MOD(IDATE,100)
      IF(L3264B.EQ.32)THEN
C
 1157    DO 116 M=KSTART,KEND
C           THE INDEX IN THIS LOOP IS M.  LATER, N REFERS TO A PARTICULAR
C           VARIABLE.
D     WRITE(KFILDO,1158)IDATE,JCYL,MSTORE(6,M),
D    1     (IPACK(L),L=6,9),(MSTORE(L,M),L=1,4)
D1158 FORMAT(/' IDATE,JCYL,MSTORE(6,M),IPACK,MSTORE',I12,2I4,4I12/
D    1      ('                                                        ',
D    2      4I12))
C
         IF(IPACK(6).EQ.MSTORE(1,M).AND.
     1      IPACK(7).EQ.MSTORE(2,M).AND.
     2      IPACK(8).EQ.MSTORE(3,M).AND.
     3      IPACK(9).EQ.MSTORE(4,M).AND.
     4      JCYL.EQ.MSTORE(6,M))THEN
C              NOTE THAT THE CYCLE IS CHECKED.
C
            N=MOD(MSTORE(5,M),7777)
C
            IF(MSTORE(5,M).NE.7777)THEN
C                 NOTE THAT N CAN = 0, SO IN THAT CASE THE TEST BELOW
C                 IS NOT VALID.  N IS USED AS AS A SUBSCRIPT, BUT WHEN
C                 MSTORE(5,M) = 7777, IT IS NEVER USED THAT WAY.  THIS
C                 TEST FOR 7777 CAUSES THE DATA TO BE KEPT.  TEST
C                 INSERTED 10/25/03.
               IF(INDEX(N).EQ.1.AND.MSTORE(7,M).EQ.0)GO TO 116
C                 WHEN THE ABOVE TEST IS MET, THE VARIABLE HAS ALREADY
C                 BEEN FOUND.  THIS CAN HAPPEN WHEN A PREVIOUS RUN OF
C                 U201 IS INPUT, AS WELL AS THE INPUT TO THE PREVIOUS
C                 U201 RUN.  TEST ON MSTORE(7,M) ADDED 9/7/03, NECESSARY
C                 TO SAVE PAST DATA IN SOME CIRCUMSTANCES; THIS MIGHT
C                 CAUSE DUPLICATE PROCESSING IF DUPLICATES WERE INPUT.
            ENDIF
C
            CALL UPDAT(IDATE,MSTORE(7,M),NEWDAT)
C              USUALLY THE LOOKBACK FEATURE WON'T BE OPERATIVE
C              AND MSTORE(7,M) WILL BE ZERO, IN WHICH CASE
C               UPDAT IS NOT EXPENSIVE.  NEWDAT IS USED LATER.
C***D           WRITE(KFILDO,1159)IDATE,NDATE,NEWDAT,M,N,
C***D    1                        (MSTORE(LL,M),LL=1,5)
C***D1159       FORMAT(' AT 1159,IDATE,NDATE,NEWDAT,M,N,',
C***D    1             '(MSTORE(LL,M),LL=1,5)'/
C***D    2             '          ',3I12,2I6,5I10)
C
            IF(IDATE.EQ.NDATE)THEN
               GO TO 117
            ELSE
               IF(NEWDAT.GE.NDATE)GO TO 117
            ENDIF
C
         ENDIF
C               
 116     CONTINUE
C
         IF(KSTART.EQ.1)THEN
            KSTART=MAX(KEND+1,MITEMS)
            KEND=MITEMS
            GO TO 110
C              SEARCH DONE.  START THE NEXT SEARCH WHERE THE
C              LAST SUCCESSFUL ONE LEFT OFF.
         ELSE
            KEND=KSTART-1
            KSTART=1
            GO TO 1157
C              COMPLETE SEARCH.
         ENDIF
C
      ELSE
         LOC=3
         IPOS=33
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA6,32,L3264B,IER,*396)
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA7,32,L3264B,IER,*396)
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA8,32,L3264B,IER,*396)
         CALL UNPKBG(KFILDO,IPACK,ND5,LOC,IPOS,IPA9,32,L3264B,IER,*396)
C
 1160    DO 1165 M=KSTART,KEND
C           THE INDEX IN THIS LOOP IS M.  LATER, N REFERS TO A PARTICULAR
C           VARIABLE.
C
         IF(IPA6.EQ.MSTORE(1,M).AND.
     1      IPA7.EQ.MSTORE(2,M).AND.
     2      IPA8.EQ.MSTORE(3,M).AND.
     3      IPA9.EQ.MSTORE(4,M).AND.
     4      JCYL.EQ.MSTORE(6,M))THEN
C              NOTE THAT THE CYCLE IS CHECKED.
C
            N=MOD(MSTORE(5,M),7777)
C
            IF(MSTORE(5,M).NE.7777)THEN
C                 NOTE THAT N CAN = 0, SO IN THAT CASE THE TEST BELOW
C                 IS NOT VALID.  N IS USED AS AS A SUBSCRIPT, BUT WHEN
C                 MSTORE(5,M) = 7777, IT IS NEVER USED THAT WAY.  THIS
C                 TEST FOR 7777 CAUSES THE DATA TO BE KEPT.  TEST
C                 INSERTED 10/25/03.
               IF(INDEX(N).EQ.1.AND.MSTORE(7,M).EQ.0)GO TO 1165
C                 WHEN THE ABOVE TEST IS MET, THE VARIABLE HAS ALREADY
C                 BEEN FOUND.  THIS CAN HAPPEN WHEN A PREVIOUS RUN OF
C                 U201 IS INPUT, AS WELL AS THE INPUT TO THE PREVIOUS
C                 U201 RUN.  TEST ON MSTORE(7,M) ADDED 9/7/03, NECESSARY
C                 TO SAVE PAST DATA IN SOME CIRCUMSTANCES; THIS MIGHT
C                 CAUSE DUPLICATE PROCESSING IF DUPLICATES WERE INPUT.
            ENDIF
C
            CALL UPDAT(IDATE,MSTORE(7,M),NEWDAT)
C              USUALLY THE LOOKBACK FEATURE WON'T BE OPERATIVE
C              AND MSTORE(7,M) WILL BE ZERO, IN WHICH CASE
C              UPDAT IS NOT EXPENSIVE.  NEWDAT IS USED LATER.
C****D           WRITE(KFILDO,1160)IDATE,NDATE,NEWDAT,M,N,MSTORE(5,M)
C****D1160       FORMAT(' AT 1160,IDATE,NDATE,NEWDAT,M,N,MSTORE(5,M)',
C****D    1                        3I12,3I6)
C
            IF(IDATE.EQ.NDATE)THEN
               GO TO 117
            ELSE
               IF(NEWDAT.GE.NDATE)GO TO 117
            ENDIF
C
         ENDIF
C
 1165    CONTINUE
C
         IF(KSTART.EQ.1)THEN
            KSTART=MAX(KEND+1,MITEMS)
            KEND=MITEMS
            GO TO 110
C              SEARCH DONE.  START THE NEXT SEARCH WHERE THE
C              LAST SUCCESSFUL ONE LEFT OFF.
         ELSE
            KEND=KSTART-1
            KSTART=1
            GO TO 1160
C              COMPLETE SEARCH.
         ENDIF
C
      ENDIF
C
C        THE DATA ARE NEEDED.  UNPACK THE ID'S, WHICH ARE NEEDED
C        FOR STORING THE DATA.
C
 117  KSTART=M
C        SAVE M FOR START OF NEXT SEARCH.  STARTING AT M RATHER
C        THAN M+1 DOESN'T REQUIRE M+1.GT.MITEMS CHECK.
      KEND=MITEMS
C        KEND IS THE END OF THE NEXT (PARTIAL) SEARCH.
      CALL UNPACK(KFILDO,IPACK,IWORK,DATA,ND5,
     1            IS0,IS1,IS2,IS4,ND7,MISSP,MISSS,1,L3264B,IER)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN UNPACK.
      IVECT=1
      IF(BTEST(IS1(2),0))IVECT=0
C        IVECT = 1 FOR VECTOR DATA, 0 FOR GRIDPOINT DATA.
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           DATA ARE NOT SAVED OR USED.  ANY ERROR IN UNPACK WILL
C           HAVE CREATED A DIAGNOSTIC.
         GO TO 110
      ENDIF
C
      IF(IVECT.EQ.1)GO TO 118
C
C**********************************************************
C
C        THIS SECTION IS FOR GRIDPOINT DATA ONLY.  THE ONLY
C        WAY OUT OF HERE IS TO STATEMENT NOS. 110, 134, OR 800.   
C
C**********************************************************
      CALL GRCOMB(KFILDO,IP12,IS2,ND7,NGRIDC,ND11,NGRID,NSLAB,
     1            CCALL,NAME,STALAT,STALON,DIR,ND1,NSTA,IER)
C        UPON RETURN FROM GRCOMB, NSLAB IS THE NUMBER OF THE GRID
C        COMBINATION IN NGRIDC OF THE GRID TO STORE.
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           AN ERROR IN GRCOMB WILL HAVE CREATED A DIAGNOSTIC. 
         GO TO 800
C           IER NE 0 IS TREATED AS FATAL IN PRED26 WITH RETURN TO CALLING
C           PROGRAM.  THAT IS, WHEN THE VARIABLE IS NEEDED, A GRID 
C           COMBINATION MUST BE ABLE TO BE DETERMINED FOR GRIDPOINT DATA.
      ENDIF
C
      IF(NEWDAT.LT.NDATE)GO TO 110
C        THE ABOVE IS A SAFETY.  SHOULD NEVER GET HERE WHEN
C        NEWDAT LT NDATE.
C
      IF(MSTORE(5,M).LT.7777)GO TO 1176
C        MSTORE(5, ) LT 7777 INDICATES IT DOESN'T NEED TO BE STORED.
C
      NRRDAT=IS1(8)
      IF(MSTORE(7,M).NE.0)CALL UPDAT(IS1(8),MSTORE(7,M),NRRDAT)
C        NRRDAT IS THE LATEST DATE/TIME THIS VARIABLE MAY BE NEEDED.
      CALL GSTORE(KFILDO,KFIL10,IS1(9),NSLAB,LSTORE,ND9,LITEMS,
     1            IPACK,LSIZE,2,NRRDAT,IS1(8),
     2            CORE,ND10,LASTL,NBLOCK,LASTD,NSTORE,L3264B,IER)
C        THIS VARIABLE IS STORED PACKED AND WILL BE USED LATER.
C        LSIZE IS THE SIZE OF THE PACKED RECORD.
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           AN ERROR IN GSTORE WILL HAVE CREATED A DIAGNOSTIC.  THIS
C           SHOULD NOT HAPPEN; IT IT DOES, THE DATA WILL NOT BE
C           AVAILABLE LATER, SO DON'T USE IT NOW.
         GO TO 110
      ENDIF
C
C        THIS VARIABLE HAS BEEN STORED.
      IF(MSTORE(5,M).EQ.7777)GO TO 110
C        WHEN MSTORE(5,M) = 7777, IT IS ONLY STORED.
C
 1176 IF(IDATE.NE.NDATE)GO TO 110
C        ONLY ON TIME DATA CAN BE USED DIRECTLY.
C
C        CONTROL NEVER GOES BEYOND THIS POINT IN THE INITIAL LOOP TO 
C        STATEMENT 400 UNLESS THE DATE IS CURRENT.
C        THIS ARRANGEMENT ASSURES THAT THE DATA NEEDED ARE STORED
C        FOR LATER RECOVERY, BUT DOES NOT GUARANTEE THAT THE DATA
C        ARE USED WHEN ENCOUNTERED.
C
C        DETERMINE WHETHER DATA READ MATCHES THE TYPE EXPECTED,
C        VECTOR OR GRIDPOINT.
C
      IF(ISTAV(N).EQ.2)THEN
C           ISTAV( ) WAS UNDETERMINED UNTIL NOW.
         ISTAV(N)=IVECT
      ELSEIF(IVECT.NE.ISTAV(N))THEN
         WRITE(KFILDO,1189)MODNUM(IN),KFILIN(IN),NDATE,NAMIN(IN)
         ISTOP(1)=ISTOP(1)+1
         GO TO 110
C
      ENDIF
C
      CALL UNPACK(KFILDO,IPACK,IWORK,DATA,ND5,
     1            IS0,IS1,IS2,IS4,ND7,MISSP,MISSS,2,L3264B,IER)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN UNPACK.
C        THE UNPACKED DATA NOW RESIDE IN DATA( ), UNLESS IER NE 0.
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           AN ERROR IN UNPACK WILL HAVE CREATED A DIAGNOSTIC.
         GO TO 110
      ENDIF
C
      IF(MISSP.NE.0)MISTOT=MISTOT+1
C        MISTOT IS INCREMENTED IF GRIDPOINT DATA HAVE MISSING DATA.
C
      NSIZE=IS2(3)*IS2(4)
C        NSIZE IS THE SIZE OF THE GRID.  CONTROL NEVER REACHES
C        HERE UNLESS THE DATA ARE GRIDPOINT AND ARE GOOD.
C
C        CHECK SIZE OF GRID.  NOTE THAT AN EARLIER CHECK WAS
C        ON LSIZE, THE SIZE OF THE RECORD READ.
C
      IF(NSIZE.GT.ND5)THEN
         WRITE(KFILDO,1178)ND5,NSIZE,KFILIN(IN),NDATE,NAMIN(IN)
 1178    FORMAT(/' ****ERROR IN PRED26 AT 1178.',
     1           '  ND5 MUST BE INCREASED FROM',I8,' TO GE',I8/
     2           '     READING ON UNIT NO.',I3,' PROCESSING DATE',I11,
     3           '    FILE = ',A60)
         ISTOP(1)=ISTOP(1)+1
         IER=38
         GO TO 110
      ENDIF
C
      GO TO 134
C
C**********************************************************
C
C        THIS SECTION FOR VECTOR DATA ONLY.  ASSOCIATE DATA
C        WITH STATION LOCATIONS.  THE ONLY WAY OUT OF HERE IS
C        TO STATEMENT NOS. 110 OR 350.
C
C**********************************************************
C
 118  ISTA=IS4(3)
      IF(ISTA.GT.ND5)THEN
         WRITE(KFILDO,1182)ND5,ISTA,KFILIN(IN),NDATE,NAMIN(IN)
 1182    FORMAT(/' ****ND5 =',I6,' TOO SMALL FOR DATA ARRAY',
     1           ' IN PRED26 AT 1182.  INCREASE TO GE',I6/
     2           '     READING ON UNIT NO.',I3,
     3           ' PROCESSING DATE',I11,'    FILE = ',A60)
         IER=38
C           SET SDATA( ) TO MISSING.  DATA( ) WILL NOT HAVE
C           BEEN OVERFLOWED, BUT WILL CONTAIN THE MISSING
C           INDICATOR.
C
         ISTOP(1)=ISTOP(1)+1
C           DATA ARE NOT USED OR STORED.
         GO TO 110
C
      ELSE
C
C           PUT DATA INTO SDATA( ).  NOTE THAT EXCEPT FOR THE
C           INITIAL RETRIEVAL INTO DATA( ), ONLY THE NSTA WORDS
C           OF DATA ARE DEALT WITH.
C      
         CALL UNPACK(KFILDO,IPACK,IWORK,DATA,ND5,
     1               IS0,IS1,IS2,IS4,ND7,MISSP,MISSS,2,L3264B,IER)
C           THE UNPACKED DATA NOW RESIDE IN DATA( ), UNLESS IER NE 0.
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN UNPACK.
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           AN ERROR IN UNPACK WILL HAVE CREATED A DIAGNOSTIC.
         GO TO 110
      ENDIF
C
         DO 1184 K=1,NSTA
C
         IF(INDEXC(K,IN).EQ.99999999)THEN
            SDATA(K)=9999.
         ELSE
            SDATA(K)=DATA(INDEXC(K,IN))
            IF(SDATA(K).EQ.9997.)SDATA(K)=PXMISS
C              THE ABOVE STATEMENT ALLOWS THE MISSING VALUE
C              9997 TO BE TREATED AS SOME OTHER VALUE.  THIS
C              WOULD USUALLY BE 0, BUT COULD BE, SAY, 9999.
         ENDIF
C
 1184    CONTINUE
C
         NSLAB=0
C           NSLAB IS SET TO 0 FOR VECTOR DATA FOR POSSIBLE
C           STORAGE BY GRCOMB.
      ENDIF
C
      IF(NEWDAT.LT.NDATE)GO TO 110
C        THE ABOVE IS A SAFETY.  SHOULD NEVER GET HERE WHEN
C        NEWDAT LT NDATE.
C
      IF(MSTORE(5,M).LT.7777)GO TO 1186
C        MSTORE(5, ) LT 7777 INDICATES IT DOESN'T NEED TO BE STORED.
C
      NRRDAT=IS1(8)
      IF(MSTORE(7,M).NE.0)CALL UPDAT(IS1(8),MSTORE(7,M),NRRDAT)
C        NRRDAT IS THE LATEST DATE/TIME THIS VARIABLE MAY BE NEEDED.
      CALL GSTORE(KFILDO,KFIL10,IS1(9),0,LSTORE,ND9,LITEMS,
     1            SDATA,NSTA,1,NRRDAT,IS1(8),
     2            CORE,ND10,LASTL,NBLOCK,LASTD,NSTORE,L3264B,IER)
C        THIS VARIABLE IS STORED UNPACKED AND WILL BE USED LATER.
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           AN ERROR IN GSTORE WILL HAVE CREATED A DIAGNOSTIC.
         GO TO 110
      ENDIF
C
C        THIS VARIABLE HAS BEEN STORED.
 1186 IF(MSTORE(5,M).EQ.7777)GO TO 110
C        WHEN MSTORE(5,M) = 7777, IT IS ONLY STORED.
C
      IF(IDATE.NE.NDATE)GO TO 110
C        ONLY ON TIME DATA CAN BE USED DIRECTLY.
C
C        CONTROL NEVER GOES BEYOND THIS POINT IN THE INITIAL LOOP TO 
C        STATEMENT 400 UNLESS THE DATE IS CURRENT.
C        THIS ARRANGEMENT ASSURES THAT THE DATA NEEDED ARE STORED
C        FOR LATER RECOVERY, BUT DOES NOT GUARANTEE THAT THE DATA
C        ARE USED WHEN ENCOUNTERED.
C
C        DETERMINE WHETHER DATA READ MATCHES THE TYPE EXPECTED,
C        VECTOR OR GRIDPOINT.
C
      IF(ISTAV(N).EQ.2)THEN
C           ISTAV( ) WAS UNDETERMINED UNTIL NOW.
         ISTAV(N)=IVECT
      ELSEIF(IVECT.NE.ISTAV(N))THEN
         WRITE(KFILDO,1189)MODNUM(IN),KFILIN(IN),NDATE,NAMIN(IN)
 1189    FORMAT(/' ****MODEL NO.',I3,' ON UNIT NO.',I3,
     1           ' IMPLYING GRIDPOINT OR VECTOR DATA DOES NOT AGREE'/
     2           '     WITH TYPE OF DATA READ IN PRED26. ',
     3           ' MODEL NUMBERS OF 80 AND ABOVE ARE RESERVED',
     4           ' FOR VECTOR DATA.'/
     5           '     PROCESSING DATE',I11,'    FILE = ',A60)
         ISTOP(1)=ISTOP(1)+1
         GO TO 110
C
      ENDIF
C
      GO TO 350
C        NOTE THAT VECTOR DATA FROM THE INPUT HAS NO COMPUTATIONS
C        DONE.
C
C***********************************************************
C
C        END OF VECTOR SECTION ONLY.
C
C***********************************************************
C 
C        THIS VARIABLE CAN BE REUSED FROM THE PREVIOUS ONE ONLY IF:
C           (1) IT IS A GRID AND ONLY THE POINT COMPUTATIONS
C               ARE NECESSARY (E.G., INTERPOLATION).
C        IF GRID PROCESSING (E.G., SMOOTHING) IS NEEDED ON A 
C        BASIC GRID, IT MAY BE SAVED IN FDA( ).
C
 119  IF(JD(1,N).EQ.JD(1,N-1).AND.
     1   JD(2,N).EQ.JD(2,N-1).AND.
     2   JD(3,N).EQ.JD(3,N-1).AND.
     3   IDPARS(3,N).NE.5.AND.
     4   IDPARS(3,N-1).NE.5.AND.
CCC     5   IDPARS(13,N).EQ.IDPARS(13,N-1).AND.
CCC  OMITTED 2/16/09
     6   IDPARS(14,N).EQ.IDPARS(14,N-1).AND.
     7   IDPARS(15,N).EQ.IDPARS(15,N-1).AND.
     8   ((IDPARS(8,N).EQ.IDPARS(8,N-1)).OR.(IDPARS(8,N).LT.7.AND.
     9                                       IDPARS(8,N-1).LT.7)).AND.
     A   (IDPARS(3,N).LE.1.AND.IDPARS(3,N-1).LE.1).AND.
C           ABOVE ADDED 9/30/09 FOR RF FROM SREF WITH B = 2
     B   NGOMIS.EQ.0)THEN
C           THE CHECK ON IDPARS(3,N-1) IS NOT NECESSARY WHEN
C           THE VARIABLES ARE ORDERED, AS THEY SHOULD BE
C           UNLESS SORTEM IS TAKEN OUT OF RDPRED.  NGOMIS
C           IS 1 WHEN THE PREVIOUS VARIABLE WAS MISSING.
C           THE CHECKS ON IDPARS(8, ) PUT IN WHEN THE VALUES
C           OF 7, 8, AND 9 WERE ADDED FOR VARIANCE (GRIDDED)
C           COMPUTATIONS.  NOTE THAT V MUST BE THE SAME FOR N AND N-1
C           UNLESS BOTH ARE LT 7.
C
D        WRITE(KFILDO,1191)N,(ID(K,N),K=1,4)
D1191    FORMAT(' REUSING GRID FOR VECTOR COMPUTATIONS AT 1191',
D    1          ' IN PRED26 FOR VARIABLE NO.',I3,I12.9,3I11)
C       
         GO TO 220
C
      ENDIF
C
C        WHEN THE ABOVE TEST IS MET, THE VECTOR NEEDED IS THE
C        SAME AS THE PREVIOUS ONE.  THE DATA ARE IN DATA( )
C        AND POINT COMPUTATIONS WILL BE DONE.  THE ONLY THING THAT
C        CAN BE DIFFERENT ARE BINARY THRESHOLDS.  SINCE POINT
C        BINARIES ARE NOT USUALLY MADE IN U201, THIS PROBABLY
C        HAS LITTLE UTILITY.
C
C        IS THIS GRID REUSABLE AND STORED IN FDA( )?  NOTE THAT
C        THESE DATA ARE USED FOR MAKING A GRID BINARY AND/OR
C        SMOOTHING.
C
      IF(JD(1,N).NE.LD(1).OR.
     1   JD(2,N).NE.LD(2).OR.
     2   JD(3,N).NE.LD(3).OR.
     3   IDPARS(3,N).EQ.2.OR.
C           ADDED THE ABOVE 9/20/09 FOR SREF RF WITH B = 2.
     4   LPARS.NE.IDPARS(15,N).OR.
     5   IDPARS(8,N).GE.7)GO TO 110
C
C        TAKE DATA FROM FDA( ).  DATA CAN BE USED FROM FDA( )
C        WHEN THE GRID (FROM GSTORE OR OPTION) IS THE SAME,
C        BUT MAKING A GRID BINARY AND SMOOTHING CAN BE DIFFERENT,
C        AS WELL AS THE POINT CALCULATIONS OF MAKING A POINT
C        BINARY, TRANSFORMATION, AND INTERPOLATION.  THE CHECK ON
C        IDPARS(8, ) PUT IN WHEN THE VALUES OF 7, 8, AND 9 WERE
C        ADDED FOR VARIANCE (GRIDDED) COMPUTATIONS.
C
D     WRITE(KFILDO,1195)N,(ID(K,N),K=1,4)
D1195 FORMAT(' REUSING GRID FROM FDA( ) AT 1190 IN PRED26',
D    1       ' FOR VARIABLE NO.',I3,I12.9,3I11)
C
      DO 120  K=1,NSIZE
      DATA(K)=FDA(K)
 120  CONTINUE
C
      GO TO 205
C
 134  IF(N.EQ.NPRED)GO TO 205
      IF(NSIZE.GT.ND2X3)GO TO 205
C        NSIZE CAN BE GREATER THAN ND2X3, BECAUSE ND5 CAN EXCEED
C        ND2X3.  THIS IS TO HANDLE LARGE CONSTANT GRIDS, SUCH
C        AS FINE SCALE TERRAIN.
C
C        SAVE GRID FOR POSSIBLE REUSE.  IT IS POSSIBLE IT WON'T BE 
C        NEEDED FOR THE NEXT VARIABLE (E.G., POINT BINARY) BUT
C        WILL BE NEEDED FOR THE NEXT (E.G., GRID BINARY).  OR IT
C        MAY NOT BE NEEDED AT ALL, BUT THIS CONTINGENCY KEEPS
C        GRIDS FROM BEING STORED BY GSTORE UNNECESSARILY.
C
      IF(JD(1,N).NE.JD(1,N+1).OR.
     1   JD(2,N).NE.JD(2,N+1).OR.
     2   JD(3,N).NE.JD(3,N+1).OR.
     3   IDPARS(3,N).EQ.2.OR.
C           ABOVE ADDED 9/20/09 FOR RF FROM SREF
     4   IDPARS(15,N).NE.IDPARS(15,N+1))GO TO 205
C        THE IDPARS(15, ) CHECK IS A SAFETY.  AT PRESENT, IDPARS(15, )
C        IS NOT USED.     
C
      IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)GO TO 205
C        TERRAIN HEIGHT IS NOT SAVED WHEN DD = 0 (DD = 5 FOR LAMP
C        FORECASTS).
C
      LD(1)=JD(1,N)
      LD(2)=JD(2,N)
      LD(3)=JD(3,N)
      IF(IDPARS(8,N).GE.7)LD(3)=ID(3,N)
C        WHEN THIS IS A VARIANCE CALCULATION (ON THE GRID), THE
C        IDPARS(8,N) = T IS SAVED.
      LPARS=IDPARS(15,N)
C
D     IF(IDPARS(8,N).LT.7)THEN
D        WRITE(KFILDO,139)N,(JD(K,N),K=1,4)
D139     FORMAT(/' SAVING GRID NO.',I3,' IN FDA( ) AT 139',
D    1           ' IN PRED26    ',I11.9,3I11)
D     ELSE
D        WRITE(KFILDO,139)N,(JD(K,N),K=1,2),ID(3,N),JD(4,N)
D1390    FORMAT(/' SAVING GRID NO.',I3,' IN FDA( ) AT 1390',
D    1           ' IN PRED26    ',I11.9,3I11)
D     ENDIF
C
      DO 140 K=1,NSIZE
      FDA(K)=DATA(K)
 140  CONTINUE
C
C        AT THIS POINT, THE VARIABLE EXISTS IN DATA( ).
C        THE FULL IDENTIFICATION IS IN IS1( ), IS2( ),
C        AND IS4( ).  IF IT MAY BE NEEDED FOR THE 
C        NEXT VARIABLE AND IS A GRID, THE DATA ARE ALSO IN FDA( ).
C
C        MAKE GRID BINARY IF DESIRED.
C
 205  IF(IDPARS(3,N).EQ.5)THEN
         CALL GRIDB(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),
     1              DATA,IWORK,IS2(3),IS2(4),IER)
C           IWORK( ) IS USED AS FLOATING POINT IN GRIDB.
C           THAT IS OK.  IWORK( ) AND DATA( ) ARE BOTH
C           DIMENSIONED ND5.
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
            GO TO 300
C              AN ERROR IN GRIDB WILL HAVE CREATED A DIAGNOSTIC AND DATA
C              ARE RETURNED AS MISSING.
         ENDIF
C
      ENDIF
C
C        SMOOTH FIELD IF DESIRED.
C
      IF(IDPARS(14,N).NE.0)THEN
C
         IF(IDPARS(14,N).EQ.1)THEN
            CALL SMTH5 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.2)THEN
            CALL SMTH9 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.3)THEN
            CALL SMTH25(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.4)THEN
            CALL SMTH2X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.5)THEN
            CALL SMTH3X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
C              IWORK( ) IS USED AS FLOATING POINT IN 
C              SMOOTHING ROUTINES.  THAT IS OK.  IWORK( )
C              AND DATA( ) ARE BOTH DIMENSIONED ND5.
         ENDIF
C
      ENDIF
C
C        PRINT GRIDPOINT VALUES IF DESIRED.  TRY TO MATCH PRECISION
C        OF PRINTING TO SIZE OF VALUES THROUGH ISCALD( ).  WHILE
C        THE LOOP IS INEFFICIENT, IT WILL BE EXECUTED VERY RARELY.
C
 206  IF(IP13.EQ.0)GO TO 2092
      IF(JP(1,N).EQ.0)GO TO 2092
C
      WRITE(IP13,207)(ID(J,N),J=1,4),NDATE
 207  FORMAT(/' GRIDPOINT VALUES FOR VARIABLE',I11.9,3I11,
     1        ' FOR DATE',I12/)
C
      DO 209 JY=1,IS2(4)
C
      IF(ISCALD(N).LE.-1)THEN
         WRITE(IP13,208)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 208     FORMAT(' ',10F10.1/(' ',10F10.1))
      ELSEIF(ISCALD(N).EQ.0)THEN
         WRITE(IP13,2080)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2080    FORMAT(' ',10F10.2/(' ',10F10.2))
      ELSEIF(ISCALD(N).EQ.1)THEN
         WRITE(IP13,2081)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2081    FORMAT(' ',10F10.3/(' ',10F10.3))
      ELSEIF(ISCALD(N).EQ.2)THEN
         WRITE(IP13,2082)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2082    FORMAT(' ',10F10.4/(' ',10F10.4))
      ELSE
         WRITE(IP13,2083)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2083    FORMAT(' ',10F10.5/(' ',10F10.5))
      ENDIF
C
 209  CONTINUE
C
C        WRITE GRIDDED DATA TO IP19.  THIS IS PRIMARILY FOR
C        GMOS_PLOT, AND IS SCALED AS NEEDED.  THE VECTOR
C        DATA ARE WRITTEN SCALED IN U201.  
C
 2092 IF(IP19.NE.0)THEN
         ITAUH=IDPARS(12,N)
         ITAUM=0
         MODNO=IDPARS(4,N) 
         NSEQ=0     
         NPROJ=NGRIDC(1,NSLAB) 
         XMESHL=NGRIDC(2,NSLAB)/1000000. 
         XLAT=NGRIDC(3,NSLAB)/10000.
         ORIENT=NGRIDC(4,NSLAB)/10000.
         ALATL=NGRIDC(5,NSLAB)/10000.
         ALONL=NGRIDC(6,NSLAB)/10000.
         NX=IS2(3)
         NY=IS2(4)
         CALL NOMINL(KFILDO,XMESHL,MESH,TRASH,NPROJ,IER)
C           MESH IS THE NOMINL GRID MESH LENGTH.
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
            WRITE(KFILDO,2094)
 2094       FORMAT('     GRID NOT WRITTEN TO IP(19).')
C              THIS FOLLOWS A **** DIAGNOSTIC IN NOMINL.
            GO TO 210
         ENDIF
C
         IF(IDPARS(1,NPRED).EQ.002)THEN
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,1.8,-459.67,0,IER)
C              THIS SCALES TEMPERATURE IN KELVIN TO F.
         ELSE
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,1.,0.,0,IER)
C              THIS JUST COPIES THE DATA FROM DATA( ) TO FD4( ).
         ENDIF
C
         NCHAR=32         
         XMISSP=0.
         XMISSS=0.
C           IT IS ASSUMED THERE ARE NO MISSING VALUES IN THE GRID.
         CALL PAWGTS(KFILDO,IP19,'IP19  ',KFILDO,NDATE,
     1               ID(1,N),ITAUH,ITAUM,MODNO,NSEQ,ISCALD(N),
     2               NPROJ,ALATL,ALONL,ORIENT,MESH,XLAT,NX,NY,
     3               FD4,IWORK,FD1,IPACK,ND5,MINPK,
     4               IS0,IS1,IS2,IS4,ND7,
     5               IPLAIN(1,1,N),PLAIN(N),NCHAR,
     6               XMISSP,XMISSS,LX,IOCTET,
     7               N19TBY,N19TRC,L3264B,L3264W,IER)
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,2096)
 2096       FORMAT(/' ****ERROR IN PAWGTS IN PRED26 AT 2096.',
     1              '  GRID NOT WRITTEN TO IP19.  CONTINUING.')
C              ERROR WRITING TO THIS DIAGNOSTIC GRID IS NOT CONSIDERED FATAL.
            GO TO 210
         ENDIF
C         
      ENDIF
C
C        WRITE THE GRIDDED DATA TO RANDOM ACCESS FILE 43, IF 
C        PROVIDED.
C
      DO 2099 JJ=1,6
C
      IF(KFILRA(JJ).EQ.43)THEN
         ISCALE=0
C
C            NOTE THAT ARRAY DATA( ) CONTAINS THE PACKED DATA.
C
         CALL PACKGR(KFILDO,KFILRA(JJ),RACESS(JJ),ID(1,N),IDPARS(1,N),
     1               ISCALD(N),ISCALE,NGRIDC(1,NSLAB),
     2               IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3               FD2,DATA,ND2X3,NX,NY,IPACK,IWORK,ND5,MINPK,
     4               IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5               NWORDS,NTOTBG,NTOTRG,
     6               L3264B,L3264W,ISTOP,IER)
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,2098)(ID(MMM,M),MMM=1,4),KFILRA(JJ),IER
 2098       FORMAT('     ERROR WRITING DATA FOR',
     1             1X,I9.9,2I10.9,I11.3,
     2             ' ON RANDOM ACCESS FILE UNIT NO.',I4,' IER =',I4,
     3             '.  PROCEEDING.')
         ENDIF
C     
         GO TO 2099
      ENDIF
C
 2099  CONTINUE
C      
C        GRIDPRINT FIELD IF DESIRED.
C
 210  IF(IP14.EQ.0)GO TO 215
      IF(JP(2,N).EQ.0)GO TO 215
C
C        GRIDPRINT WHEN DESIRED.
C
      CALL PREDX1(KFILDO,IDPARS(1,N),THRESH(N),
     1            SMULT(N),SADD(N),ORIGIN(N),CINT(N),
     2            PLAIN(N),UNITS(N),NDATE,-IDPARS(9,N),DATA,ND5,
     3            IS2,ND7,IP14,ISTOP(1),IER)
C        AN ERROR IN GRIDPRINTING IS TREATED AS AN ISTOP(1) ERROR.  
C        NORMALLY, GRIDPRINTING WOULD BE DONE ONLY IN CHECKOUT.
C        IER NE 0 IN PREDX1 DOES NOT CAUSE MISSING DATA.
C
C        PACK AND WRITE THE GRIDPOINT FIELD WHEN A UNIT NUMBER
C        KFILGO IS PROVIDED.  IT IS POSSIBLE SOME GRIDS WILL HAVE
C        PRIMARY MISSING VALUES (E.G., CEILING HEIGHT FOR LAMP).
C        (PACKG IS USED IN U202/PACK23)
C
 215  IF(KFILGO.NE.0)THEN
         XMISSP=9999.
         XMISSS=0.
         CALL PACKG(KFILDO,KFILGO,ID(1,N),IDPARS(1,N),
     1              ISCALD(N),0,NGRIDC(1,NSLAB),
     2              IPLAIN(1,1,N),NDATE,NYR,NMO,NDA,NHR,
     3              FD1,DATA,ND2X3,IS2(3),IS2(4),IPACK,IWORK,ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              NWORDS,LTOTBG,LTOTRG,
     6              L3264B,L3264W,ISTOP(1),IER)
C           NOTE THAT GRIDPOINT DATA TO PACK ARE IN DATA( ).
      ENDIF
C
C        INTERPOLATE TO STATIONS.
C
 220  CONTINUE
C        ABOVE CONTINUE ONLY FOR TRANSFER ABOVE 221
D     WRITE(KFILDO,221)(ID(J,N),J=1,4),IER
D221  FORMAT(/' AT 221 IN PRED26--(ID(J,N),J=1,4),IER',5I10)
C
D     WRITE(KFILDO,2211)NSIZE,NSLAB,(DATA(J),J=1,30)
D2211 FORMAT(/' AT 2211--NSIZE,NSLAB,(DATA(J),J=1,NSIZE)',2I10,/,
D    1      (10F10.3))
C
      IF(IDPARS(13,N).EQ.1)THEN
         CALL INTRPA(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPA IS BIQUADRATIC INTERPOLATION WHERE POSSIBLE,
C           BILINEAR OTHERWISE.
C
      ELSEIF(IDPARS(13,N).EQ.2)THEN
         CALL INTRPB(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPB IS BILINEAR.
C
      ELSEIF(IDPARS(13,N).EQ.3)THEN
C
         CALL INTRP(KFILDO,DATA,IWORK,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRP IS INTERPOLATION FOR PRECIPITATION AMOUNT.  THE
C           PROCESS IS BILINEAR AFTER PREPARATION OF THE FIELD 
C           TO PUT THE ZERO LINE ABOUT HALFWAY BETWEEN POSITIVE 
C           AND ZERO GRIDPOINTS.
C           IWORK( ) IS USED AS FLOATING POINT IN INTRP.  THAT IS OK.
C           IWORK( ) AND DATA( ) ARE BOTH DIMENSIONED ND5.
C
      ELSEIF(IDPARS(13,N).EQ.4)THEN
         CALL INTRPC(KFILDO,DATA,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPC IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT.
C
      ELSEIF(IDPARS(13,N).EQ.5)THEN
         NX=IS2(3)
         NY=IS2(4)
         CALL INTRPD(KFILDO,KFIL10,IP12,
     1               ID(1,N),IDPARS(1,N),JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,NELEV,
     4               ISDATA,SDATA,DIR,ND1,NSTA,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,ND5,
     7               LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               ND7,
     A               DATA,FD1,FD2,FD3,FD4,ND2X3,NX,NY,
     B               L3264B,L3264W,ISTOP(1),IER)
C           INTRPD IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT WITHIN THE 4-GRIDPOINT BOX WHERE THE STATION
C           IS LOCATED, BUT CONTINGENT ON A MASK INDICATING
C           A GRIDPOINT THAT CAN BE USED AND THE DIFFERENCE
C           BETWEEN THE ELEVATION OF THE GRIDPOINT AND THE
C           STATION BEING WITHIN BOUNDS (HARDWIRED IN INTRPD).
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
C              IER NE 0 FROM INTRPD IS TREATED AS AN ERROR, BUT
C              PROCESSING PROCEEDS.  IF THE GENERIC IDS WERE USED,
C              THE DATA ARE GOOD, BUT ISTOP(1) HAS BEEN INCREMENTED
C              IN INTRPD AND IER CAN = 0; IN OTHER CASES, THE DATA ARE
C              MISSING.  THE TRANSFORMATIONS BELOW HANDLE MISSING
C              VALUES.
            ISTOP(2)=ISTOP(2)+1
C              ANY IER NE 0 WILL MEAN MISSING DATA.  NOTE THAT THIS
C              IS THE ONLY "INTERPOLATION" ROUTINE THAT CAN ITSELF
C              CREATE AN ERROR OR MISSING DATA.
            IER=0
         ENDIF
C
      ELSEIF(IDPARS(1,N).GE.400.AND.IDPARS(1,N).LE.499)THEN
C            FOR THIS GRIDDED DATA FIELD, AN INTERPOLATION VALUE
C            OF 1, 2, 3, 4, OR 5 IS REQUIRED.  IT IS LIKELY THIS WILL
C            NOT BE REACHED FOR CCC = 409 TERRAIN DATA, AS THEY WILL
C            BE STORED INTERNALLY BY PRED21.  THEREFORE, MISSING DATA
C            WILL NOT BE REPORTED.
         WRITE(KFILDO,228)(JD(K,N),K=1,4)
 228     FORMAT(/' ****GRIDDED CONSTANT ',3I10.9,I11.3,' DOES NOT HAVE',
     1           ' A VALID INTERPOLATION VALUE IN IDPARS(13).'/
     2           '     THIS IS AN UNEXPECTED CONDITION.')
         ISTOP(1)=ISTOP(1)+1
         GO TO 300
      ELSE
         GO TO 300
C           WHEN THE INTERPOLATION VALUE IS NOT LEGITIMATE, CKIDS WILL
C           HAVE PRINTED A DIAGNOSTIC EXCEPT FOR THE CONSTANTS
C           TREATED IMMEDIATELY ABOVE.
      ENDIF
C
C        TRANSFORM VARIABLE WHEN DESIRED.  FROM HERE ON, DATA ARE
C        VECTOR.
C
      IF(IDPARS(1,N).GE.200.AND.IDPARS(1,N).LE.299)GO TO 350
      IF(IDPARS(1,N).GE.300.AND.IDPARS(1,N).LE.399)GO TO 350
      IF(IDPARS(1,N).GE.500.AND.IDPARS(1,N).LE.599)GO TO 350
      IF(IDPARS(1,N).GE.600.AND.IDPARS(1,N).LE.699)GO TO 350
C        IT IS ASSUMED THAT IF CCC = 2XX (MOS FORECASTS), 
C        3XX (COMBINATION OF MODELS), 5XX (1-D TRANSFORMATIONS)
C        AND 6XX (2-D TRANSFORMATIONS) SHOULD NOT HAVE BINARY
C        PROCESSING DONE.
C
      IF(IDPARS(8,N).NE.0.AND.IDPARS(8,N).LT.7)
C            IDPARS(8, ) DOES NOT APPLY TO VECTOR DATA FOR 7, 8, AND 9.)
     1    CALL TRANS(KFILDO,ID(1,N),IDPARS(8,N),SDATA,NSTA,FD1,ND2X3,
     2               IER)
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           WHEN IER NE 0, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
C           AN ERROR IN TRANS WILL HAVE CREATED A DIAGNOSTIC.
         GO TO 312
      ENDIF
C
C         MAKE POINT BINARY VARIABLE WHEN DESIRED.
C
      IF(IDPARS(3,N).EQ.1)
     1    CALL BINARY(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),SDATA,NSTA,
     2                IER)
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           WHEN IER NE 0, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
C           AN ERROR IN BINARY WILL HAVE CREATED A DIAGNOSTIC.
         GO TO 312
      ENDIF
C
C        CURRENTLY, THE ONLY LEGITIMATE VALUES OF IDPARS(3, ) ARE O, 1, 2,
C        AND 5 IN U201.  OTHER VALUES CAUSE VALUES TO BE SET TO MISSING.
C        THIS ACCOMMODATES THE CUMULATIVE FROM ABOVE POINT BINARIES THAT
C        CAN BE USED AS PREDICTORS AND GRID BINARIES, BUT NOT CUMULATIVE
C        FROM BELOW OR DISCRETE BINARIES THAT CAN BE USED AS PREDICTANDS.
C        HOWEVER, IT ALSO ACCOMMODATES B = 2 FOR RELATIVE FREQUENCIES
C        AND PERCENTS AS MIGHT COME FROM AN ENSEMBLE (E.G., THE SREF).
C        NORMALLY, BINARIES WILL NOT BE MADE BY U201 BECAUSE ALL USING
C        PROGRAMS OF U201 OUTPUT WILL HAVE BINARY CAPABILITY.
C
      IF(IDPARS(3,N).EQ.0.OR.
     1   IDPARS(3,N).EQ.1.OR.
     2   IDPARS(3,N).EQ.5)GO TO 350
C
C        THE DATA ARE MISSING OR HAVE A NON-LEGITIMATE BINARY
C        INDICATOR.  NOTE THAT CCC = 2XX, 3XX, 5XX, AND 6XX HAVE BEEN
C        EXEMPTED FROM BINARY PROCESSING.  SET ALL VALUES TO 9999
C        EXCEPT IDPARS(3,N) = 2 IS PERMITTED, THIS LATTER FOR 
C        RELATIVE FREQUENCIES FROM THE SREF MODEL.
C
      IF(IDPARS(3,N).EQ.2)THEN 
C
         IF(IFIRST.EQ.0)THEN
            WRITE(KFILDO,298)(ID(J,N),J=1,4)
 298        FORMAT(/' ****BINARY INDICATOR IDPARS(3, ) = 2 IN PRED26',
     1              ' MAY BE AN ERROR FOR VARIABLE ',3I10.9,I11.3,/,
     2              '     BINARY INDICATOR IGNORED.  THIS DIAGNOSTIC',
     3              ' WILL NOT PRINT AGAIN IN PRED26.') 
            ISTOP(1)=ISTOP(1)+1
            IFIRST=1
         ENDIF
C
         GO TO 350 
C         
      ENDIF
C  
      WRITE(KFILDO,299)(ID(J,N),J=1,4)
 299  FORMAT(/' ****BINARY INDICATOR IDPARS(3, ) NE 0, 1, 2,OR 5',
     1        ' IS AN ERROR FOR ',3I10.9,I11.3,
     2        '.  SET TO MISSING.') 
C
 300  DO 310 K=1,NSTA
      SDATA(K)=9999.
 310  CONTINUE
C
 312  ISTOP(2)=ISTOP(2)+1
      XMISSP=9999.
      XMISSS=0.
      GO TO 355
C
C        SET XMISSP AND XMISSS.  NOTE THAT ANY VALUES OF 9997
C        IN VECTOR DATA HAVE BEEN SET TO PXMISS.
C        9997 IS NOT EXPECTED OR DEALT WITH IN GRIDPOINT DATA.
C        OPTION SHOULD NOT RETURN 9997 UNLESS IT IS DESIRED
C        TO LEAVE THOSE VALUES IN THE OUTPUT.
C
 350  CALL SETMIS(KFILDO,SDATA,NSTA,XMISSP,XMISSS)
C
 355  CONTINUE
C
      IF(JP(3,N).NE.0)THEN
C        JP(3,N) CONTROLS WRITING OF VECTOR DATE TO BOTH
C        SEQUENTIAL AND EXTERNAL RANDOM ACCESS FILES. 
C        IN ADDITION, TO WRITE TO SEQUENTIAL, KFILVO HAS TO BE
C        NE 0 AND TO WRITE TO RA, 49 HAS TO BE ONE OF THE 
C        KFILRA( ) UNITS.
C
C        PACK AND WRITE THE DATA.
C
 360     CALL PACKV(KFILDO,KFILVO,ID(1,N),IDPARS(1,N),
     1              JP(1,N),ISCALD(N),0,
     2              IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3              CCALL,ISDATA,SDATA,ND1,NSTA,IPACK,ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              IP15,NWORDS,NTOTBV,NTOTRV,
     6              L3264B,L3264W,ISTOP(1),IER)
         IF(INDEX(N).NE.1)GO TO 393
C
         IF(KFILVO.EQ.0)THEN
            WRITE(KFILDO,390)(ID(I,N),I=1,4),NDATE
 390        FORMAT(/' ****VARIABLE ',I11.9,3I11,
     1              ' COMPUTED MORE THAN ONCE FOR DATE',I11)
         ELSE
            WRITE(KFILDO,391)(ID(I,N),I=1,4),NDATE
 391        FORMAT(/' ****VARIABLE ',I11.9,3I11,' COMPUTED AND',
     1              ' WRITTEN MORE THAN ONCE PROCESSING DATE',I11)
         ENDIF
C
         ISTOP(1)=ISTOP(1)+1
 393     INDEX(N)=1
C
C           WRITE TO EXTERNAL RA WHEN KFILRA( ) CONTAINS 49, THE
C           ONLY UNIT AVAILABLE FOR WRITING VECTOR DATA.
C
         DO 395 J=1,NUMRA
C
D        WRITE(KFILDO,394)NUMRA,J,KFILRA(J)
D394     FORMAT(/' AT 394--NUMRA,J,KFILRA(J)',3I10)
C
         IF(KFILRA(J).EQ.49)THEN
            NREPLA=2
C              REPLACE RECORD IF FOUND OR WRITE NEW RECORD.
            NCHECK=0
            CALL WRTDLR(KFILDO,KFILRA(J),RACESS(J),IS1(9),
     1                  ICALL,CCALL,ND1,NSTA,
     1                  ICALLD,CCALLD,ND5,IPACK,NWORDS,
     2                  NREPLA,NCHECK,L3264B,L3264W,IER) 
C              IS1(9) IS ESSENTIALLY ID(1,N).  FOR CCC = 400-499,
C              THE DD IS STRIPPED OFF IN PACKV.  THIS SHOULD NOT
C              MATTER HERE.
            IF(IER.NE.0)THEN
               ISTOP(1)=ISTOP(1)+1
C                 AN ERROR IN WRTDLR WILL PRINT A DIAGNOSTIC.
               GO TO 3955
            ELSE
C                 THE CALCULATION OF BYTES IS THE SAME AS IN PACKV
C                 WHEN THE DATA ARE ACTUALLY WRITTEN.  THIS REPRESENTS
C                 THE BYTES OF DATA AND DOES NOT INCLUDE THE WORD
C                 (FOR L3264B = 32) WRITTEN PRECEEDING THE DATA.
C                 
               IF(L3264B.EQ.32)THEN
                  LTOTBV=LTOTBV+NWORDS*4
               ELSE
                  LTOTBV=LTOTBV+NWORDS*8
               ENDIF
C
               LTOTRV=LTOTRV+1
            ENDIF
C
            GO TO 3955
         ENDIF
C
 395     CONTINUE
C
      ENDIF
C 
 3955 N=N+1
      IF(N.GT.NPRED)GO TO 110
      IF(ISTAV(N).EQ.1)GO TO 110
      IF(INDEX(N).EQ.1)GO TO 110
      GO TO 119
C
 396  WRITE(KFILDO,397)IER,NDATE
 397  FORMAT(/' ****ERROR IN UNPKBG IN PRED26.  IER =',I4,
     1        ', PROCESSING DATE',I11)
      ISTOP(1)=ISTOP(1)+1
C        UNPKBG DOES NOT CREATE A DIAGNOSTIC.
      GO TO 110
C
 400  CONTINUE
C
C        VARIABLES HAVE BEEN USED FOR CURRENT DATE THAT DO NOT
C        REQUIRE BEING STORED WITH KEYS IN LSTORE( , ). 
C        OUTPUT DIAGNOSTIC IF NO DATA AVAILABLE ON A PARTICULAR
C        INPUT FILE.
C 
      DO 4015 J=1,NUMIN
C
      IF(JFOPEN(J).NE.1)GO TO 4015
C
      IF(LKHERE(J).NE.0.AND.
     1   MSDATE(J).EQ.0)THEN
C
         IF(IP23.NE.0.AND.IP23.NE.KFILDO)THEN
            WRITE(IP23,401)KFILIN(J),NDATE,NAMIN(J)
 401        FORMAT(/' ****NO DATA AVAILABLE FOR FILE ON UNIT NO.',I4,
     1              ' PROCESSING DATE',I11/
     2              '     FILE = ',A60)
C              NOTE THAT THIS OUTPUT IS PROVIDED ONLY WHEN AN END OF
C              FILE HAS NOT BEEN REACHED.
            NODATA=NODATA+1
         ENDIF
C
         IF(NODATA.LT.2)THEN
            WRITE(KFILDO,401)KFILIN(J),NDATE,NAMIN(J)
         ELSEIF(NODATA.EQ.3)THEN
            WRITE(KFILDO,401)KFILIN(J),NDATE,NAMIN(J)
            WRITE(KFILDO,4010)
 4010       FORMAT('     THIS DIAGNOSTIC WILL NOT BE WRITTEN AGAIN.')
         ENDIF            
C
      ENDIF
C
 4015 CONTINUE
C
C        OUTPUT DIAGNOSTIC IF ALL DATA HAVE BEEN EXHAUSTED.
C 
      DO 402 J=1,NUMIN
C***D     WRITE(KFILDO,4019)LITEMS,NUMIN,J,JFOPEN(J),MSDATE(J),LKHERE(J)
C***D4019 FORMAT(' PRED26 AT 4019--LITEMS,NUMIN,J,JFOPEN,MSDATE,LKHERE ',
C***D    1         6I4)
      IF(LITEMS.NE.0.OR.
     1   MSDATE(J).NE.0.OR.
     2   LKHERE(J).NE.0)GO TO 405
 402  CONTINUE
C
      WRITE(KFILDO,403)NDATE
 403  FORMAT(/' ****ALL INPUT DATA EXHAUSTED LOOKING FOR DATE',I11,'.')
      IER=127
      ISTOP(1)=ISTOP(1)+1
      GO TO 800
C
C        NOW COMPUTE THE VARIABLES THROUGH THE OPTION SUBROUTINE.
C
 405  LD(1)=0
C        ABOVE STATEMENT NECESSARY BECAUSE A FIELD COULD HAVE BEEN
C        LEFT OVER FROM A PREVIOUS DATE.
C
      DO 700 N=1,NPRED
C
D     WRITE(KFILDO,406)N,ISTOP(1),ISTOP(2)
D406  FORMAT(/' AT 406 IN PRED26--N,ISTOP(1),ISTOP(2)',3I5)
C
      IF(INDEX(N).EQ.1)GO TO 700
C        WHEN INDEX( ) = 1, THIS VARIABLE HAS ALREADY BEEN SECURED.
      IF(IDPARS(1,N).EQ.799)GO TO 700
C        CCC = 799 IS A DUMMY THAT HAS NO PURPOSE IN PRED26 EXCEPT
C        IN DETERMINING LDATB( ) AND LDATE( ).
C
      IF(ISTAV(N).EQ.1.AND.ITIME(N).EQ.1)GO TO 427
C        VECTOR DATA FOR THE CURRENT DATE HAVE BEEN ACCESSED.
C        THE TRANSFER TO 427 WILL TAKE CARE OF POSSIBLE PAST
C        CASES.  OTHERWISE, THIS VECTOR MUST COME FROM OPTION.
C
C***D     WRITE(KFILDO,408)N,(JD(I,N),I=1,4),IFIND(N),ISTAV(N)
C***D408  FORMAT(' AT 408 IN PRED26--N,(JD(I,N),I=1,4),IFIND(N),ISTAV(N)',
C***D    1       I6,I11.9,3I11,2I6)
C
      IF(ISTAV(N).NE.0)THEN
C           THIS VARIABLE MAY BE A VECTOR; IT IS NEVER SAVED.
C           NOTE THAT ISTAV( ) MAY BE 2 AFTER DAY 1, AND LATER
C           BE CHANGED.
         GO TO 425
      ENDIF
C
C        A DROP THROUGH HERE WHEN IT IS EXPECTED THE VARIABLE
C        IS GRIDPOINT AND MAY BE AVAILABLE DIRECTLY FROM INPUT.
C        A VECTOR IS NOT SAVED IN FDA( ).
C
      IF(N.EQ.1)GO TO 425
C
C        THIS VARIABLE CAN BE REUSED FROM THE PREVIOUS ONE ONLY IF:
C           (1) IT IS A GRID AND ONLY THE POINT COMPUTATIONS
C               ARE NECESSARY (E.G., INTERPOLATION).
C        IF GRID PROCESSING (E.G., SMOOTHING) IS NEEDED ON A 
C        BASIC GRID, IT MAY BE SAVED IN FDA( ).
C
C***D     WRITE(KFILDO,410)N,JD(1,N-1),JD(2,N-1),JD(3,N-1),
C***D    1                 IDPARS(13,N-1),IDPARS(14,N-1),IDPARS(15,N-1),
C***D    2                 JD(1,N),JD(2,N),JD(3,N),  
C***D    3                 IDPARS(3,N),
C***D    4                 IDPARS(13,N),IDPARS(14,N),IDPARS(15,N) 
C***D410  FORMAT(' PRED26 AT 410',I4,3I10,6X,3I6/
C***D    1       '              '4X,3I10,  4I6)
      IF(JD(1,N).EQ.JD(1,N-1).AND.
     1   JD(2,N).EQ.JD(2,N-1).AND.
     2   JD(3,N).EQ.JD(3,N-1).AND.
     3   IDPARS(3,N).NE.5.AND.
     4   IDPARS(3,N-1).NE.5.AND.
CCC     5   IDPARS(13,N).EQ.IDPARS(13,N-1).AND.
CCC  OMITTED 2/16/09
     6   IDPARS(14,N).EQ.IDPARS(14,N-1).AND.
     7   IDPARS(15,N).EQ.IDPARS(15,N-1).AND.
     8   ((IDPARS(8,N).EQ.IDPARS(8,N-1)).OR.(IDPARS(8,N).LT.7.AND.
     9                                       IDPARS(8,N-1).LT.7)).AND.
     A   IDPARS(3,N).NE.2.AND.
C           ABOVE ADDED 9/20/09 FOR RF FROM SREF
     B   NGOMIS.EQ.0)THEN
C           THE CHECK ON IDPARS(3,N-1) IS NOT NECESSARY WHEN
C           THE VARIABLES ARE ORDERED, AS THEY SHOULD BE
C           UNLESS SORTEM IS TAKEN OUT OF RDPRED.  NGOMIS
C           IS 1 WHEN THE PREVIOUS VARIABLE WAS MISSING.
C           THE CHECKS ON IDPARS(8, ) PUT IN WHEN THE VALUES
C           OF 7, 8, AND 9 WERE ADDED FOR VARIANCE (GRIDDED)
C           COMPUTATIONS.  NOTE THAT V MUST BE THE SAME FOR N AND N-1
C           UNLESS BOTH ARE LT 7.
C
D        WRITE(KFILDO,4105)N,(ID(K,N),K=1,4)
D4105    FORMAT(' REUSING GRID FOR VECTOR COMPUTATIONS AT 4105',
D    1          ' IN PRED26 FOR VARIABLE NO.',I3,I12.9,3I11)
         GO TO 520    
C           THE GRID IN DATA( ) CAN BE REUSED AT 520 FOR MAKING
C           BINARIES, AND FOR TRANSFORMATION WHEN EITHER T LT 7
C           OR T IS THE SAME FOR THIS VARIABLE AND 
C
      ENDIF
C
C        IS THIS GRID STORED IN FDA( ) REUSABLE?  NOTE THAT
C        THESE DATA ARE USED FOR MAKING A GRID BINARY AND/OR
C        SMOOTHING.
C
      IF(JD(1,N).NE.LD(1).OR.
     1   JD(2,N).NE.LD(2).OR.
     2   JD(3,N).NE.LD(3).OR.
     3   IDPARS(3,N).EQ.2.OR.
C           ABOVE ADDED 9/20/09 FOR RF FROM SREF
     4   LPARS.NE.IDPARS(15,N).OR.
     5   IDPARS(8,N))GO TO 425
C
C        TAKE DATA FROM FDA( ).  DATA CAN BE USED FROM FDA( )
C        WHEN THE GRID (FROM GSTORE OR OPTION) IS THE SAME,
C        BUT MAKING A GRID BINARY AND SMOOTHING CAN BE DIFFERENT,
C        AS WELL AS THE POINT CALCULATIONS OF MAKING A POINT
C        BINARY, TRANSFORMATION, AND INTERPOLATION.  THE CHECK ON
C        IDPARS(8, ) PUT IN WHEN THE VALUES OF 7, 8, AND 9 WERE
C        ADDED FOR VARIANCE (GRIDDED) COMPUTATIONS.
C
D     WRITE(KFILDO,419)N,(ID(K,N),K=1,4)
D419  FORMAT(' REUSING GRID FROM FDA( ) AT 419 IN PRED26',
D    1       ' FOR VARIABLE NO.',I3,I12.9,3I11)
C
      DO 420  K=1,NSIZE
      DATA(K)=FDA(K)
 420  CONTINUE
C
      GO TO 505
C
C        MUST EITHER FIND A VARIABLE IN LSTORE( , ) OR COMPUTE IT IN
C        OPTION.  ALL VARIABLES NOT TO BE COMPUTED IN OPTION OF THE
C        CURRENT DATE/TIME HAVE BEEN DEALT WITH.  BASIC LAGGED 
C        VARIABLES CAN BE GOTTEN DIRECTLY BY GFETCH.
C
 425  IF(IFIND(N).NE.1)GO TO 432
C        WHEN IFIND(N) = 0, THIS VARIABLE MUST BE COMPUTED IN OPTION;
C        WHEN IFIND(N) = 2, IT MAY NEED TO BE COMPUTED IN OPTION;
C        IFIND( ) IS INITIALLY SET IN PRED21 AND CAN BE MODIFIED
C        IN PRED26.  THIS IS DONE FOR EFFICIENCY ONLY.
C      
      IF(IDPARS(9,N).EQ.0)THEN
C           LAG OF 0 HAS BEEN DEALT WITH ABOVE, UNLESS IT IS COMPUTED IN
C           OPTION.  THIS KEEPS CONTROL OUT OF GFETCH.
         WRITE(KFILDO,426)(JD(K,N),K=1,4),NDATE
 426     FORMAT(/' ****VARIABLE ',I11.9,3I11,
     1           ' NOT FOUND ON INPUT FILE(S) FOR DATE',I11)
         ISTOP(1)=ISTOP(1)+1
         GO TO 600
      ENDIF
C
 427  IF(IFIND(N).EQ.0)GO TO 432
C        IF IFIND( ) = 0, THE VARIABLE IS KNOWN TO COME FROM OPTION.
C
      IF(ISTAV(N).NE.1)THEN
C        IF ISTAV( ) = 0, THE VARIABLE IS VECTOR.
C        IF ISTAV( ) = 2, THE TYPE IS UNKNOWN AT THIS TIME.
C
C           THIS IS FOR GRIDPOINT DATA.
C
CCCC         CALL GFETCH(KFILDO,KFIL10,JD(1,N),N,LSTORE,ND9,LITEMS,
CCCC     1               IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,DATA,ND5,NSIZE,
CCCC     2               NPACK,NDATE,NTIMES,CORE,ND10,
CCCC     3               NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,ITIME(N),
CCCC     4               IER)
         CALL PRSID1(KFILDO,JD(1,N),JDPARS)
         CALL GTVEGR(KFILDO,KFIL10,IP12,
     1               JD(1,N),JDPARS,JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,
     4               ISDATA,SDATA,DIR,ND1,NSTA,NSIZE,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,DATA,ND5,
     7               LSTORE,ND9,LITEMS,N,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               IS0,IS1,IS2,IS4,ND7,
     A               ISTAV(N),L3264B,L3264W,IER)
C           DATA ARE RETURNED IN DATA(ND5), NSIZE VALUES.  HOWEVER,
C           IF IER NE 0, NSIZE MAY BE ZERO.
         LD(1)=0
C           ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C           FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN GFETCH.
         IF(MISSP.NE.0)MISTOT=MISTOT+1
C***D        WRITE(KFILDO,428)(JD(J,N),J=1,4),IER,NSLAB,(DATA(K),K=1,7)
C***D428     FORMAT(' OUT OF GFETCH--JD,IER,NSLAB,DATA(K),K=1,7)'
C***D    1           I11.9,3I11,2I4,7F10.2)
C
         IF(IER.EQ.0)THEN
C
            IF(NSLAB.EQ.0)THEN
C                 DATA ARE VECTOR.  THIS IS ALREADY KNOWN UNLESS
C                 DATA WERE MISSING UP TO THIS POINT.  NORMALLY,
C                 THIS ENTRY TO GFETCH WOULD NOT OCCUR, BECAUSE
C                 ISTAV(N) WOULD BE 0 AND THE DATA WOULD BE GRIDPOINT.
               ISTAV(N)=1
C   
               DO 4285 K=1,NSTA
               SDATA(K)=DATA(K)
 4285          CONTINUE
C
               GO TO 650
            ELSE
C                 DATA ARE NOT VECTOR.  THIS IS ALREADY KNOWN UNLESS
C                 DATA WERE MISSING UP TO THIS POINT.       
               ISTAV(N)=0
               GO TO 435
            ENDIF
C
         ELSEIF(IER.EQ.47)THEN
C
            IF(IFIND(N).EQ.2)THEN
               GO TO 4287
            ELSE
               WRITE(KFILDO,426)(JD(K,N),K=1,4),NDATE
               GO TO 600
            ENDIF
C
         ELSE
            ISTOP(1)=ISTOP(1)+1
C              AN ERROR IN GFETCH WILL HAVE CREATED A DIAGNOSTIC EXCEPT,
C              POSSIBLY, FOR IER = 47.  IER = 47 MEANS THE DATA 
C              COULDN'T BE FOUND.  OTHER RETURNS ARE PROBABLY FATAL.
C              NOTE THAT CONTROL IS NOT HERE IF IT IS EXPECTED THAT
C              OPTION IS NEEDED.
            GO TO 600
         ENDIF
C       
      ENDIF
C
 4287 IF(ISTAV(N).NE.0)THEN
C        IF ISTAV( ) = 1, THE VARIABLE IS VECTOR.
C        IF ISTAV( ) = 2, THE TYPE IS UNKNOWN AT THIS TIME.
C
C           THIS IS FOR VECTOR DATA.
C
CCC         CALL GFETCH(KFILDO,KFIL10,ID(1,N),N,LSTORE,ND9,LITEMS,
CCC     1               IS0,IS1,IS2,IS4,ND7,IPACK,IWORK,SDATA,ND1,
CCC     2               NSIZE,NPACK,NDATE,NTIMES,CORE,ND10,
CCC     3               NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,ITIME(N),
CCC     4               IER)
         CALL GTVEGR(KFILDO,KFIL10,IP12,
     1               ID(1,N),IDPARS(1,N),JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,
     4               ISDATA,SDATA,DIR,ND1,NSTA,NSIZE,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,DATA,ND5,
     7               LSTORE,ND9,LITEMS,N,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               IS0,IS1,IS2,IS4,ND7,
     A               ISTAV(N),L3264B,L3264W,IER)
         LD(1)=0
C           ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C           FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN GFETCH.
C           DATA ARE RETURNED IN SDATA(ND1), NSTA VALUES.
C
C***D        WRITE(KFILDO,429)(ID(J,N),J=1,4),IER,(SDATA(K),K=1,7)
C***D429     FORMAT(' OUT OF GFETCH--ID,IER,SDATA(K),K=1,7)',
C***D               I11.9,3I11,I4,7F10.2)
         IF(IER.EQ.0)THEN
C
            IF(NSLAB.EQ.0)THEN
C                 DATA ARE VECTOR.  THIS IS ALREADY KNOWN UNLESS
C                 DATA WERE MISSING UP TO THIS POINT.
               ISTAV(N)=1
               GO TO 650
            ELSE
C                 DATA ARE NOT VECTOR.  THIS IS ALREADY KNOWN UNLESS
C                 DATA WERE MISSING UP TO THIS POINT.  NORMALLY,
C                 THIS ENTRY TO GFETCH WOULD NOT OCCUR, BECAUSE
C                 ISTAV(N) WOULD BE 1 AND THE DATA WOULD BE VECTOR.
C                 IF THIS WERE TO OCCUR, LIKELY ND1 WOULD BE SMALLER
C                 THAN THE GRID, AND GFETCH WOULD NOT RETURN IER = 0.
C                 IF THIS DID HAPPEN AND WORK CORRECTLY, NSIZE WORDS
C                 WILL BE IN SDATA( ).
               ISTAV(N)=0
C   
               DO 4295 K=1,NSIZE
               DATA(K)=SDATA(K)
 4295          CONTINUE       
C
               GO TO 435
            ENDIF
C
         ELSEIF(IER.EQ.47)THEN
C
            IF(IFIND(N).EQ.2)THEN
               GO TO 432
            ELSE
               WRITE(KFILDO,426)(JD(K,N),K=1,4),NDATE
               GO TO 600
            ENDIF
C
         ELSE
            ISTOP(1)=ISTOP(1)+1
C              AN ERROR IN GFETCH WILL HAVE CREATED A DIAGNOSTIC EXCEPT,
C              POSSIBLY, FOR IER = 47.  IER = 47 MEANS THE DATA 
C              COULDN'T BE FOUND.  OTHER RETURNS ARE PROBABLY FATAL.
C              NOTE THAT CONTROL IS NOT HERE IF IT IS EXPECTED THAT
C              OPTION IS NEEDED.
            GO TO 600
         ENDIF
C
      ENDIF
C
      IF(IFIND(N).EQ.1)GO TO 600
C
C         MUST COMPUTE THIS VARIABLE UNLESS IT IS A TERRAIN
C         CONSTANT.  IN THAT CASE, PRED21 WILL HAVE STORED IT
C         IN INTERNAL STORAGE.  THE EXACT ID MUST BE FOUND,
C         WHICH ALLOWS FOR DIFFERENT SMOOTHINGS, ETC.  A "CONSTANT"
C         RATHER THAN A FORECAST FROM LAMP (DD = 5) WILL HAVE DD = 0.
C
 432  IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)THEN
         KSDATE=0
C           DATE/TIME ON CONSTANT RECORD = 0.
CCCC         MSTIME=0
C           TIME ADJUSTMENT NOT TO BE MADE.
CCCC         CALL GFETCH(KFILDO,KFIL10,ID(1,N),7777,LSTORE,ND9,LITEMS,
CCCC     1               IS0,IS1,IS2,IS4,ND7,IPACK,ISDATA,SDATA,ND1,
CCCC     2               NWORDS,NPACK,KSDATE,NTIMES,CORE,ND10,
CCCC     3               NBLOCK,NFETCH,NSLAB,MISSP,MISSS,L3264B,MSTIME,IER)
         CALL GTVEGR(KFILDO,KFIL10,IP12,
     1               ID(1,N),IDPARS(1,N),JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,
     4               ISDATA,SDATA,DIR,ND1,NSTA,NSIZE,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,DATA,ND5,
     7               LSTORE,ND9,LITEMS,7777,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               IS0,IS1,IS2,IS4,ND7,
     A               ISTAV(N),L3264B,L3264W,IER)
C           FOR UNPACKED DATA, WORK ARRAYS ARE NOT USED.  IF CONSTANT
C           DATA ARE AVAILABLE, THEY WILL BE EXACTLY AS NEEDED; NO
C           FURTHER PROCESSING IS TO BE DONE.  THE RETURNED VALUES
C           NTIMES, MISS, AND NWORDS ARE NOT NEEDED OR USED.  IT IS
C           ASSUMED NWORDS = NSTA, SINCE THIS PROGRAM STORED THE DATA.
C           THE DATE OF SUCH RECORDS IS 0.  NOTE THAT THE DIMENSION 
C           ND1 IS FURNISHED RATHER THAN ND5.
         IF(MISSP.NE.0)MISTOT=MISTOT+1
C
C           IT IS NOW ESTABLISHED THAT THIS VARIABLE IS A VECTOR
C           AND IS IN INTERNAL STORAGE; SET IFIND( ) AND ISTAV( ) TO
C           SO INDICATE.  THIS WON'T REALLY MAKE ANY DIFFERENCE
C           IN THE RETRIEVAL, BUT WILL LET THE USER KNOW IF THE
C           PRINT IS EXERCISED IN U201.
C
         IF(IER.EQ.0)GO TO 650
C           GOOD RETURN MEANS DATA ARE READY FOR PACKING AND WRITING.
C
      ENDIF
C
      CALL OPTION(KFILDO,KFIL10,NFIRST,
     1            ID(1,N),IDPARS(1,N),THRESH(N),JD(1,N),NDATE,
     2            KFILRA,RACESS,NUMRA,
     3            ICALL,CCALL,ICALLD,CCALLD,NAME,
     4            NELEV,STALAT,STALON,
     5            ITIMEZ,ISDATA,SDATA,SDATA1,L1DATA,DIR,ND1,NSTA,
     6            NGRIDC,NGRID,ND11,NSLAB,IPACK,IWORK,DATA,ND5,
     7            LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     8            NBLOCK,LASTD,NSTORE,NFETCH,
     9            IS0,IS1,IS2,IS4,ND7,
     A            FD1,FD2,FD3,FD4,FD5,FD6,FD7,
     B            FDVERT,FDTIME,FDSINS,FDMS,ND2X3,
     C            KFILAC,IP12,IP16,IP20,IP21,
     D            ISTAVX,L3264B,L3264W,MISTOT,
     E            THRPHS,THRQPF,THRTRW,THRSVR,
     F            IPHSBC,PHSTMP,NSVRLOC,NX,NY,IER)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN OPTION.
C
D     WRITE(KFILDO,4320)N,(ID(L,N),L=1,4),ISTAV(N),IER
D4320 FORMAT(' OUT OF OPTION IN PRED26--N,ID( ,N),ISTAV(N),IER',
D    1        I6,I11.9,3I11,3I6)
C
C        DEFINE NSIZE.  IF THE DATA ARE GRIDPOINT AND IER NE 0,
C        IS2( ) IS NOT DEFINED, SO MAKE NSIZE = ND2X3 IN CASE
C        ND2X3 IS USED (E.G., FOR SAVING A GRID).
C       
      IF(ISTAV(N).EQ.1)THEN
C           DATA ARE VECTOR.
         NSIZE=NSTA
      ELSE
C           DATA ARE GRIDPOINT.
C
         IF(IER.EQ.0)THEN
            NSIZE=IS2(3)*IS2(4)
         ELSE
            NSIZE=ND2X3
         ENDIF
C
      ENDIF
C
C        AS A SPECIAL FEATURE, IER = -1 FROM A SUBROUTINE CALLED
C        BY OPTION MEANS THAT THE DATA ARE NOT TO BE WRITTEN.
C        THIS CAN BE USED WHEN NOT ALL HOURS BEING PROCESSED
C        HAVE DATA FOR THAT HOUR (E.G., MAX/MIN TEMPERATURE).
C        ALSO, WHEN THE VARIABLE ID CANNOT BE LOCATED IN OPTION,
C        IER IS RETURNED AS -2.  THIS FACILITATES THE USE OF THE
C        LOOKBACK FEATURE IN PRED21 WHEN NOT ALL DATA ARE AVAILABLE 
C        FOR DAY 1.
C 
      IF(IER.EQ.0)THEN
         IFIND(N)=0
         GO TO 4325
C
      ELSEIF(IER.EQ.47)THEN
C           MISSING DATA IS NOT COUNTED AS AN ERROR, BUT IS
C           COUNTED LATER AS MISSING DATA.  IFIND( ) IS NOT
C           CHANGED.  IT MAY STILL NOT BE KNOWN WHERE THE
C           VARIABLE IS TO COME FROM.
         GO TO 600
C
      ELSEIF(IER.EQ.-1)THEN
C           DON'T WRITE THIS VARIABLE TO THE ARCHIVE FILE.
C           TREAT IER = 0 ONWARD.
         IFIND(N)=0
         IER=0
C
C            WHEN CCC = 000, WRITE THIS VARIABLE TO THE INTERNAL
C            STORAGE.
C
         IF(IDPARS(1,N).EQ.000)THEN
            NCOMBO=1
C              NCOMBO HAS NO MEANING FOR VECTOR DATA.
            NPACK=1
C              THE DATA ARE NOT PACKED.
            MSDATE=0
C              THE DATE TO STORE IS ZERO.
            NR=0
C              IT IS ASSUMED THIS FIELD NEED NOT BE SAVED PAST
C              ITS DATE.
            CALL GSTORE(KFILDO,KFIL10,ID(1,N),NCOMBO,LSTORE,ND9,LITEMS,
     1                  DATA,NSTA,NPACK,NR,NDATE,
     2                  CORE,ND10,LASTL,NBLOCK,LASTD,
     3                  NSTORE,L3264B,IER) 
C              IER IS NOT CHECKED.  IF DATA AREN'T STORED CORRECTLY,
C              THEY WON'T BE READ.
         ENDIF
         INDEX(N)=1
C
         GO TO 700
C
      ELSEIF(IER.EQ.120)THEN
C           IER = 120 IS FROM FINDST IN CONST AND MEANS ONE
C           OR MORE STATIONS COULD NOT BE FOUND.  THIS IS
C           NOT FATAL, BUT IS TREATED AS AN ERROR.
         IFIND(N)=0
         ISTOP(1)=ISTOP(1)+1
         GO TO 4325
C
      ELSEIF(IER.EQ.-2)THEN
C           THIS SHOULD NOT HAPPEN.
         IFIND(N)=1
         ISTOP(1)=ISTOP(1)+1
         GO TO 600
      ELSE
         ISTOP(1)=ISTOP(1)+1
      ENDIF
C      
 4325 IF(ISTAVX.NE.ISTAV(N))THEN
         ISTOP(1)=ISTOP(1)+1
         WRITE(KFILDO,433)(ID(J,N),J=1,4),NDATE
 433     FORMAT(/' ****ISTAV RETURNED FROM OPTION IN PRED26 DOES',
     1           ' NOT AGREE WITH WHAT WAS EXPECTED FOR VARIABLE'/
     2           '     ',I9.9,3I11,' PROCESSING DATE',I11)
         GO TO 600
      ENDIF
C
      IF(ISTAV(N).EQ.1)GO TO 530
C        VECTOR DATA ARE NOT SAVED IN FDA( ).  TRANSFORMATION
C        AND BINARY OPERATORS ARE USED FOR VECTOR DATA FROM
C        OPTION (BUT NOT FOR VECTOR DATA NOT FROM OPTION). 
C
C        SAVE GRID FOR POSSIBLE REUSE.  IT IS POSSIBLE IT WON'T BE 
C        NEEDED FOR THE NEXT VARIABLE (E.G., POINT BINARY) BUT
C        WILL BE NEEDED FOR THE NEXT (E.G., GRID BINARY).  OR IT
C        MAY NOT BE NEEDED AT ALL, BUT THIS CONTINGENCY KEEPS
C        GRIDS FROM BEING STORED BY GSTORE UNNECESSARILY.
C
 435  IF(N.EQ.NPRED)GO TO 504
C        THE LAST VARIABLE IN THE LIST NEED NOT BE SAVED.
      IF(NSIZE.GT.ND2X3)GO TO 504
C        NSIZE CAN BE GREATER THAN ND2X3, BECAUSE ND5 CAN EXCEED
C        ND2X3.  THIS IS TO HANDLE LARGE CONSTANT GRIDS, SUCH
C        AS FINE SCALE TERRAIN.
C
      IF(JD(1,N).NE.JD(1,N+1).OR.
     1   JD(2,N).NE.JD(2,N+1).OR.
     2   JD(3,N).NE.JD(3,N+1).OR.
     3   IDPARS(3,N).EQ.2.OR.
C           ABOVE ADDED 9/20/09 FOR RF FROM SREF
     4   IDPARS(15,N).NE.IDPARS(15,N+1))GO TO 504
C        THE IDPARS(15, ) CHECK IS A SAFETY.  AT PRESENT, IDPARS(15, )
C        IS NOT USED.     
C
      IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)GO TO 504
C        TERRAIN HEIGHT IS NOT SAVED WHEN DD = 0 (DD = 5 FOR LAMP
C        FORECASTS).
C
      LD(1)=JD(1,N)
      LD(2)=JD(2,N)
      LD(3)=JD(3,N)
      IF(IDPARS(8,N).GE.7)LD(3)=ID(3,N)
C        WHEN THIS IS A VARIANCE CALCULATION (ON THE GRID), THE
C        IDPARS(8,N) = T IS SAVED.
      LPARS=IDPARS(15,N)
C
C        THE DATA SAVED ARE DIRECTLY OUT OF OPTION AND HAVE
C        NOT HAD SMOOTHING APPLIED.  OF COURSE, THE VECTOR
C        CALCULATIONS V AND I HAVE NOT BEEN APPLIED.  HOWEVER,
C        THE V FOR GRIDDED (V GE 7) HAS BEEN APPLIED.
C
D     IF(IDPARS(8,N).LT.7)THEN
D        WRITE(KFILDO,439)N,(JD(K,N),K=1,4)
D439     FORMAT(/' SAVING GRID NO.',I3,' IN FDA( ) AT 439',
D    1           ' IN PRED26    ',I11.9,3I11)
D     ELSE
D        WRITE(KFILDO,439)N,(JD(K,N),K=1,2),ID(3,N),JD(4,N)
D4390    FORMAT(/' SAVING GRID NO.',I3,' IN FDA( ) AT 4390',
D    1           ' IN PRED26    ',I11.9,3I11)
D     ENDIF
C
      DO 440 K=1,NSIZE
      FDA(K)=DATA(K)
 440  CONTINUE
C
      MISDAT=0
C
C        AT THIS POINT, THE VARIABLE HAS BEEN FOUND OR COMPUTED AND
C        EXISTS IN DATA( ).  THE FULL IDENTIFICATION IS IN IS1( ),
C        IS2( ), AND IS4( ).  IF IT MAY BE NEEDED FOR THE NEXT
C        VARIABLE AND IS A GRID, THE DATA ARE ALSO IN FDA( ).
C        IF IER NE 0, THE DATA MAY BE MISSING OR INCORRECT, BUT
C        THIS MAY SAVE ANOTHER TRIP TO OPTION.  NOTE THE CHECK
C        OR IER BELOW.
C
 504  IF(IER.NE.0)GO TO 600
C        IT IS POSSIBLE THIS POINT COULD BE REACHED WITH MISSING
C        GRIDPOINT VALUES; HENCE, THE CHECK FOR IER = 0 FOR SAFETY.
C
C        MAKE GRID BINARY IF DESIRED.
C
 505  IF(IDPARS(3,N).EQ.5)THEN
         CALL GRIDB(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),
     1              DATA,IWORK,IS2(3),IS2(4),IER)
C           IWORK( ) IS USED AS FLOATING POINT IN GRIDB.  THAT IS OK.
C           IWORK( ) AND DATA( ) ARE BOTH DIMENSIONED ND5.
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
            GO TO 600
C              AN ERROR IN GRIDB WILL HAVE CREATED A DIAGNOSTIC AND DATA
C              ARE RETURNED AS MISSING.
         ENDIF
C
      ENDIF
C
C        SMOOTH FIELD IF DESIRED.
C
      IF(IDPARS(14,N).NE.0)THEN
C
         IF(IDPARS(14,N).EQ.1)THEN
            CALL SMTH5 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.2)THEN
            CALL SMTH9 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.3)THEN
            CALL SMTH25(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.4)THEN
            CALL SMTH2X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.5)THEN
            CALL SMTH3X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
C              IWORK( ) IS USED AS FLOATING POINT IN 
C              SMOOTHING ROUTINES.  THAT IS OK.  IWORK( ) AND 
C              DATA( ) ARE BOTH DIMENSIONED ND5.
         ENDIF
C
      ENDIF
C
C        PRINT GRIDPOINT VALUES IF DESIRED.  TRY TO MATCH PRECISION
C        OF PRINTING TO SIZE OF VALUES THROUGH ISCALD( ).  WHILE
C        THE LOOP IS INEFFICIENT, IT WILL BE EXECUTED VERY RARELY.
C
      IF(IP13.EQ.0)GO TO 5092
      IF(JP(1,N).EQ.0)GO TO 5092
      WRITE(IP13,207)(ID(J,N),J=1,4),NDATE
C
      DO 509 JY=1,IS2(4)
C
      IF(ISCALD(N).LE.-1)THEN
         WRITE(IP13,208)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
      ELSEIF(ISCALD(N).EQ.0)THEN
         WRITE(IP13,2080)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
      ELSEIF(ISCALD(N).EQ.1)THEN
         WRITE(IP13,2081)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
      ELSEIF(ISCALD(N).EQ.2)THEN
         WRITE(IP13,2082)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
      ELSE
         WRITE(IP13,2083)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
      ENDIF
C
 509  CONTINUE
C
 5092 IF(IP19.NE.0)THEN
         ITAUH=IDPARS(12,N)
         ITAUM=0
         MODNO=IDPARS(4,N) 
         NSEQ=0     
         NPROJ=NGRIDC(1,NSLAB) 
         XMESHL=NGRIDC(2,NSLAB)/1000000. 
         XLAT=NGRIDC(3,NSLAB)/10000.
         ORIENT=NGRIDC(4,NSLAB)/10000.
         ALATL=NGRIDC(5,NSLAB)/10000.
         ALONL=NGRIDC(6,NSLAB)/10000.
         NX=IS2(3)
         NY=IS2(4)
         CALL NOMINL(KFILDO,XMESHL,MESH,TRASH,NPROJ,IER)
C           MESH IS THE NOMINL GRID MESH LENGTH.
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
            WRITE(KFILDO,5094)
 5094       FORMAT('     GRID NOT WRITTEN TO IP(19).')
C              THIS FOLLOWS A **** DIAGNOSTIC IN NOMINL.
            GO TO 510
         ENDIF
C
         IF(IDPARS(1,NPRED).EQ.002)THEN
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,1.8,-459.67,0,IER)
C              THIS SCALED TEMPERATURE IN KELVIN TO F.
         ELSE
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,1.,0.,0,IER)
C              THIS JUST COPIES THE DATA FROM DATA( ) TO FD4( ).
         ENDIF
C
         NCHAR=32         
         XMISSP=0.
         XMISSS=0.
C           IT IS ASSUMED THERE ARE NO MISSING VALUES IN THE GRID.
         CALL PAWGTS(KFILDO,IP19,'IP19  ',KFILDO,NDATE,
     1               ID(1,N),ITAUH,ITAUM,MODNO,NSEQ,ISCALD(N),
     2               NPROJ,ALATL,ALONL,ORIENT,MESH,XLAT,NX,NY,
     3               FD4,IWORK,FD1,IPACK,ND5,MINPK,
     4               IS0,IS1,IS2,IS4,ND7,
     5               IPLAIN(1,1,N),PLAIN(N),NCHAR,
     6               XMISSP,XMISSS,LX,IOCTET,
     7               N19TBY,N19TRC,L3264B,L3264W,IER)
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,5096)
 5096       FORMAT(/' ****ERROR IN PAWGTS IN PRED26 AT 5096.',
     1              '  GRID NOT WRITTEN TO IP19.  CONTINUING.')
C              ERROR WRITING TO THIS DIAGNOSTIC GRID IS NOT CONSIDERED FATAL.
            GO TO 510
         ENDIF
C         
      ENDIF    
C
C        WRITE THE GRIDDED DATA TO RANDOM ACCESS FILE 43, IF 
C        PROVIDED.
C
      DO 5099 JJ=1,6
C
      IF(KFILRA(JJ).EQ.43)THEN
         ISCALE=0
C
C            NOTE THAT ARRAY DATA( ) CONTAINS THE PACKED DATA.
C
         CALL PACKGR(KFILDO,KFILRA(JJ),RACESS(JJ),ID(1,N),IDPARS(1,N),
     1               ISCALD(N),ISCALE,NGRIDC(1,NSLAB),
     2               IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3               FD2,DATA,ND2X3,NX,NY,IPACK,IWORK,ND5,MINPK,
     4               IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5               NWORDS,LTOTBG,LTOTRG,
     6               L3264B,L3264W,ISTOP,IER)
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,5098)(ID(MMM,M),MMM=1,4),KFILRA(JJ),IER
 5098       FORMAT('     ERROR WRITING DATA FOR',
     1             1X,I9.9,2I10.9,I11.3,
     2             ' ON RANDOM ACCESS FILE UNIT NO.',I4,' IER =',I4,
     3             '.  PROCEEDING.')
         ENDIF
C     
         GO TO 5099
      ENDIF
C
 5099  CONTINUE
C
C        GRIDPRINT FIELD IF DESIRED.
C
 510  IF(IP14.EQ.0)GO TO 515
      IF(JP(2,N).EQ.0)GO TO 515
C
C        GRIDPRINT WHEN DESIRED.
C
      CALL PREDX1(KFILDO,IDPARS(1,N),THRESH(N),
     1            SMULT(N),SADD(N),ORIGIN(N),CINT(N),
     2            PLAIN(N),UNITS(N),NDATE,-IDPARS(9,N),DATA,ND5,
     3            IS2,ND7,IP14,ISTOP(1),IER)
C        AN ERROR IN GRIDPRINTING IS TREATED AS AN ISTOP(1) ERROR.  
C        NORMALLY, GRIDPRINTING WOULD BE DONE ONLY IN CHECKOUT.
C        IER NE 0 IN PREDX1 DOES NOT CAUSE MISSING DATA.
C
C        PACK AND WRITE THE GRIDPOINT FIELD WHEN A UNIT NUMBER
C        KFILGO IS PROVIDED.  IT IS POSSIBLE SOME GRIDS WILL HAVE
C        PRIMARY MISSING VALUES (E.G., CEILING HEIGHT FOR LAMP).
C        (PACKG IS USED IN U202/PACK23)
C
 515  IF(KFILGO.NE.0)THEN
         XMISSP=9999.
         XMISSS=0.
         CALL PACKG(KFILDO,KFILGO,ID(1,N),IDPARS(1,N),
     1              ISCALD(N),0,NGRIDC(1,NSLAB),
     2              IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3              FD1,DATA,ND2X3,IS2(3),IS2(4),IPACK,IWORK,ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              NWORDS,NTOTBG,NTOTRG,
     6              L3264B,L3264W,ISTOP(1),IER)
C           NOTE THAT GRIDPOINT DATA TO PACK ARE IN DATA( ).
      ENDIF
C
C        INTERPOLATE TO STATIONS.
C
 520  NGOMIS=0
C        CONTROL HERE SHOULD MEAN NON-MISSING DATA.
C
D     WRITE(KFILDO,521)(ID(J,N),J=1,4),IER
D521  FORMAT(/' AT 521 IN PRED26--(ID(J,N),J=1,4),IER',5I10)
C
D     WRITE(KFILDO,5211)NSIZE,NSLAB,(DATA(J),J=1,30)
D5211 FORMAT(/' AT 2211--NSIZE,NSLAB,(DATA(J),J=1,NSIZE)',2I10,/,
D    1      (10F10.3))
C
      IF(IDPARS(13,N).EQ.1)THEN
         CALL INTRPA(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPA IS BIQUADRATIC INTERPOLATION WHERE POSSIBLE, BILINEAR
C           OTHERWISE.
      ELSEIF(IDPARS(13,N).EQ.2)THEN
         CALL INTRPB(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPB IS BILINEAR.
      ELSEIF(IDPARS(13,N).EQ.3)THEN
         CALL INTRP(KFILDO,DATA,IWORK,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRP IS INTERPOLATION FOR PRECIPITATION AMOUNT.  THE PROCESS
C           IS BILINEAR AFTER PREPARATION OF THE FIELD TO PUT THE ZERO
C           LINE ABOUT HALFWAY BETWEEN POSITIVE AND ZERO GRIDPOINTS.\
C           IWORK( ) IS USED AS FLOATING POINT IN INTRP.  THAT IS OK.
C           IWORK( ) AND DATA( ) ARE BOTH DIMENSIONED ND5.
      ELSEIF(IDPARS(13,N).EQ.4)THEN
         CALL INTRPC(KFILDO,DATA,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPC IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT.
C
      ELSEIF(IDPARS(13,N).EQ.5)THEN
         NX=IS2(3)
         NY=IS2(4)
         CALL INTRPD(KFILDO,KFIL10,IP12,
     1               ID(1,N),IDPARS(1,N),JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,NELEV,
     4               ISDATA,SDATA,DIR,ND1,NSTA,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,ND5,
     7               LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               ND7,
     A               DATA,FD1,FD2,FD3,FD4,ND2X3,NX,NY,
     B               L3264B,L3264W,ISTOP(1),IER)
C           INTRPC IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT WITHIN THE 4-GRIDPOINT BOX WHERE THE STATION
C           IS LOCATED, BUT CONTINGENT ON A MASK INDICATING
C           A GRIDPOINT THAT CAN BE USED AND THE DIFFERENCE
C           BETWEEN THE ELEVATION OF THE GRIDPOINT AND THE
C           STATION BEING WITHIN BOUNDS (HARDWIRED IN INTRPD).
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
C              IER NE 0 FROM INTRPD IS TREATED AS AN ERROR, BUT
C              PROCESSING PROCEEDS.  IF THE GENERIC IDS WERE USED,
C              THE DATA ARE GOOD, BUT ISTOP(1) HAS BEEN INCREMENTED
C              IN INTRPD AND IER CAN = 0; IN OTHER CASES, THE DATA ARE
C              MISSING.  THE TRANSFORMATIONS BELOW HANDLE MISSING
C              VALUES.
            ISTOP(2)=ISTOP(2)+1
C              ANY IER NE 0 WILL MEAN MISSING DATA.  NOTE THAT THIS
C              IS THE ONLY "INTERPOLATION" ROUTINE THAT CAN ITSELF
C              CREATE AN ERROR OR MISSING DATA.
            IER=0
         ENDIF
      ELSEIF(IDPARS(1,N).GE.400.AND.IDPARS(1,N).LE.499)THEN
C            FOR THIS GRIDDED DATA FIELD, AN INTERPOLATION VALUE
C            OF 1, 2, 3, OR 4 IS REQUIRED.  IT IS LIKELY THIS WILL NOT
C            BE REACHED FOR CCC = 409 TERRAIN DATA, AS THEY WILL BE
C            STORED INTERNALLY BY PRED21.  THEREFORE, MISSING DATA
C            WILL NOT BE REPORTED.
         WRITE(KFILDO,528)(JD(K,N),K=1,4)
 528     FORMAT(/' ****GRIDDED CONSTANT ',3I10.9,I11.3,' DOES NOT HAVE',
     1           ' A VALID INTERPOLATION VALUE IN IDPARS(13).')
         ISTOP(1)=ISTOP(1)+1
      ELSE
C           WHEN THE INTERPOLATION VALUE IS NOT LEGITIMATE, CKIDS WILL
C           HAVE PRINTED A DIAGNOSTIC EXCEPT FOR THE CONSTANTS
C           TREATED IMMEDIATELY ABOVE.
         GO TO 600
      ENDIF
C
C        TRANSFORM VARIABLE WHEN DESIRED.  FROM HERE ON, DATA ARE 
C        VECTOR.
C
 530  IF(IDPARS(1,N).GE.200.AND.IDPARS(1,N).LE.299)GO TO 650
      IF(IDPARS(1,N).GE.300.AND.IDPARS(1,N).LE.399)GO TO 650
      IF(IDPARS(1,N).GE.500.AND.IDPARS(1,N).LE.599)GO TO 650
      IF(IDPARS(1,N).GE.600.AND.IDPARS(1,N).LE.699)GO TO 650
C        IT IS ASSUMED THAT IF CCC = 2XX (MOS FORECASTS), 
C        3XX (COMBINATION OF MODELS), 5XX (1-D TRANSFORMATIONS)
C        AND 6XX (2-D TRANSFORMATIONS) SHOULD NOT HAVE BINARY
C        PROCESSING DONE.
C
      IF(IDPARS(10,N).EQ.9)GO TO 650
C        WHEN IDPARS(10, ) = 9, THE THRESHOLD IS USED THROUGH OPTION
C        AND NO FURTHER PROCESSING IS DONE.
C
      IF(IDPARS(8,N).NE.0.AND.IDPARS(8,N).LT.7)
C            IDPARS(8, ) DOES NOT APPLY TO VECTOR DATA FOR 7, 8, AND 9.)
     1    CALL TRANS(KFILDO,ID(1,N),IDPARS(8,N),SDATA,NSTA,FD1,ND2X3,
     2               IER)
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
         GO TO 612
C           WHEN IER NE 0, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
C           AN ERROR IN TRANS WILL HAVE CREATED A DIAGNOSTIC.
      ENDIF
C
C         MAKE POINT BINARY VARIABLE WHEN DESIRED.
C
      IF(IDPARS(3,N).EQ.1)
     1    CALL BINARY(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),SDATA,NSTA,
     2                IER)
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
         GO TO 612
C           WHEN IER NE 0, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
C           AN ERROR IN BINARY WILL HAVE CREATED A DIAGNOSTIC.
      ENDIF
C
C        CURRENTLY, THE ONLY LEGITIMATE VALUES OF IDPARS(3, ) ARE O, 1, 2,
C        AND 5 IN U201.  OTHER VALUES CAUSE VALUES TO BE SET TO MISSING.
C        THIS ACCOMMODATES THE CUMULATIVE FROM ABOVE POINT BINARIES THAT
C        CAN BE USED AS PREDICTORS AND GRID BINARIES, BUT NOT CUMULATIVE
C        FROM BELOW OR DISCRETE BINARIES THAT CAN BE USED AS PREDICTANDS.
C        HOWEVER, IT ALSO ACCOMMODATES B = 2 FOR RELATIVE FREQUENCIES
C        AND PERCENTS AS MIGHT COME FROM AN ENSEMBLE (E.G., THE SREF).
C        NORMALLY, BINARIES WILL NOT BE MADE BY U201 BECAUSE ALL USING
C        PROGRAMS OF U201 OUTPUT WILL HAVE BINARY CAPABILITY.
C
      IF(IDPARS(3,N).EQ.0.OR.
     1   IDPARS(3,N).EQ.1.OR.
     2   IDPARS(3,N).EQ.5)GO TO 650
C
C        THE DATA ARE MISSING OR HAVE A NON-LEGITIMATE BINARY
C        INDICATOR.  NOTE THAT CCC = 2XX, 3XX, 5XX, AND 6XX HAVE BEEN
C        EXEMPTED FROM BINARY PROCESSING.  SET ALL VALUES TO 9999
C        EXCEPT IDPARS(3,N) = 2 IS PERMITTED, THIS LATTER FOR 
C        RELATIVE FREQUENCIES FROM THE SREF MODEL.
C
      IF(IDPARS(3,N).EQ.2)THEN 
C
         IF(IFIRST.EQ.0)THEN
            WRITE(KFILDO,598)(ID(J,N),J=1,4)
 598        FORMAT(/' ****BINARY INDICATOR IDPARS(3, ) = 2 IN PRED26',
     1             ' MAY BE AN ERROR FOR VARIABLE ',3I10.9,I11.3,/,
     2              '     BINARY INDICATOR IGNORED.  THIS DIAGNOSTIC',
     3              ' WILL NOT PRINT AGAIN IN PRED26.') 
            ISTOP(1)=ISTOP(1)+1
            IFIRST=1
         ENDIF
C
         GO TO 650 
C         
      ENDIF
C  
      WRITE(KFILDO,599)(ID(J,N),J=1,4)
 599  FORMAT(/' ****BINARY INDICATOR IDPARS(3, ) NE 0, 1, 2,OR 5',
     1        ' IS AN ERROR FOR ',3I10.9,I11.3,
     2        '.  SET TO MISSING.') 
C
 600  DO 610 K=1,NSTA
      SDATA(K)=9999.
 610  CONTINUE
C
 612  ISTOP(2)=ISTOP(2)+1
C        AN ATTEMPT IS MADE TO COUNT ALL MISSING FIELDS IN ISTOP(2),
C        EVEN IF AN ERROR HAS BEEN COUNTED IN ISTOP(1).
      NGOMIS=1
C        SET NGOMIS = 1 TO KEEP FROM REUSING A GRID WITH 
C        MISSING VALUES.
      XMISSP=9999.
      XMISSS=0.
      GO TO 655
C
C        SET XMISSP AND XMISSS.  NOTE THAT ANY VALUES OF 9997
C        IN VECTOR DATA HAVE BEEN SET TO PXMISS.
C        9997 IS NOT EXPECTED OR DEALT WITH IN GRIDPOINT DATA.
C        OPTION SHOULD NOT RETURN 9997 UNLESS IT IS DESIRED
C        TO LEAVE THOSE VALUES IN THE OUTPUT.
C
 650  IF(JP(3,N).NE.0)THEN
         CALL SETMIS(KFILDO,SDATA,NSTA,XMISSP,XMISSS)
      ENDIF
C
 655  CONTINUE
C
      IF(JP(3,N).NE.0)THEN
C        JP(3,N) CONTROLS WRITING OF VECTOR DATE TO BOTH
C        SEQUENTIAL AND EXTERNAL RANDOM ACCESS FILES. 
C        IN ADDITION, TO WRITE TO SEQUENTIAL, KFILVO HAS TO BE
C        NE 0 AND TO WRITE TO RA, 49 HAS TO BE ONE OF THE 
C        KFILRA( ) UNITS.
C
D        WRITE(KFILDO,6551)NSIZE,NSLAB,(SDATA(J),J=1,30)
D6551    FORMAT(/' AT 6551--NSIZE,NSLAB,(SDATA(J),J=1,NSIZE)',2I10,/,
D    1         (10F10.3))
C
C           PACK AND WRITE THE DATA.
C
         CALL PACKV(KFILDO,KFILVO,ID(1,N),IDPARS(1,N),
     1              JP(1,N),ISCALD(N),0,
     2              IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3              CCALL,ISDATA,SDATA,ND1,NSTA,IPACK,ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              IP15,NWORDS,NTOTBV,NTOTRV,
     6              L3264B,L3264W,ISTOP(1),IER)
         IF(INDEX(N).NE.1)GO TO 693
C
         IF(KFILVO.EQ.0)THEN
            WRITE(KFILDO,690)(ID(I,N),I=1,4),NDATE
 690        FORMAT(/' ****VARIABLE ',I11.9,3I11,
     1              ' COMPUTED MORE THAN ONCE PROCESSING DATE',I11)
         ELSE
            WRITE(KFILDO,691)(ID(I,N),I=1,4),NDATE
 691        FORMAT(/' ****VARIABLE ',I11.9,3I11,' COMPUTED AND',
     1              ' WRITTEN MORE THAN ONCE PROCESSING DATE',I11)
         ENDIF
C
         ISTOP(1)=ISTOP(1)+1
 693     INDEX(N)=1
C
C           WRITE TO EXTERNAL RA WHEN KFILRA( ) CONTAINS 49, THE
C           ONLY UNIT AVAILABLE FOR WRITING VECTOR DATA.
C
         DO 695 J=1,NUMRA
C
         IF(KFILRA(J).EQ.49)THEN
            NREPLA=2
C              REPLACE RECORD IF FOUND OR WRITE NEW RECORD.
            NCHECK=0
            CALL WRTDLR(KFILDO,KFILRA(J),RACESS(J),IS1(9),
     1                  ICALL,CCALL,ND1,NSTA,
     1                  ICALLD,CCALLD,ND5,IPACK,NWORDS,
     2                  NREPLA,NCHECK,L3264B,L3264W,IER) 
C              IS1(9) IS ESSENTIALLY ID(1,N).  FOR CCC = 400-499,
C              THE DD IS STRIPPED OFF IN PACKV.  THIS SHOULD NOT
C              MATTER HERE.
            IF(IER.NE.0)THEN
               ISTOP(1)=ISTOP(1)+1
C                 AN ERROR IN WRTDLR WILL PRINT A DIAGNOSTIC.
               GO TO 700
            ELSE
C                 THE CALCULATION OF BYTES IS THE SAME AS IN PACKV
C                 WHEN THE DATA ARE ACTUALLY WRITTEN.  THIS REPRESENTS
C                 THE BYTES OF DATA AND DOES NOT INCLUDE THE WORD
C                 (FOR L3264B = 32) WRITTEN PRECEEDING THE DATA.
C                 
               IF(L3264B.EQ.32)THEN
                  LTOTBV=LTOTBV+NWORDS*4
               ELSE
                  LTOTBV=LTOTBV+NWORDS*8
               ENDIF
C
               LTOTRV=LTOTRV+1
            ENDIF
C
            GO TO 700
         ENDIF
C
 695     CONTINUE
C
      ENDIF
C
 700  CONTINUE
C
 800  RETURN
      END
