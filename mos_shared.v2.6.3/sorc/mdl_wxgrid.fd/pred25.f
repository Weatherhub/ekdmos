      SUBROUTINE PRED25(KFILDO,KFIL10,KFILVO,KFILGO,NFIRST,
     1                  ID,IDPARS,THRESH,JD,JP,IFIND,ISTAV,ITIME,ISCALD,
     2                  SMULT,SADD,ORIGIN,CINT,IPLAIN,PLAIN,UNITS,NPRED,
     3                  NDATE,KFILRA,RACESS,NUMRA,
     4                  ICALL,CCALL,ICALLD,CCALLD,NAME,NSTA,NGRID,DIR,
     5                  NGRIDC,ISDATA,SDATA,SDATA1,L1DATA,
     6                  NELEV,STALAT,STALON,ITIMEZ,ND1,ND11,
     7                  IPACK,IWORK,DATA,ND5,MINPK,
     8                  LSTORE,MSTORE,ND9,LITEMS,MITEMS,CORE,ND10,LASTL,
     9                  NBLOCK,LASTD,NSTORE,NFETCH,
     A                  IS0,IS1,IS2,IS4,ND7,
     B                  FD1,FD2,FD3,FD4,FD5,FD6,FD7,
     C                  FDA,FDVERT,FDTIME,FDSINS,FDMS,ND2X3,
     D                  KFILAC,ASCIFL,
     E                  IP12,IP13,IP14,IP15,IP16,IP19,IP20,IP21,
     F                  NTOTBV,NTOTRV,NTOTBG,NTOTRG,
     G                  LTOTBV,LTOTRV,LTOTBG,LTOTRG,RAFILV,RAFILG,
     H                  N19TBY,N19TRC,
     I                  L3264B,L3264W,MISTOT,ISTOP,
     J                  THRPHS,THRQPF,THRTRW,THRSVR,
     K                  IPHSBC,PHSTMP,NSVRLOC,NX,NY,IER)
C
C        FEBRUARY  2010   GLAHN       MDL   MOS-2000
C                                     ADAPTED FROM PRED21
C        OCTOBER   2010   HUNTEMANN   ADDED KFILAC, IP20 TO CALL
C        JULY      2011   HUNTEMANN   ADDED IP21
C        NOVEMBER  2012   HUNTEMANN   ADDED PLAIN( ) TO THE CALLING 
C                                     SEQUENCE FOR ALL CALLS TO PACKGR. 
C
C        PURPOSE
C           TO OBTAIN FOR U720 ALL VARIABLES IDENTIFIED IN ID( , ),
C           IDPARS( , ), AND THRESH( ) FOR "DAY 1".  "BASIC" 
C           VARIABLES (THE VARIABLES SANS "PROCESSING" INFORMATION)
C           ARE IN JD( , ), RESPECTIVELY.  AVAILABLE VARIABLES ARE
C           INDICATED IN LSTORE( , ).  VARIABLES MAY BE OBTAINED 
C           FROM CORE( ) OR FROM DISK AS INDICATED IN LSTORE( , ),
C           OR THEY CAN BE COMPUTED THROUGH CALLING THE SUBROUTINE
C           OPTION.  THE VARIABLES ARE COMPUTED AND WRITTEN TO THE
C           OUTPUT FILE.  PRED25 IS ENTERED (ONLY) FOR THE FIRST
C           DATE/TIME.  CUMULATIVE FROM BELOW OR DISCRETE
C           BINARIES ARE NOT SUPPORTED.  GRIDPOINT AND VECTOR DATA
C           MUST BE HANDLED SOMEWHAT DIFFERENTLY.  FOR GRIDPOINT
C           DATA, THE BASIC ID IN JD( ) IS USED AND ALL PROCESSING
C           OPERATORS (B, T, I, S) APPLY.  FOR VECTOR DATA, IT IS
C           EXPECTED THAT THE PROCESSING WILL BE DONE IN OPTION,
C           EXCEPT THAT VECTOR DATA OUT OF OPTION CAN HAVE THE
C           TRANSFORMATION AND BINARY OPERATORS (T, B) APPLY.
C           SINCE IT IS NOT KNOWN UPON ENTRY WHETHER THE ID( )
C           APPLIES TO VECTOR OR GRIDPOINT DATA, GFETCH IS 
C           ENTERED FIRST WITH JD( ), THEN IF THE DATA ARE NOT
C           FOUND, GFETCH IS ENTERED AGAIN WITH ID( ).  IT THE
C           DATA ARE FOUND WITH JD( ), PROCESSING OCCURS;
C           OTHERWISE, IT DOES NOT.
C
C           IT IS A DIFFICULT CIRCUMSTANCE WHEN ALL DATA FOR 
C           DAY 1 ARE NOT AVAILABLE.  IN THAT CASE, WHEN OPTION
C           CANNOT IDENTIFY THE VARIABLE, IT IS ASSUMED THAT
C           IT IS NOT A COMPUTED VARIABLE BUT ONE THAT SHOULD
C           BE AVAILABLE FROM INPUT, BUT NOT FOR DAY 1.  SO,
C           ENTRIES ARE MADE DIRECTLY IN MSTORE( , ), WHICH
C           IS NORMALLY FILLED IN LMSTR2.  THE MAXIMUM RR
C           IN IDPARS(9, ) HAS TO BE APPLIED. 
C
C           PRED25 WAS DERIVED FROM PRED21 FOR U201; PRED 25 USES
C           ACCESSING ROUTINE GTVEGR RATHER THAN GFETCH.  GTVEGR
C           FIRST TRIES TO GET DATA FROM INTERNAL STORAGE VIA
C           GFETCH, AND IF NOT SUCCESSFUL TRIES RAFILES.  SOME
C           COMMENTS STILL REFER TO GFETCH, AND CAN BE INTERPRETED
C           AT THE GFETCH CALLED BY GTVEGR.
C   
C        DATA SET USE
C            KFILDO - UNIT NUMBER OF OUTPUT (PRINT) FILE.  (OUTPUT)
C            KFIL10 - UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                     (INPUT-OUTPUT) 
C            KFILVO - UNIT NUMBER OF VECTOR OUTPUT FILE.  (OUTPUT)
C            KFILGO - UNIT NUMBER OF GRIDDED OUTPUT FILE.  (OUTPUT)
C            KFILAC - UNIT NUMBER OF ASCII WEATHER KEY LIST FILE. 
C                     (OUTPUT)
C         KFILRA( ) - UNIT NUMBERS OF RANDOM ACCESS FILES.
C                     (INPUT/OUTPUT)
C              IP19 - UNIT NUMBER FOR SCALED GRIDDED OUTPUT.  (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF OUTPUT (PRINT) FILE.  (INPUT)
C              KFIL10 = UNIT NUMBER OF TDL MOS-2000 FILE SYSTEM ACCESS.
C                       (INPUT)
C              KFILVO = UNIT NUMBER OF VECTOR OUTPUT FILE.  (INPUT)
C              KFILGO = UNIT NUMBER OF GRIDDED OUTPUT FILE.  (INPUT)
C              KFILAC = UNIT NUMBER OF ASCII WEATHER KEY LIST FILE. 
C                       (OUTPUT)
C              ASCIFL = FILE NAME THAT CORRESPONDS TO THE UNIT NUMBER IN
C                       KFILAC. (CHARACTER*60)  (INTERNAL)
C              NFIRST = 1 FOR FIRST DAY, 2 FOR SECOND, 3 OTHERWISE.  
C                       FOR PRED25, NFIRST WILL ALWAYS BE 1.  (INPUT)  
C             ID(J,N) = THE INTEGER VARIABLE ID'S (J=1,4) (N=1,NPRED).
C                       (INPUT)
C         IDPARS(J,N) = THE PARSED, INDIVIDUAL COMPONENTS OF THE VARIABLE
C                       ID CORRESPONDING TO ID( ) (J=1,15) (N=1,NPRED).
C                       (INPUT)
C                       J=1--CCC (CLASS OF VARIABLE),
C                       J=2--FFF (SUBCLASS OF VARIABLE),
C                       J=3--B (BINARY INDICATOR),
C                       J=4--DD (DATA SOURCE, MODEL NUMBER),
C                       J=5--V (VERTICAL APPLICATION),
C                       J=6--LBLBLBLB (BOTTOM OF LAYER, 0 IF ONLY 1 LAYER),
C                       J=7--LTLTLTLT (TOP OF LAYER),
C                       J=8--T (TRANSFORMATION),
C                       J=9--RR (RUN TIME OFFSET, ALWAYS + AND BACK IN TIME),
C                       J=10--OT (TIME APPLICATION),
C                       J=11--OH (TIME PERIOD IN HOURS),
C                       J=12--TAU (PROJECTION IN HOURS),
C                       J=13--I (INTERPOLATION TYPE),
C                       J=14--S (SMOOTHING INDICATOR), AND
C                       J=15--G (GRID INDICATOR).
C           THRESH(N) = THE BINARY THRESHOLD ASSOCIATED WITH IDPARS( ,N)
C                       (N=1,NPRED).  (INPUT)
C             JD(J,N) = THE BASIC INTEGER VARIABLE ID (J=1,4) (N=1,NPRED).
C                       THIS IS THE SAME AS ID(J,N), EXCEPT THAT THE PORTIONS
C                       PERTAINING TO PROCESSING ARE OMITTED:
C                       B = IDPARS(3, ),
C                       T = IDPARS(8, ),
C                       I = IDPARS(13, ),
C                       S = IDPARS(14, ),
C                       G = IDPARS(15, ), AND
C                       THRESH( ).
C                       JD( , ) IS USED TO IDENTIFY THE BASIC MODEL FIELDS
C                       AS READ FROM THE ARCHIVE.  (INPUT)
C             JP(J,N) = JP( ,N) INDICATES WHETHER (>0) OR NOT (=0) VARIABLE N
C                       WILL BE OUTPUT FOR VIEWING (N=1,NPRED).
C                       J=1--GRIDPOINT VALUES,
C                       J=2--GRIDPRINT WITH CONTOURS, AND
C                       J=3--INTERPOLATED VALUES.
C                       THIS ALLOWS INDIVIDUAL VARIABLE CONTROL ON THE PRINT
C                       PARAMETERS IP12, IP13, AND IP14.  (INPUT)
C            IFIND(N) = 1 = WHEN THE VARIABLE CAN BE FOUND DIRECTLY
C                           FROM GFETCH (DOESN'T HAVE TO GO THRU OPTION).
C                       2 = WHEN ID( , ) HAS BEEN FOUND IN OPTION, BUT
C                           GOOD DATA WERE NOT RETURNED.  THEREFORE, IT 
C                           IS UNKNOWN WHERE THE DATA ARE TO COME FROM.
C                       0 = WHEN ID( , ) HAS BEEN FOUND IN OPTION AND
C                           THE DATA WILL BE COMPUTED THERE.
C                       (OUTPUT)
C            ISTAV(N) = INDICATES FOR EACH VARIABLE (N=1,NPRED) WHETHER 
C                       DATA ARE CURRENTLY VECTOR (=1) OR GRIDPOINT (=0).
C                       WHEN STILL UNDETERMINED, SET = 2.
C                       (INTERNAL/OUTPUT)
C            ITIME(N) = FOR EACH VARIABLE (N=1,NPRED) INDICATES
C                       WHETHER (=1) OR NOT (=0) THE RR IS TO BE USED 
C                       BY GFETCH WHEN FETCHING DATA.  (OUTPUT)
C           ISCALD(N) = THE DECIMAL SCALING CONSTANT TO USE WHEN PACKING THE 
C                       INTERPOLATED DATA (N=1,ND4).  THE BINARY SCALING
C                       CONSTANT IS USED AS ZERO.  (INPUT)
C            SMULT(N) = THE MULTIPLICATIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C             SADD(N) = THE ADDITIVE FACTOR WHEN CONTOURING OR
C                       GRIDPRINTING THE DATA (N=1,ND4).  (INPUT)
C           ORIGIN(N) = THE CONTOUR ORIGIN, APPLIES TO THE UNITS IN UNITS(N)
C                       (N=1,ND4).  (INPUT)
C             CINT(N) = THE CONTOUR INTERVAL, APPLIES TO THE UNITS IN
C                       UNITS(N) (N=1,ND4).  (INPUT)
C       IPLAIN(L,J,N) = 32 CHARACTERS (L=1,L3264W) (J=1,4) OF PLAIN LANGUAGE
C                       DESCRIPTION OF VARIABLES (N=1,ND4).
C                       NOTE THAT THIS REQUIRES TWO 32-BIT WORDS TO HOLD
C                       THE DESCRIPTION BUT ONLY ONE 64-BIT WORD.
C                       EQUIVALENCED TO PLAIN( ).  (INPUT)
C            PLAIN(N) = THE PLAIN LANGUAGE DESCRIPTION OF THE VARIABLES
C                       (N=1,ND4).  EQUIVALENCED TO IPLAIN( , ).
C                       (CHARACTER*32)  (INPUT)
C            UNITS(N) = THE UNITS OF THE DATA THAT APPLY AFTER MULTIPLYING
C                       BY SMULT(N) AND ADDING SADD(N) (N=1,NPRED).
C                       (CHARACTER*12)
C               NPRED = THE NUMBER OF VARIABLES NEEDED AND IDENTIFIED IN 
C                       ID( , ), ETC.  ALSO TREATED AS THE DIMENSION OF THE
C                       VARIABLES ID( , ), ETC.  THIS NAME IS A HOLDOVER,
C                       AS IS THE NAME OF THE ROUTINE ITSELF, TO WHEN 
C                       U720 WAS WRITTEN ONLY FOR PREDICTORS.  (INPUT)
C               NDATE = THE DATE/TIME FOR WHICH VARIABLES ARE TO BE
C                       FURNISHED ON THIS CALL TO PRED25.  (INPUT)
C           KFILRA(J) = HOLDS THE UNIT NUMBERS FOR ACCESSING THE MOS-2000
C                       EXTERNAL RANDOM ACCESS FILES (J=1,NUMRA).  (INPUT)
C           RACESS(J) = THE FILE NAMES CORRESPONDING TO KFILRA(J) (J=1,NUMRA).
C                       (CHARACTER*60)  (INPUT)
C               NUMRA = THE NUMBER OF UNIT NUMBERS AND NAMES IN KFILRA( )
C                       AND RACESS( ).  (INPUT)
C        ICALL(L,K,J) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,NSTA) (J=1,6).
C                       EQUIVALENCED TO CCALL( , )  (INPUT)
C          CCALL(K,J) = 8-CHARACTER STATION CALL LETTERS (OR GRIDPOINT
C                       LOCATIONS FOR GRID DEVELOPMENT) TO PROVIDE
C                       OUTPUT FOR (J=1) AND 5 POSSIBLE OTHER STATION
C                       CALL LETTERS (J=2,6) THAT CAN BE USED INSTEAD
C                       IF THE PRIMARY (J=1) STATION CANNOT BE FOUND 
C                       IN AN INPUT DIRECTORY (K=1,NSTA).  ALL STATION
C                       DATA ARE KEYED TO THIS LIST, EXCEPT POSSIBLY 
C                       CCALLD( ).  EQUIVALENCED TO ICALL( , , ).
C                       (CHARACTER*8)  (INPUT)
C         ICALLD(L,K) = 8 STATION CALL LETTERS AS CHARACTERS IN AN INTEGER
C                       VARIABLE (L=1,L3264W) (K=1,ND5).
C                       EQUIVALENCED TO CCALLD( ).  (INPUT)
C           CCALLD(K) = 8 STATION CALL LETTERS (K=1,ND5).  EQUIVALENCED 
C                       TO ICALLD( , ).  (CHARACTER*8)  (INTERNAL)
C             NAME(K) = NAMES OF STATIONS (K=1,NSTA).  USED FOR PRINTOUT
C                       ONLY.  (CHARACTER*20)  (INPUT)
C                NSTA = THE NUMBER OF STATIONS IN ICALL( , , ) AND CCALL( , ).
C                       (INPUT)
C               NGRID = THE NUMBER OF GRID COMBINATIONS IN DIR( , , ),
C                       MAXIMUM OF ND11.  (NOT ACTUALLY USED.)  (INPUT)
C          DIR(K,J,M) = THE IX (J=1) AND JY (J=2) POSITIONS ON THE GRID
C                       FOR THE COMBINATION OF GRID CHARACTERISTICS M
C                       (M=1,NGRID) AND STATION K (K=1,NSTA) IN NGRIDC( ,M).
C                       (INPUT)
C         NGRIDC(L,M) = HOLDS THE GRID CHARACTERISTICS (L=1,6) FOR EACH GRID
C                       COMBINATION (M=1,NGRID).
C                       L=1--MAP PROJECTION NUMBER (3=LAMBERT, 5=POLAR
C                            STEREOGRAPHIC). 
C                       L=2--GRID LENGTH IN MILLIMETERS,
C                       L=3--LATITUDE AT WHICH GRID LENGTH IS CORRECT *10000,
C                       L=4--GRID ORIENTATION IN DEGREES *10000,
C                       L=5--LATITUDE OF LL CORNER IN DEGREES *10000,
C                       L=6--LONGITUDE OF LL CORNER IN DEGREES *10000.
C           ISDATA(K) = USED IN PACK1D (K=1,NSTA).  (INTERNAL)
C            SDATA(K) = INTERPOLATED DATA FOR WRITING (K=1,NSTA).
C                       (INTERNAL)
C           SDATA1(K) = WORK ARRAY RESERVED FOR USE IN L2D2 (K=1,NSTA).
C                       (INTERNAL)
C           L1DATA(K) = THE ARRAY RESERVED FOR USE BY LINEARIZATION
C                       ROUTINES (K=1,NSTA).  (INTERNAL)  
C            NELEV(K) = ELEVATION OF STATIONS (K=1,NSTA).  (INPUT)
C           STALAT(K) = LATITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           STALON(K) = LONGITUDE OF STATIONS (K=1,NSTA).  (INPUT)
C           ITIMEZ(K) = TIME ZONE INDICATOR.  THE NUMBER OF HOURS
C                       THE STATION IS DIFFERENT FROM UTC (K=1,NSTA).
C                       (INPUT)
C                 ND1 = MAXIMUM NUMBER OF STATIONS THAT CAN BE DEALT WITH.
C                       (INPUT)
C                ND11 = MAXIMUM NUMBER OF GRID COMBINATIONS THAT CAN BE
C                       DEALT WITH ON THIS RUN.  LAST DIMENSION OF
C                       NGRIDC( , ) AND DIR( , , ).  (INPUT)
C            IPACK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C            IWORK(J) = WORK ARRAY (J=1,ND5).  (INTERNAL)
C             DATA(J) = ARRAY TO FURNISH TO SUBROUTINE GFETCH AND OPTION
C                       TO HOLD RETURNED DATA (J=1,ND5).  (INTERNAL)
C                 ND5 = DIMENSION OF IPACK( ), IWORK( ), AND DATA( ).
C                       MUST BE GE GRID SIZE, MAX IN RUN OF ND2X3.
C                       (INPUT)
C               MINPK = MINIMUM GROUP SIZE WHEN PACKING THE INTERPOLATED
C                       VALUES OR GRID.  (INPUT)
C         LSTORE(L,J) = THE ARRAY HOLDING INFORMATION ABOUT THE DATA 
C                       STORED (L=1,12) (J=1,LITEMS).  (INPUT-OUTPUT)
C                       L=1,4--THE 4 ID'S FOR THE DATA.
C                       L=5  --LOCATION OF STORED DATA.  WHEN IN CORE,
C                              THIS IS THE LOCATION IN CORE( ) WHERE
C                              THE DATA START.  WHEN ON DISK, 
C                              THIS IS MINUS THE RECORD NUMBER WHERE 
C                              THE DATA START.
C                       L=6  --THE NUMBER OF 4-BYTE WORDS STORED.
C                       L=7  --2 FOR DATA PACKED IN TDL GRIB, 1 FOR NOT.
C                       L=8  --THE DATE/TIME OF THE DATA IN FORMAT
C                              YYYYMMDDHH.
C                       L=9  --NUMBER OF TIMES DATA HAVE BEEN RETRIEVED.
C                       L=10 --NUMBER OF THE SLAB IN DIR( , ,L) AND
C                              IN NGRIDC( ,L) DEFINING THE CHARACTERISTICS
C                              OF THIS GRID.
C                       L=11 --THE NUMBER OF THE FIRST VARIABLE IN THE SORTED
C                              LIST IN ID( ,N) (N=1,NPRED) FOR WHICH THIS
C                              VARIABLE IS NEEDED, WHEN IT DOES NOT NEED
C                              TO BE STORED AFTER DAY 1.  WHEN THE VARIABLE
C                              MUST BE STORED (TO BE ACCESSED THROUGH OPTION)
C                              FOR ALL DAYS, ID(11,N) IS 7777 + THE NUMBER
C                              OF THE FIRST VARIABLE IN THE SORTED LIST
C                              FOR WHICH THIS VARIABLE IS NEEDED.
C                       L=12 --USED INITIALLY IN ESTABLISHING MSTORE( , ).
C                              LATER USED AS A WAY OF DETERMINING WHETHER
C                              TO KEEP THIS VARIABLE.
C         MSTORE(L,J) = THE ARRAY HOLDING THE VARIABLES NEEDED AS INPUT, AFTER
C                       DAY 1, AND ASSOCIATED INFORMATION (L=1,7) (J=1,MITEMS).
C                       J=1,4 --THE 4 ID'S OF THE DATA.
C                       J=5   --THE VALUE TAKEN FROM LSTORE(11, ) WHICH
C                               INDICATES WHETHER OR NOT TO STORE THE
C                               VARIABLE AND THE FIRST PREDICTOR TO USE IT FOR.
C                       J=6   --THE CYCLE TIME FOR WHICH THIS VARIABLE
C                               IS NEEDED FOR THE DATE BEING PROCESSED.  A
C                               VARIABLE NEEDED FOR MORE THAN ONE CYCLE TIME
C                               WILL HAVE ONE (AND ONLY ONE) ENTRY FOR EACH
C                               CYCLE.
C                       J=7   --THE MAXIMUM TIME OFFSET RR (SEE IDPARS(9, )
C                               CORRESPONDING TO MSTORE(6, )
C                 ND9 = THE SECOND DIMENSION OF LSTORE( , ).  (INPUT)
C              LITEMS = THE NUMBER OF ITEMS (COLUMNS) IN LSTORE( , ) THAT 
C                       HAVE BEEN USED IN THIS RUN.
C              MITEMS = THE NUMBER OF ITEMS IN MSTORE( , ).  (OUTPUT)
C             CORE(J) = THE ARRAY TO STORE OR RETRIEVE THE DATA IDENTIFIED IN
C                       LSTORE( , ) (J=1,ND10).  WHEN CORE( ) IS FULL
C                       DATA ARE STORED ON DISK.  (OUTPUT)
C                ND10 = DIMENSION OF CORE( ).  (INPUT)
C               LASTL = THE LAST LOCATION IN CORE( ) USED FOR MOS-2000 INTERNAL
C                       STORAGE.  INITIALIZED TO 0 ON FIRST ENTRY TO GSTORE.
C                       ALSO INITIALIZED IN U720 IN CASE GSTORE IS NOT ENTERED.
C              NBLOCK = THE BLOCK SIZE IN WORDS OF THE MOS-2000 RANDOM
C                       DISK FILE.  (INPUT)
C               LASTD = TOTAL NUMBER OF PHYSICAL RECORDS ON DISK FOR MOS-2000
C                       INTERNAL STORAGE.
C              NSTORE = THE NUMBER OF TIMES GSTORE HAS BEEN ENTERED.  GSTORE
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  THE USER 
C                       NEED NOT WORRY ABOUT THIS.   (OUTPUT)
C              NFETCH = THE NUMBER OF TIMES GFETCH HAS BEEN ENTERED.  GFETCH
C                       KEEPS TRACK OF THIS AND RETURNS THE VALUE.  (OUTPUT)
C              IS0(J) = MOS-2000 GRIB SECTION 0 ID'S (J=1,3).  (INTERNAL)
C              IS1(J) = MOS-2000 GRIB SECTION 1 ID'S (J=1,22+).  (INTERNAL)
C              IS2(J) = MOS-2000 GRIB SECTION 2 ID'S (J=1,12).  (INTERNAL)
C              IS4(J) = MOS-2000 GRIB SECTION 4 ID'S (J=1,4).  (INTERNAL)
C                 ND7 = DIMENSION OF IS0( ), IS1( ), IS2( ), AND IS4( ).
C                       NOT ALL LOCATIONS ARE USED.  (INPUT)
C  FD1(J),FD2(J), ETC = WORK ARRAYS (J=1,ND2X3).  THESE MAY BE USED IN
C                       ROUTINES AS 2-DIMENSIONAL ARRAYS, WHERE THE
C                       TOTAL ARRAY SIZE IS ND2*ND3=ND2X3 AS DECLARED IN
C                       THE CALLING PROGRAM.  (INTERNAL)
C              FDA(J) = USED TO RETAIN A GRID WITHIN PRED25 TO ELIMINATE
C                       MULTIPLE SEARCHS BY GFETCH AND UNPACKING OF
C                       THE DATA.  (INTERNAL)
C           FDVERT(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE VERTP
C                       (J=1,ND2X3).
C           FDTIME(J) = TEMPORARY STORAGE RESERVED FOR SUBROUTINE TEMEP
C                       (J=1,ND2X3).
C       FDSINS(IX,JY) = USED TO SAVE THE SIN OF THE LATITUDE IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C         FDMS(IX,JY) = USED TO SAVE THE MAP FACTOR IN SUBROUTINE
C                       PSMAPF (IX=1,NX) (JY=1,NY).  THE USER MUST NOT
C                       USE THIS ARRAY EXCEPT IN CALLING PSMAPF.
C                       (INPUT/OUTPUT)
C               ND2X3 = DIMENSION OF FD1( ), FD2( ), ETC.   MUST BE
C                       AT LEAST AS LARGE AS THE LARGEST GRID AND AS
C                       LARGE AS NSTA.  (INPUT)
C                IP12 = INDICATES WHETHER (>1) OR NOT (=0) THE LIST OF
C                       STATIONS ON THE INPUT VECTOR FILES WILL BE WRITTEN 
C                       TO UNIT IP12.
C                IP13 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE WRITTEN TO UNIT IP13 FOR VIEWING.  (INPUT)
C                IP14 = INDICATES WHETHER (>1) OR NOT (=0) GRIDPOINT FIELDS
C                       WILL BE CONTOURED AND WRITTEN TO UNIT IP14 FOR
C                       VIEWING.  (INPUT)
C                IP15 = INDICATES WHETHER (>1) OR NOT (=0) INTERPOLATED
C                       VALUES WILL BE WRITTEN TO UNIT IP15 FOR VIEWING.
C                       (INPUT)
C                IP16 = INDICATES WHETHER (>0) OR NOT (=0) DIAGNOSTICS
C                       WILL BE WRITTEN TO UNIT IP16 FOR LINEARIZATION
C                       AND CONSTANT ROUTINES (E.G., STATIONS IN
C                       THRESHOLD LISTS THAT ARE NOT BEING DEALT WITH
C                       IN THIS RUN).  (INPUT)
C                IP19 = INDICATES WHETHER (>0) OR NOT (=0) THE GRIDDED
C                       VARIABLES WILL BE WRITTEN TO IP19.
C                       GRIDDED VARIABLES WRITTEN PACKED.  THIS
C                       CAPABILITY WAS INSERTED FOR VIEWING THE
C                       GRIDS WITH GMOS_PLOT.  IT ALSO CONTROLS THE
C                       WRITING OF ASCII DATA FOR THE LAST VARIABLE
C                       DEALT WITH FOR THE LAST DAY.  IF LEFT ON,
C                        OTS OF DATA MIGHT BE NEEDLESSLY PACKED AND
C                       WRITTEN.  NORMALLY, U720 WOULD BE RUN FOR
C                       ONE VARIABLE FOR ONE DATE WHEN IP(19) NE.0.
C                       (INPUT)
C                IP20 = INDICATES WHETHER (>0) OR NOT (=0) A DIAGNOSTIC
C                       WEATHER KEY LIST PRINTED WITH CORRESPONDING
C                       INDICES FROM THE GRID WILL BE WRITTEN TO IP20.
C                       SAME OUTPUT AS KFILAC, EXCEPT WITH INDICES FOR 
C                       CHECKOUT. (INPUT)
C                IP21 = STATION VALUES OF WEATHER KEYS FOR STATIONS
C                       IN STATION LIST. (INPUT)
C              NTOTBV = THE TOTAL NUMBER OF BYTES IN THE SEQUENTIAL
C                       VECTOR FILE ASSOCIATED WITH UNIT NO. KFILVO.
C                       IT IS UPDATED WHEN THE DATA IN IPACK( ) ARE
C                       WRITTEN. (INPUT/OUTPUT)
C              NTOTRV = THE TOTAL NUMBER OF RECORDS IN THE SEQUENTIAL
C                       VECTOR FILE ASSOCIATED WITH UNIT NO. KFILVO. 
C                       IT IS UPDATED AS NEEDED IN WRITEP.
C                       (INPUT/OUTPUT)
C              NTOTBG = THE TOTAL NUMBER OF BYTES IN THE SEQUENTIAL
C                       GRIDDED FILE ASSOCIATED WITH UNIT NO. KFILGO.
C                       IT IS UPDATED WHEN THE DATA IN PACKG( ) ARE
C                       WRITTEN. (INPUT/OUTPUT)
C              NTOTRG = THE TOTAL NUMBER OF RECORDS IN THE SEQUENTIAL
C                       GRIDDED FILE ASSOCIATED WITH UNIT NO. KFILGO.
C                       IT IS UPDATED AS NEEDED IN PACKG. (INPUT/OUTPUT)
C              LTOTBV = THE TOTAL NUMBER OF BYTES OF VECTOR DATA WRITTEN
C                       TO THE EXTERNAL RANDOM ACCESS FILE, UNIT NO. 49.
C                       (INPUT/OUTPUT)
C              LTOTRV = THE TOTAL NUMBER OF RECORDS OF VECTOR DATA
C                       WRITTEN TO THE EXTERNAL RANDOM ACCESS FILE, UNIT
C                       NO. 49. (INPUT/OUTPUT)
C              LTOTBG = THE TOTAL NUMBER OF BYTES OF GRIDDED DATA
C                       WRITTEN TO THE EXTERNAL RANDOM ACCESS FILE, UNIT
C                       NO. 42 OR 43. (INPUT/OUTPUT)
C              LTOTRG = THE TOTAL NUMBER OF RECORDS OF GRIDDED DATA
C                       WRITTEN TO THE EXTERNAL RANDOM ACCESS FILE, UNIT
C                       NO. 42 OR 43.  (INPUT-OUTPUT)
C              RAFILV = THE NAME OF THE VECTOR FILE WRITTEN TO FOR UNIT
C                       NO. 49.  (CHARACTER*60)  (OUTPUT)
C              RAFILG = THE NAME OF THE GRIDDED FILE WRITTEN TO FOR UNIT
C                       NO. 43.  (CHARACTER*60)  (OUTPUT)
C              N19TBY = TOTAL BYTES WRITTEN TO IP19.  (INPUT-OUTPUT)
C              N19TRC = TOTAL RECORDS WRITTEN TO IP19.  (INPUT-OUTPUT)
C              L3264B = INTEGER WORD LENGTH IN BITS OF MACHINE BEING USED
C                       (EITHER 32 OR 64).  (INPUT)
C              L3264W = NUMBER OF WORDS IN 64 BITS (EITHER 1 OR 2).  (INPUT)  
C              MISTOT = TOTAL NUMBER OF TIMES A PRIMARY MISSING INDICATOR
C                       HAS BEEN ENCOUNTERED IN UNPACKING GRIDS.  NOTE 
C                       THAT THIS IS LIMITED TO GRIDS AND DOES NOT
C                       INCLUDE VECTORS.  (INPUT-OUTPUT)
C            ISTOP(J) = FOR J=1, ISTOP( ) IS INCREMENTED BY 1 EACH TIME
C                       AN ERROR OCCURS THAT MAY BE FATAL OR SHOUD BE 
C                       DIAGNOSED.
C                       FOR J=2, ISTOP( ) IS INCREMENTED BY 1 WHENEVER AN
C                       INPUT DATA RECORD IS NOT FOUND.  (INPUT-OUTPUT)
C                 IER = STATUS RETURN.
C                        0 = GOOD RETURN.
C                       38 = ND2X3 NOT LARGE ENOUGH.
C                       SEE OTHER ROUTINES FOR OTHER VALUES.
C                       (INTERNAL-OUTPUT)
C               NSLAB = THE NUMBER OF THE SLAB IN DIR( , , ) AND
C                       IN NGRIDC( , ) DEFINING THE CHARACTERISTICS
C                       OF THIS GRID.  SEE LSTORE(10, ).  (INTERNAL) 
C              NTIMES = THE NUMBER OF TIMES, INCLUDING THIS ONE, THAT THE 
C                       DATA HAVE BEEN FETCHED.  THIS IS STORED IN
C                       LSTORE(9, ).  (INTERNAL)
C                 NYR = YEAR, 4 DIGITS.  (INTERNAL)
C                 NMO = MONTH.  (INTERNAL)
C                 NDA = DAY OF MONTH.  (INTERNAL)
C                 NHR = HOUR, 2 DIGITS.  (INTERNAL)
C               LD(J) = HOLDS THE 3 ID WORDS OF THE DATA IN FDA( ) (J=1,3).  
C                       (INTERNAL)
C               LFIND = THE VALUE OF IFIND( ) FOR THE VARIABLE IN FDA( ).
C                       (INTERNAL)
C               NSIZE = THE NUMBER OF VALUES IN VARIOUS ARRAYS, EITHER
C                       VECTOR OR GRIDPOINT.  (INTERNAL)
C               MISSP = PRIMARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C               MISSS = SECONDARY MISSING VALUE INDICATOR.  RETURNED AS ZERO
C                       FROM GFETCH WHEN DATA ARE NOT PACKED.  (INTERNAL)
C              XMISSP = PRIMARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C              XMISSS = SECONDARY MISSING VALUE PROVIDED TO PACKV.
C                       (INTERNAL)
C              NGOMIS = SWITCH TO KEEP FROM PROCESSING A MISSING GRID.
C                       1 = MISSING GRIDPOINT DATA,
C                       0 = GOOD GRID DATA.
C                       (INTERNAL)
C              NWORDS = NUMBER OF WORDS IN IPACK( ) RETURNED FROM PACKV
C                       AND PACKG.(INTERNAL)
C              NRRDAT = DATE FAR INTO THE FUTURE TO FORCE SAVING OF
C                       STATION UPSLOPE VALUES.
C              IFIRST = 0 FOR FIRST VARIABLE AND = 1 OTHERWISE.  SET BY
C                       DATA STATEMENT.  (INTERNAL)
C           THRPHS(I) = REAL VECTOR OF LENGTH (4) CONTAINING THE PHASE
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE FOUR 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS 
C                       (INPUT).  ELEMENTS WITHIN THRPHS MUST BE 
C                       BETWEEN 0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (I=1,4)
C           THRQPF(I) = REAL VECTOR OF LENGTH (2) CONTAINING THE QPF6 
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE TWO 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS. 
C                       ELEMENTS WITHIN THRQPF MUST BE BETWEEN 
C                       0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (INPUT)  (I=1,2)
C           THRTRW(I) = REAL VECTOR OF LENGTH (4) CONTAINING THE THUNDER
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE FOUR 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS 
C                       (INPUT).  ELEMENTS WITHIN THRTRW MUST BE 
C                       BETWEEN 0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (I=1,4)
C           THRSVR(I) = REAL VECTOR OF LENGTH (4) CONTAINING THE SEVERE 
C                       THRESHOLDS, EXPRESSED IN PERCENT, OF THE FOUR 
C                       PERMITTED CATEGORICAL PROBABILITY FORECASTS 
C                       (INPUT).  ELEMENTS WITHIN THRSVR MUST BE 
C                       BETWEEN 0 AND 100 PERCENT, INCLUSIVE, AND BE 
C                       MONOTONICALLY INCREASING. (I=1,4)
C              PHSTMP = PRECIPITATION PHASE CUTOVER TEMPERATURE
C                       THRESHOLD TO LIQUID.  IF THE MOS FORECAST
C                       TEMPERATURE IS AT OR ABOVE PHSTMP, THE 
C                       PRECIPITATION PHASE IS INITIALIZED TO 
C                       LIQUID. (INPUT)
C              IPHSBC = FLAG FOR USING CONDITIONAL PRECIPITATION TYPE
C                       BEST CATEGORY THRESHOLDS:
C                       1 = USE THRESHOLDS
C                       ELSE = DON'T USE THRESHOLDS
C                       (INPUT) 
C             NSVRLOC = FLAG TO DETERMINE ORDER OF ASCII WEATHER SUBKEYS.
C                       1 = SEVERE ALWAYS FIRST
C                       2 = SCT,NUM,DEF SEVERE ALWAYS FIRST
C                       3 = SHOW LESS SEVERE AT LATER PROJECTIONS
C                       (INPUT) 
C                  NX = NUMBER OF GRIDPOINTS IN X DIRECTION. (INPUT)
C                  NY = NUMBER OF GRIDPOINTS IN Y DIRECTION. (INPUT)
C
C        1         2         3         4         5         6         7 X
C 
C        NONSYSTEM SUBROUTINES USED 
C            OPTION, GRIDB, SMTH5, SMTH9, SMTH25, SMTH2X, SMTH3X,
C            INTRP, INTRPA, INTRPB, INTRPC, INTRPD, TRANS, BINARY,
C            PREDX1, PACKV, TIMPR, GTVEGR
C
      CHARACTER*8 CCALL(ND1,6),
     1            CCALLD(ND5)
      CHARACTER*12 UNITS(NPRED)
      CHARACTER*20 NAME(ND1)
      CHARACTER*32 PLAIN(NPRED)
      CHARACTER*60 RACESS(NUMRA),RAFILV,RAFILG
C
      DIMENSION ICALL(L3264W,ND1,6),
     1          NELEV(ND1),STALAT(ND1),STALON(ND1),ITIMEZ(ND1),
     2          ISDATA(ND1),SDATA(ND1),SDATA1(ND1),L1DATA(ND1)
      DIMENSION DIR(ND1,2,ND11),NGRIDC(6,ND11)
      DIMENSION ID(4,NPRED),IDPARS(15,NPRED),THRESH(NPRED),
     1          JD(4,NPRED),JP(3,NPRED),IFIND(NPRED),ISTAV(NPRED),
     2          ITIME(NPRED),ISCALD(NPRED),SMULT(NPRED),SADD(NPRED),
     3          ORIGIN(NPRED),CINT(NPRED)
      DIMENSION IPLAIN(L3264W,4,NPRED)
      DIMENSION FD1(ND2X3),FD2(ND2X3),FD3(ND2X3),FD4(ND2X3),
     1          FD5(ND2X3),FD6(ND2X3),FD7(ND2X3),FDA(ND2X3),
     2          FDVERT(ND2X3),FDTIME(ND2X3),FDSINS(ND2X3),FDMS(ND2X3)
      DIMENSION IPACK(ND5),IWORK(ND5),DATA(ND5),ICALLD(L3264W,ND5)
      DIMENSION IS0(ND7),IS1(ND7),IS2(ND7),IS4(ND7)
      DIMENSION LSTORE(12,ND9),MSTORE(7,ND9)
      DIMENSION CORE(ND10)
      DIMENSION KFILRA(NUMRA)
      DIMENSION LD(3),ISTOP(2),JDPARS(15)
      DIMENSION THRPHS(4),THRTRW(4),THRQPF(2),THRSVR(4)
C
      DATA NGOMIS/0/
      DATA NRRDAT/2100010100/
      DATA IFIRST/0/
C
      IER=0
D     CALL TIMPR(KFILDO,KFILDO,'START PRED25        ')
C
C        SET UP SOME VALUES FOR LOADING IS1( ).
C
      NYR=NDATE/1000000
      NMO=NDATE/10000-NYR*100
      NDA=NDATE/100-NYR*10000-NMO*100
      NHR=NDATE-NYR*1000000-NMO*10000-NDA*100
C
C        FIND/COMPUTE ALL VARIABLES FOR THE DATE IN NDATE.
C      
      MITEMS=0
C 
      DO 400 N=1,NPRED
C
D     WRITE(KFILDO,105)N,ISTOP(1),ISTOP(2)
D105  FORMAT(/' AT 105 IN PRED25--N,ISTOP(1),ISTOP(2)',3I5)
C
      ITIME(N)=1
C        ITIME(N) = 1 SIGNIFIES RR IS TO BE USED.  THIS WILL
C        BE MODIFIED LATER IF THE FULL ID IS LOCATED BY GFETCH.
      IFIND(N)=1
C        SET IFIND( ) FOR SAFETY.  IT SHOULD BE REPLACED.
C
      IF(IDPARS(1,N).EQ.799)GO TO 390
C           NO NEED TO LOOK FOR THE SPECIAL CCC = 799.
C
      IF(N.EQ.1)GO TO 130
      IF(ISTAV(N-1).EQ.1)GO TO 130
C        NOTE THAT ISTAV(N) HAS NOT BEEN INITIALIZED YET.
C
C        THIS SECTION IS NOT ENTERED FOR VECTOR DATA.
C        THIS VARIABLE CAN BE REUSED FROM THE PREVIOUS ONE ONLY IF:
C           (1) IT IS A GRID AND ONLY THE POINT COMPUTATIONS
C               ARE NECESSARY (E.G., INTERPOLATION).
C        IF GRID PROCESSING (E.G., SMOOTHING) IS NEEDED ON A 
C        BASIC GRID, IT MAY BE SAVED IN FDA( ).
C        THE MAIN PURPOSE OF THESE BYPASSES IS TO COUNT THE NUMBER OF
C        TIMES A GRID MUST BE ACCESSED ON SUBSEQUENT DATES.  THIS IS 
C        SO THAT ONLY THOSE DATA THAT MUST BE ACTUALLY RETRIEVED FROM 
C        THE MOS-2000 INTERNAL STORAGE SYSTEM WILL BE STORED WITH
C        GSTORE.)
C
      ISTAV(N)=ISTAV(N-1)
C        ISTAV(N) MAY LATER BE REPLACED.
      IF(JD(1,N).EQ.JD(1,N-1).AND.
     1   JD(2,N).EQ.JD(2,N-1).AND.
     2   JD(3,N).EQ.JD(3,N-1).AND.
     3   IDPARS(3,N).NE.5.AND.
     4   IDPARS(3,N-1).NE.5.AND.
CCC     5   IDPARS(13,N).EQ.IDPARS(13,N-1).AND.
CCC  OMITTED 2/16/09
     6   IDPARS(14,N).EQ.IDPARS(14,N-1).AND.
     7   IDPARS(15,N).EQ.IDPARS(15,N-1).AND.
     8   ((IDPARS(8,N).EQ.IDPARS(8,N-1)).OR.(IDPARS(8,N).LT.7.AND.
     9                                       IDPARS(8,N-1).LT.7)).AND.
     A   (IDPARS(3,N).LE.1.AND.IDPARS(3,N-1).LE.1).AND.
C           ABOVE ADDED 9/30/09 FOR RF FROM SREF WITH B = 2
     B   NGOMIS.EQ.0)THEN
C           THE CHECK ON IDPARS(3,N-1) IS NOT NECESSARY WHEN
C           THE VARIABLES ARE ORDERED, AS THEY SHOULD BE
C           UNLESS SORTEM IS TAKEN OUT OF RDPRED.  NGOMIS
C           IS 1 WHEN THE PREVIOUS VARIABLE WAS MISSING.
C           THE CHECKS ON IDPARS(8, ) PUT IN WHEN THE VALUES
C           OF 7, 8, AND 9 WERE ADDED FOR VARIANCE (GRIDDED)
C           COMPUTATIONS.  NOTE THAT V MUST BE THE SAME FOR N AND N-1
C           UNLESS BOTH ARE LT 7.
         IFIND(N)=IFIND(N-1)
D        WRITE(KFILDO,115)N,(ID(J,N),J=1,4)
D115     FORMAT(' REUSING GRID FOR VECTOR COMPUTATIONS AT 115',
D    1          ' IN PRED25, FOR VARIABLE NO. ',I3,I12.9,3I11)
         GO TO 220
      ENDIF
C        WHEN THE ABOVE TEST IS MET, THE GRID IN DATA( ) CAN
C        BE REUSED FOR VECTOR COMPUTATIONS.  THE ONLY THING THAT
C        CAN BE DIFFERENT ARE BINARY THRESHOLDS, INTERPOLATION,
C        AND TRANSFORMATIONS WITH T LT 7.  SINCE POINT BINARIES
C        ARE NOT USUALLY MADE IN U720, INTERPOLATION TYPE IS
C        USUALLY THE SAME FOR ALL VARIABLES, AND TRANSFORMATIONS
C        RARELY USED, THIS PROBABLY HAS LITTLE UTILITY.
C
C        IS THIS GRID REUSABLE AND STORED IN FDA( )?  NOTE THAT
C        THESE DATA ARE USED FOR MAKING A GRID BINARY AND/OR
C        SMOOTHING.
C
      IF(JD(1,N).NE.LD(1).OR.
     1   JD(2,N).NE.LD(2).OR.
     2   JD(3,N).NE.LD(3).OR.
     3   IDPARS(3,N).EQ.2.OR.
C           ADDED THE ABOVE 9/7/09 FOR SREF RF WITH B = 2.
     4   IDPARS(8,N).GE.7)GO TO 130
C
C        TAKE DATA FROM FDA( ).  DATA CAN BE USED FROM FDA( )
C        WHEN THE GRID (FROM GSTORE OR OPTION) IS THE SAME,
C        BUT MAKING A GRID BINARY AND SMOOTHING CAN BE DIFFERENT,
C        AS WELL AS THE POINT CALCULATIONS OF MAKING A POINT
C        BINARY, TRANSFORMATION, AND INTERPOLATION.  THE CHECK ON
C        IDPARS(8, ) PUT IN WHEN THE VALUES OF 7, 8, AND 9 WERE
C        ADDED FOR VARIANCE (GRIDDED) COMPUTATIONS.
C
D     WRITE(KFILDO,119)N,(JD(K,N),K=1,4)
D119  FORMAT(' REUSING GRID FROM FDA( ) AT 119 IN PRED25 ',
D    1       ' FOR VARIABLE NO.',I3,I12.9,3I11)
C
      IFIND(N)=LFIND
C
      DO 120  K=1,NSIZE
      DATA(K)=FDA(K)
 120  CONTINUE
C
      GO TO 205
C
 130  IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)GO TO 133
C        IN PRED25, TERRAIN HEIGHT MUST COME THROUGH OPTION WHEN 
C        DD = 0 (DD = 5 FOR LAMP FORECASTS).  PRED25 STORES 
C        TERRAIN DATA WITH DD = 0 AS VECTOR AT STATIONS (AT STATEMENT
C        NO. 360), PRED22 WILL OBTAIN THEM FROM THERE.
C
C        TRY TO FIND VARIABLE IN LSTORE AND RETURN IT IN DATA( ).
C        IF THE DATA ARE GRIDPOINT, THEN JD( , ) IS USED BECAUSE
C        THE RAW VARIABLE BEFORE THE PROCESSING IS DONE IS NEEDED.
C        WHEN THE DATA ARE VECTOR, THEN ID( , ) IS USED, BECAUSE
C        THE INPUT MAY HAVE COME FROM A PREVIOUS RUN OF U201 OR 720
C        AND THE PROCESSING INDICATORS WILL ALREADY BE THERE.
C        SINCE ISTAV( ) IS INITIALIZED LATER, THERE IS NO WAY TO
C        TELL ON THIS FIRST ACCESS WHETHER VECTOR OR GRIDPOINT
C        DATA ARE NEEDED.  LOOK FOR VECTOR DATA FIRST, AND IF
C        NOT FOUND, THEN LOOK FOR GRIDPOINT DATA.
C
      JTIME=0
C        FIRST TRY WITH RR INOPERATIVE UNLESS THE PREVIOUS
C        VARIABLE IS THE SAME WITH ITIME = 0.  THEN, IN
C        ORDER TO NOT GET THE SAME VARIABLE, RR MUST BE
C        OPERATIVE.
C
 1300 CALL GTVEGR(KFILDO,KFIL10,IP12,
     1            ID(1,N),IDPARS(1,N),JD(1,N),NDATE,
     2            KFILRA,RACESS,NUMRA,
     3            CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,
     4            ISDATA,SDATA,DIR,ND1,NSTA,NSIZE,
     5            NGRIDC,NGRID,ND11,NSLAB,
     6            IPACK,IWORK,DATA,ND5,
     7            LSTORE,ND9,LITEMS,N,CORE,ND10,LASTL,
     8            NBLOCK,LASTD,NSTORE,NFETCH,
     9            IS0,IS1,IS2,IS4,ND7,
     A            ISTAV(N),L3264B,L3264W,IER)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN GFETCH.
      IF(IER.EQ.0)THEN
         ITIME(N)=JTIME
C           IF THE FULL ID WAS FOUND (WITH NO RR TIME OFFSET),
C           ITIME(N) IS SET TO JTIME SIGNIFYING WHETHER OR NOT RR
C           IS NOT TO BE USED ON SUBSEQUENT DAYS FOR THIS VARIABLE.
         IDYES=1
C           IDYES=1 INDICATES DATA FOR THE FULL ID WERE FOUND.
C           RR MAY OR MAY NOT HAVE BEEN OPERATIVE.
C
CCC         IF(ISTAV(N).EQ.0)THEN
CCC            WRITE(KFILDO,1301)NSIZE,NSLAB,(DATA(J),J=1,30)
CCC 1301       FORMAT(/' AT 1301--NSIZE,NSLAB,(DATA(J),J=1,NSIZE)',2I10,/,
CCC     1            (10F10.3))
CCC         ELSE
CCC            WRITE(KFILDO,1302)NSIZE,NSLAB,(SDATA(J),J=1,30)
CCC 1302       FORMAT(/' AT 1302--NSIZE,NSLAB,(SDATA(J),J=1,NSIZE)',2I10,/,
CCC     1            (10F10.3))
CCC         ENDIF
C
         GO TO 1305
      ELSE
         IDYES=0
         IF(IER.NE.47)ISTOP(1)=ISTOP(1)+1
C           THIS IS AN ERROR EXCEPT WHEN IER = 47.
C
         IF(JTIME.EQ.0)THEN
            JTIME=1
C              JTIME SET = 1 THE FIRST TIME THROUGH LETS
C              STATEMENT 1300 BE REPEATED ONLY ONCE.
            IF(IDPARS(9,N).NE.0)GO TO 1300
C              NO NEED TO ENTER GFETCH AGAIN IF RR = 0.
         ENDIF
C
      ENDIF
C
      IF(IER.EQ.47)THEN
         IF(ID(1,N).EQ.JD(1,N).AND.
     1      ID(2,N).EQ.JD(2,N).AND.
     2      ID(3,N).EQ.JD(3,N).AND.
     3      ID(4,N).EQ.JD(4,N))GO TO 1305
C              NO USE TO CALL GFETCH AGAIN FOR THE SAME THING.
C              CALLS GFETCH HERE ONLY ON IER = 47 FROM ABOVE.
         CALL PRSID1(KFILDO,JD(1,N),JDPARS)
         CALL GTVEGR(KFILDO,KFIL10,IP12,
     1               JD(1,N),JDPARS,JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,
     4               ISDATA,SDATA,DIR,ND1,NSTA,NSIZE,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,DATA,ND5,
     7               LSTORE,ND9,LITEMS,N,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               IS0,IS1,IS2,IS4,ND7,
     A               ISTAV(N),L3264B,L3264W,IER)
C           MOST NON-ZERO VALUES OF IER SHOULD BE NEAR FATAL.
C           ISTOP(1) IS INCREMENTED, EXCEPT WHEN IER = 47,
C           WHICH JUST MEANS DATA COULD NOT BE FOUND.  RETURNED
C           DATA WILL BE UNPACKED WHETHER OR NOT THEY WERE STORED
C           PACKED, AND NSIZE WILL BE THE NUMBER OF VALUES.
C           FOR GRIDPOINT DATA, THIS WILL BE IS2(3)*IS2(4); FOR
C           VECTOR DATA, THIS WILL BE NSTA.
      ENDIF
C
 1305 IF(IER.EQ.0)THEN
         IFIND(N)=1
C
         IF(NSIZE.GT.ND2X3)THEN
            WRITE(KFILDO,131)ND2X3,(ID(J,N),J=1,4),NSIZE
 131        FORMAT(/' ****ND2X3 =',I6,' TOO SMALL FOR GRID SIZE',
     1              ' PROCESSING VARIABLE',I11.9,3I11,
     2              ' IN PRED25 AT 131.  INCREASE TO GE',I6)
            IER=38
            ISTOP(1)=ISTOP(1)+1
            GO TO 300
         ENDIF
C
CCCC         WRITE(KFILDO,1315)N,IFIND(N),IDYES,NSLAB
CCCC 1315    FORMAT(/' AT 1315--N,IFIND(N),IDYES,NSLAB',4I8)
C
         IF(NSLAB.EQ.0)THEN
C
            IF(IDYES.EQ.0)THEN
               IFIND(N)=0
C                 IDYES = 0 INDICATES THAT THE FULL ID WAS NOT
C                 FOUND BY GFETCH, AND WHEN THE DATA ARE VECTOR,
C                 DATA FOR THE PARTIAL ID, EVEN IF FOUND, ARE
C                 NOT USED.  A PARTIAL ID INDICATES PROCESSING
C                 IS NEEDED, AND PROCESSING ON VECTOR DATA IS
C                 NOT DONE OUTSIDE OPTION.  NOTE THAT IT IS
C                 NOT KNOWN BEFORE CALLING GFETCH THE SECOND 
C                 TIME THAT THE DATA ARE VECTOR.
               GO TO 133
            ENDIF
C
CCCC            ISTAV(N)=1
C              WHEN NSLAB = 0, THE DATA ARE VECTOR, NOT GRIDPOINT.
C              TRANSFER DATA FROM DATA( ) TO SDATA( ) AND DO NO
C              PROCESSING.   THE ONLY PROCESSING THAT CAN BE DONE 
C              ON VECTOR DATA MUST BE DONE IN OPTION.
C              THEREFORE, PUT DATA INTO SDATA( ) AND OUTPUT.
C              NOTE THAT THE ARRANGEMENT OF VECTOR DATA HAS
C              ALREADY BEEN MADE IN RDSTR2.
            NSTA=NSIZE
C            
CCCC         DO 132 K=1,NSIZE
CCCC            SDATA(K)=DATA(K)
CCCC 132        CONTINUE
C
            GO TO 350
         ELSE
CCCC            ISTAV(N)=0
            IF(MISSP.NE.0)MISTOT=MISTOT+1
C              MISTOT IS AUGMENTED ONLY WHEN DATA ARE GRIDPOINT.
         ENDIF
C
         GO TO 138
C
      ELSEIF(IER.EQ.47)THEN
C           JUST MISSING DATA, A NOT UNEXPECTED EVENT.  GO TO OPTION,
C           DO NOT COUNT THIS AS AN ERROR.  (IT WOULD BE AN ERROR IN
C           PRED22.)
         ISTAV(N)=2
C           THE TYPE OF DATA IS UNDETERMINED.
         GO TO 133
C
      ELSE
         IFIND(N)=1
         ISTOP(1)=ISTOP(1)+1
C           FATAL ERROR FOR THIS VARIABLE.  IT WAS FOUND BY GFETCH, BUT
C           COULD NOT BE RETURNED.  ALL VALUES WILL BE MISSING.
C           GO TO 300 TO PUT MISSING VALUES INTO SDATA( ).
         ISTAV(N)=2
C           THE TYPE OF DATA IS UNDETERMINED.
         GO TO 300
C
      ENDIF
C
C        MUST COMPUTE THIS VARIABLE.
C
 133  CALL OPTION(KFILDO,KFIL10,NFIRST,
     1            ID(1,N),IDPARS(1,N),THRESH(N),JD(1,N),NDATE,
     2            KFILRA,RACESS,NUMRA,
     3            ICALL,CCALL,ICALLD,CCALLD,NAME,
     4            NELEV,STALAT,STALON,
     5            ITIMEZ,ISDATA,SDATA,SDATA1,L1DATA,DIR,ND1,NSTA,
     6            NGRIDC,NGRID,ND11,NSLAB,IPACK,IWORK,DATA,ND5,
     7            LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     8            NBLOCK,LASTD,NSTORE,NFETCH,
     9            IS0,IS1,IS2,IS4,ND7,
     A            FD1,FD2,FD3,FD4,FD5,FD6,FD7,
     B            FDVERT,FDTIME,FDSINS,FDMS,ND2X3,
     C            KFILAC,IP12,IP16,IP20,IP21,
     D            ISTAV(N),L3264B,L3264W,MISTOT,
     E            THRPHS,THRQPF,THRTRW,THRSVR,
     F            IPHSBC,PHSTMP,NSVRLOC,NX,NY,IER)
      LD(1)=0
C        ABOVE IS A SAFETY, BECAUSE CHARACTERISTICS OF ANY GRID IN
C        FDA( ) WILL BE WIPED OUT BY FILLING IS2( ) ETC. IN OPTION.
      NSIZE=IS2(3)*IS2(4)
      IF(ISTAV(N).EQ.1)NSIZE=NSTA
C
D     WRITE(KFILDO,134)N,(ID(J,N),J=1,4),ISTAV(N),IER,NSLAB,NSIZE
D134  FORMAT(' OUT OF OPTION AT 134 IN PRED25--N,ID( ,N),ISTAV(N),IER,',
D    1       'NSLAB,NSIZE',I6,I11.9,3I11,3I6,I10)
C
C        AS A SPECIAL FEATURE, IER = -1 FROM A SUBROUTINE CALLED
C        BY OPTION MEANS THAT THE DATA ARE NOT TO BE WRITTEN.
C        THIS CAN BE USED WHEN NOT ALL HOURS BEING PROCESSED
C        HAVE DATA FOR THAT HOUR (E.G., MAX/MIN TEMPERATURE).
C        ALSO, WHEN THE VARIABLE ID CANNOT BE LOCATED IN OPTION,
C        IER IS RETURNED AS -2.  THIS FACILITATES THE USE OF THE
C        LOOKBACK FEATURE WHEN NOT ALL DATA ARE AVAILABLE 
C        FOR DAY 1.
C 
      IF(IER.EQ.0)THEN
C           THE VARIABLE IS TO COME FROM OPTION.  THE SUBROUTINE
C           SHOULD HAVE SET ISTAV( ).
         IFIND(N)=0
         GO TO 1375
C
      ELSEIF(IER.EQ.-1)THEN
C           SURELY, THE VARIABLE IS TO COME FROM OPTION. 
C           THE SUBROUTINE SHOULD HAVE SET ISTAV( ).
         IFIND(N)=0
C            DON'T WRITE THIS VARIABLE TO THE ARCHIVE FILE.
C            IER = -1 IS RETURNED FROM A SUBROUTINE.  IT SHOULD
C            NOT REPRESENT AN ERROR; AN ERROR SHOULD BE IER GT 0.
C
C            WHEN CCC = 000, WRITE THIS VARIABLE TO THE INTERNAL
C            STORAGE.
C
         IF(IDPARS(1,N).EQ.000)THEN
            NCOMBO=1
C              NCOMBO HAS NO MEANING FOR VECTOR DATA.
            NPACK=1
C              THE DATA ARE NOT PACKED.
            MSDATE=0
C              THE DATE TO STORE IS ZERO.
            NR=0
C              IT IS ASSUMED THIS FIELD NEED NOT BE SAVED PAST
C              ITS DATE.
            CALL GSTORE(KFILDO,KFIL10,ID(1,N),NCOMBO,LSTORE,ND9,LITEMS,
     1                  DATA,NSTA,NPACK,NR,NDATE,
     2                  CORE,ND10,LASTL,NBLOCK,LASTD,
     3                  NSTORE,L3264B,IER) 
C              IER IS NOT CHECKED.  IF DATA AREN'T STORED CORRECTLY,
C              THEY WON'T BE READ.
         ENDIF
C
         GO TO 390
C
      ELSEIF(IER.EQ.-2)THEN
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=1
C           IER = -2 IS RETURNED FROM OPTION, WHICH MEANS VARIABLE
C           COULD NOT BE IDENTIFIED.  PUT THIS VARIABLE INTO 
C           MSTORE( , ) IN CASE IT IS A "RAW" VARIABLE AND IS 
C           JUST NOT AVAILABLE ON DAY 1.  SETTING IFIND( ) TO 1
C           KEEPS CONTROL OUT OF OPTION IN PRED22.
         ISTAV(N)=2
C           ISTAV(N) SET TO 2 WHEN THE VARIABLE COULD NOT BE
C           IDENTIFIED IN OPTION.  THIS WILL LET IT BE FOUND
C           ON INPUT IN CASES WHERE IT WAS NOT AVAILABLE ON
C           DAY 1.
C          
         GO TO 1343
C
      ELSEIF(IER.EQ.47)THEN
C           DON'T COUNT THIS AS AN ERROR.  IT IS POSSIBLE THE
C           VARIABLE IS FOUND IN OPTION, BUT MISSING DATA FROM
C           GFETCH THROWS IT TO OPTN2, WHERE THE VARIABLE CAN'T
C           BE IDENTIFIED.  THIS IS PROBABLY JUST CAUSED BY
C           MISSING DATA, AND OPTN2 DOES NOT WRITE A DIAGNOSTIC
C           UNLESS COMPILED WITH /D.
         IFIND(N)=2
C           STILL DON'T KNOW WHERE THE VARIABLE IS TO COME FROM.
         GO TO 1343
C
      ELSEIF(IER.EQ.120)THEN
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=0
C           THE VARIABLE IS TO COME FROM OPTION.
         IER=0
C           IER = 120 IS FROM FINDST IN CONST AND MEANS SOME
C           STATIONS COULD NOT BE FOUND.  THIS IS NOT FATAL.
         GO TO 1375
C
      ELSE
         ISTOP(1)=ISTOP(1)+1
         IFIND(N)=0
C           SURELY, THE VARIABLE IS TO COME FROM OPTION.
         GO TO 300
C
      ENDIF
C        IF OPTION COULD NOT IDENTIFY A VARIABLE, THEN IT
C        IT IS LIKELY THE VARIABLE IS ONE AVAILABLE ON
C        INPUT, BUT NOT AT THE FIRST DATE/TIME.  ENTER
C        IT INTO MSTORE( , ) IN ANTICIPATION.  THIS MAY
C        NOT WORK IN ALL CASES.  ONE PROBLEM IS THAT IT
C        IS NOT KNOWN WHETHER THIS IS A GRID NEEDED AT
C        TAU = IDPARS(12, ), IN WHICH CASE THE 4TH ID
C        WORD WOULD BE 0, OR WHETHER IT IS INTERPOLATED
C        DATA FROM A GRID, IN WHICH CASE THE 4TH ID 
C        WORD WOULD CONTAIN THE THRESHOLD, I, AND S.
C        MORE THAN ONE POSSIBILITY IS INCLUDED TO TRY
C        COVER ALL BASES.  NORMALLY, A BINARY WOULD
C        NOT BE LOOKED FOR AND IS NOT PROVIDED FOR,
C        EXCEPT FOR A GRID BINARY.
C
 1343 MITEMS=MITEMS+1
C
      IF(MITEMS.GT.ND9)THEN
         WRITE(KFILDO,1345)
 1345    FORMAT(/' ****ND9 =',I5,' NOT LARGE ENOUGH.',
     1           '  STOP AT 1345 IN PRED25.')
         STOP 1345
      ENDIF
C
      MSTORE(1,MITEMS)=IDPARS(1,N)*1000000+
     1                 IDPARS(2,N)*1000+
     2                 IDPARS(4,N)
      MSTORE(2,MITEMS)=ID(2,N)
      MSTORE(3,MITEMS)=IDPARS(8,N)*100000000+
     1                 IDPARS(10,N)*100000+
     2                 IDPARS(11,N)*1000+
     3                 IDPARS(12,N)
      MSTORE(4,MITEMS)=0
C
      IF(IDPARS(9,N).EQ.0)THEN
C           NOTE THAT ONLY "ON-TIME" DATA HAVE OTHER THAN 7777.
         MSTORE(5,MITEMS)=N+7777
         MSTORE(6,MITEMS)=NDATE
         MSTORE(7,MITEMS)=0
      ELSE
         MSTORE(5,MITEMS)=7777
         CALL UPDAT(NDATE,-IDPARS(9,N),LDATE)
         MSTORE(6,MITEMS)=LDATE
         MSTORE(7,MITEMS)=IDPARS(9,N)
C           DATA MAY BE KEPT LONGER THAN NEEDED; CAN'T
C           BE HELPED.
      ENDIF
C
C        DON'T KEEP IF A DUPLICATE, AND MAKE SURE
C        IT IS KEPT FAR ENOUGH BACK.
C
      IF(MITEMS.EQ.1)GO TO 1350
C
      DO 135 L=1,MITEMS-1
      IF(MSTORE(1,L).NE.MSTORE(1,MITEMS).OR.
     1   MSTORE(2,L).NE.MSTORE(2,MITEMS).OR.
     2   MSTORE(3,L).NE.MSTORE(3,MITEMS).OR.
     3   MSTORE(4,L).NE.MSTORE(4,MITEMS))GO TO 135
      IF(MOD(MSTORE(6,L),100).NE.MOD(MSTORE(6,MITEMS),100))GO TO 135
C        THE ABOVE STATEMENT KEEPS THE ENTRY IF ITS CYCLE 
C        IS DIFFERENT.
C
      IF(MSTORE(5,L).GT.7777)THEN 
         GO TO 1348
      ELSEIF(MSTORE(5,L).EQ.7777)THEN
C
         IF(MSTORE(5,MITEMS).EQ.7777)THEN
            GO TO 1348
         ELSEIF(MSTORE(5,MITEMS).LT.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,MITEMS)+7777
         ENDIF
C
      ELSE
C
         IF(MSTORE(5,MITEMS).LE.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,L)+7777
         ENDIF
C
      ENDIF
C
 1348 MSTORE(6,L)=MIN(MSTORE(6,L),MSTORE(6,MITEMS))
      MSTORE(7,L)=MAX(MSTORE(7,L),MSTORE(7,MITEMS))
C        
      MITEMS=MITEMS-1 
      GO TO 1350
C
 135  CONTINUE
C
C        THE BELOW IS FOR VECTOR DATA.  THIS SHOULD WORK
C        FOR OBSERVATIONS AND PREVIOUSLY COMPUTED/INTERPOLATED
C        DATA.  BINARIES ARE NOT PROVIDED FOR, EXCEPT FOR
C        GRID BINARIES.
C
 1350 MITEMS=MITEMS+1
C
      IF(MITEMS.GT.ND9)THEN
      WRITE(KFILDO,1351)
 1351 FORMAT(/' ****ND9 =',I5,' NOT LARGE ENOUGH.',
     1         '  STOP AT 1351 IN PRED25.')
      STOP 1351
      ENDIF
C
      MSTORE(1,MITEMS)=IDPARS(1,N)*1000000+
     1                 IDPARS(2,N)*1000+
     2                 IDPARS(4,N)
C
      IF(IDPARS(3,N).EQ.5)THEN
C           THIS IS A GRID BINARY.
         MSTORE(1,MITEMS)=MSTORE(1,MITEMS)+IDPARS(3,N)*100
      ENDIF
C
      MSTORE(2,MITEMS)=ID(2,N)
      MSTORE(3,MITEMS)=ID(3,N)
      MSTORE(4,MITEMS)=ID(4,N)
C        
      IF(IDPARS(9,N).EQ.0)THEN
C           NOTE THAT ONLY "ON-TIME" DATA HAVE OTHER THAN 7777.
         MSTORE(5,MITEMS)=N
      ELSE
         MSTORE(5,MITEMS)=7777
      ENDIF
C
      MSTORE(6,MITEMS)=NDATE
      MSTORE(7,MITEMS)=0
C
C        DON'T KEEP IF A DUPLICATE, AND MAKE SURE
C        IT IS KEPT FAR ENOUGH BACK.
C
      IF(MITEMS.EQ.1)GO TO 1370
C
      DO 137 L=1,MITEMS-1
      IF(MSTORE(1,L).NE.MSTORE(1,MITEMS).OR.
     1   MSTORE(2,L).NE.MSTORE(2,MITEMS).OR.
     2   MSTORE(3,L).NE.MSTORE(3,MITEMS).OR.
     3   MSTORE(4,L).NE.MSTORE(4,MITEMS))GO TO 137
C
      IF(MSTORE(5,L).GT.7777)THEN 
         GO TO 136
      ELSEIF(MSTORE(5,L).EQ.7777)THEN
C
         IF(MSTORE(5,MITEMS).EQ.7777)THEN
            GO TO 136
         ELSEIF(MSTORE(5,MITEMS).LT.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,MITEMS)+7777
         ENDIF
C
      ELSE
C
         IF(MSTORE(5,MITEMS).LE.7777)THEN
            MSTORE(5,MITEMS)=MSTORE(5,L)+7777
         ENDIF
C
      ENDIF
C        
 136  MSTORE(6,L)=MIN(MSTORE(6,L),MSTORE(6,MITEMS))
      MSTORE(7,L)=MAX(MSTORE(7,L),MSTORE(7,MITEMS))
C        
      MITEMS=MITEMS-1
      GO TO 1370    
C
 137  CONTINUE
C
 1370 IER=0
C***D     WRITE(KFILDO,1374)((MSTORE(I,J),I=1,7),J=1,MITEMS)
C***D1374 FORMAT(' MSTORE IN PRED25 AT 1374'/(' '7I12))
      GO TO 300
C
C        COMES THROUGH HERE ONLY FOR IER = 0.
C
 1375 IF(ISTAV(N).EQ.1)GO TO 230
C        VECTOR DATA ARE NOT SAVED IN FDA( ).  TRANSFORMATION
C        AND BINARY OPERATORS ARE USED FOR VECTOR DATA FROM
C        OPTION (BUT NOT FOR VECTOR DATA NOT FROM OPTION). 
C
C        DETERMINE WHETHER OR NOT THE DATA IN DATA( ) CAN BE USED FOR
C        THE NEXT VARIABLE.  IF SO, SAVE IT IN FDA( ).  THIS IS OK 
C        EVEN THOUGH THE VALUES MAY BE SET TO THE MISSING VALUE.
C        NORMALLY, A MISSING FIELD IS NOT SAVED  OPTION DOES NOT SET
C        MISSING VALUES WHEN THE FIELD CANNOT BE RETURNED BECAUSE 
C        GFETCH HAS JUST BEEN CALLED WHICH DOES RETURN MISSING VALUES
C        WHICH ARE CARRIED OVER.  WHEN ISTAV( ) EQ 1, MISSING STATION
C        VALUES SHOULD BE RETURNED.  OCCASIONALLY, DATA WILL BE STORED
C        IN FDA( ) THAT ARE NOT NEEDED.  THIS HAPPENS WHEN 
C        INTERPOLATION AND SMOOTHING ARE THE SAME, BUT THE POINT BINARY
C        AND TRANSFORMATION IS PERFORMED ON THE INTERPOLATED DATA.
C        HOWEVER, SINCE THE PROGRAM LOOKS AHEAD ONLY ONE VARIABLE, IT IS
C        POSSIBLE THE DATA WOULD BE NEEDED EVEN THOUGH IT IS NOT NEEDED
C        FOR THE NEXT VARIABLE.
C
 138  IF(N.EQ.NPRED)GO TO 204
C        THE LAST VARIABLE IN THE LIST NEED NOT BE SAVED.
      IF(NSIZE.GT.ND2X3)GO TO 204
C        NSIZE CAN BE GREATER THAN ND2X3, BECAUSE ND5 CAN EXCEED
C        ND2X3.  THIS IS TO HANDLE LARGE CONSTANT GRIDS, SUCH
C        AS FINE SCALE TERRAIN.
C
C        SAVE GRID FOR POSSIBLE REUSE.  IT IS POSSIBLE IT WON'T BE 
C        NEEDED FOR THE NEXT VARIABLE (E.G., POINT BINARY) BUT
C        WILL BE NEEDED FOR THE NEXT (E.G., GRID BINARY).  OR IT
C        MAY NOT BE NEEDED AT ALL, BUT THIS CONTINGENCY KEEPS
C        GRIDS FROM BEING STORED BY GSTORE UNNECESSARILY IN
C        SUBSEQUENT PASSES IN PRED22.
C
      IF(JD(1,N).NE.JD(1,N+1).OR.
     1   JD(2,N).NE.JD(2,N+1).OR.
     2   JD(3,N).NE.JD(3,N+1).OR.
     3   IDPARS(3,N).EQ.2.OR.
C           ABOVE ADDED 9/30/09 FOR RF FROM SREF WITH B = 2
     4   IDPARS(15,N).NE.IDPARS(15,N+1))GO TO 204
C        THE IDPARS(15, ) CHECK IS A SAFETY.  AT PRESENT, IDPARS(15, )
C        IS NOT USED.  VARIANCE GRIDS WILL BE SAVED, BUT MAY
C        NOT BE NEEDED.  THE ORDERING DOES NOT NECESSARILY KEEP
C        THE SAME VALUES OF IDPARS(8, ) TOGETHER.
C
      IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)GO TO 204
C        TERRAIN HEIGHT IS NOT SAVED WHEN DD = 0 (DD = 5 FOR LAMP
C        FORECASTS).
C
      LD(1)=JD(1,N)
      LD(2)=JD(2,N)
      LD(3)=JD(3,N)
      IF(IDPARS(8,N).GE.7)LD(3)=ID(3,N)
C        WHEN THIS IS A VARIANCE CALCULATION (ON THE GRID), THE
C        IDPARS(8,N) = T IS SAVED.
      LFIND=IFIND(N)
C        SAVES IFIND( ) SO THAT THE REUSED VARIABLE WILL HAVE THE
C        SAME VALUE.
C
D     IF(IDPARS(8,N).LT.7)THEN
D        WRITE(KFILDO,139)N,(JD(K,N),K=1,4)
D139     FORMAT(/' SAVING GRID NO.',I3,' IN FDA( ) AT 139',
D    1           ' IN PRED25    ',I13.9,3I11)
D     ELSE
D        WRITE(KFILDO,1390)N,(JD(K,N),K=1,2),ID(3,N),JD(4,N)
D1390    FORMAT(/' SAVING GRID NO.',I3,' IN FDA( ) AT 1390',
D    1           ' IN PRED25   ',I13.9,3I11)
D     ENDIF
C
      DO 140 K=1,NSIZE
      FDA(K)=DATA(K)
 140  CONTINUE
C
C        AT THIS POINT, THE VARIABLE HAS BEEN FOUND OR COMPUTED AND
C        EXISTS IN DATA( ).  THE FULL IDENTIFICATION IS IN IS1( ),
C        IS2( ), AND IS4( ).  IF IT MAY BE NEEDED FOR THE NEXT
C        VARIABLE AND IS A GRID, THE DATA ARE ALSO IN FDA( ).
C
 204  IF(IER.NE.0)GO TO 300
C        IT IS POSSIBLE THIS POINT COULD BE REACHED WITH MISSING
C        VALUES; HENCE, THE CHECK FOR IER=0 FOR SAFETY.
C
C        MAKE GRID BINARY IF DESIRED.
C
 205  IF(IDPARS(3,N).EQ.5)THEN
         CALL GRIDB(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),
     1              DATA,IWORK,IS2(3),IS2(4),IER)
C           IWORK( ) IS USED AS FLOATING POINT IN GRIDB.
C           THAT IS OK.  IWORK( ) AND DATA( ) ARE BOTH
C           DIMENSIONED ND5.
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
            GO TO 300
         ENDIF
C
      ENDIF
C
C        SMOOTH FIELD IF DESIRED.
C
      IF(IDPARS(14,N).NE.0)THEN
C
         IF(IDPARS(14,N).EQ.1)THEN
            CALL SMTH5 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.2)THEN
            CALL SMTH9 (KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.3)THEN
            CALL SMTH25(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.4)THEN
            CALL SMTH2X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
         ELSEIF(IDPARS(14,N).EQ.5)THEN
            CALL SMTH3X(KFILDO,DATA,IWORK,IS2(3),IS2(4))
C              IWORK( ) IS USED AS FLOATING POINT IN 
C              SMOOTHING ROUTINES.  THAT IS OK.  IWORK( )
C              AND DATA( ) ARE BOTH DIMENSIONED ND5.
         ENDIF
C
      ENDIF
C
C        PRINT GRIDPOINT VALUES IF DESIRED.  TRY TO MATCH PRECISION
C        OF PRINTING TO SIZE OF VALUES THROUGH ISCALD( ).  WHILE
C        THE LOOP IS INEFFICIENT, IT WILL BE EXECUTED VERY RARELY.
C
      IF(IP13.EQ.0)GO TO 2091
      IF(JP(1,N).EQ.0)GO TO 2091
      WRITE(IP13,207)(ID(J,N),J=1,4),NDATE
 207  FORMAT(/' GRIDPOINT VALUES FOR VARIABLE',I11.9,3I11,
     1        ' FOR DATE',I12/)
C
      DO 209 JY=1,IS2(4)
C
      IF(ISCALD(N).LE.-1)THEN
         WRITE(IP13,208)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 208     FORMAT(' ',10F10.1/(' ',10F10.1))
      ELSEIF(ISCALD(N).EQ.0)THEN
         WRITE(IP13,2080)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2080    FORMAT(' ',10F10.2/(' ',10F10.2))
      ELSEIF(ISCALD(N).EQ.1)THEN
         WRITE(IP13,2081)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2081    FORMAT(' ',10F10.3/(' ',10F10.3))
      ELSEIF(ISCALD(N).EQ.2)THEN
         WRITE(IP13,2082)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2082    FORMAT(' ',10F10.4/(' ',10F10.4))
      ELSE
         WRITE(IP13,2083)(DATA(K),K=(IS2(4)-JY)*IS2(3)+1,
     1                             (IS2(4)-JY)*IS2(3)+IS2(3))
 2083    FORMAT(' ',10F10.5/(' ',10F10.5))
      ENDIF
C
 209  CONTINUE
C
C        WRITE GRIDDED DATA TO SEQUENTIAL FILE IP19.  THIS IS PRIMARILY
C        FOR GMOS_PLOT, AND THE DATA ARE SCALED AS NEEDED (SEE ABOVE).  
C 
 2091 IF(IP19.NE.0)THEN
         ITAUH=IDPARS(12,N)
         ITAUM=0
         MODNO=IDPARS(4,N) 
         NSEQ=0     
         NPROJ=NGRIDC(1,NSLAB) 
         XMESHL=NGRIDC(2,NSLAB)/1000000. 
         XLAT=NGRIDC(3,NSLAB)/10000.
         ORIENT=NGRIDC(4,NSLAB)/10000.
         ALATL=NGRIDC(5,NSLAB)/10000.
         ALONL=NGRIDC(6,NSLAB)/10000.
         NX=IS2(3)
         NY=IS2(4)
         CALL NOMINL(KFILDO,XMESHL,MESH,TRASH,NPROJ,IER)
C           MESH IS THE NOMINL GRID MESH LENGTH.
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
            WRITE(KFILDO,2092)
 2092       FORMAT('     GRID NOT WRITTEN TO IP(19).')
C              THIS FOLLOWS A **** DIAGNOSTIC IN NOMINL.
            GO TO 210
         ENDIF
C
         IF(IDPARS(1,NPRED).EQ.002)THEN
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,1.8,-459.67,0,IER)
C              THIS SCALES TEMPERATURE IN KELVIN TO F.
C
CCC         ELSEIF(IDPARS(1,NPRED).EQ.001.AND.IDPARS(7,N).EQ.1000)THEN
CCC            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,.25,-5.,0,IER)
C              THIS SCALES 1000 MB HEIGHT FOR GMOS_PLOT TEMP SCALE.
C
         ELSEIF(IDPARS(1,NPRED).EQ.004.AND.IDPARS(7,N).EQ.850)THEN
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,2.,0.,0,IER)
C              THIS SCALES 850 MB U- OR V-WIND FOR GMOS_PLOT TEMP SCALE.
C
         ELSEIF(IDPARS(1,NPRED).EQ.001.AND.IDPARS(7,N).EQ.500)THEN
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,.1,-530.,0,IER)
C              THIS SCALES 500 MB HEIGHT FOR GMOS_PLOT TEMP SCALE.
C
         ELSEIF(IDPARS(1,NPRED).EQ.001.AND.IDPARS(7,N).EQ.1000)THEN
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,.1,20.,0,IER)
CCC            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,.5,-70.,0,IER)
C              THIS SCALES 1000 MB HEIGHT FOR GMOS_PLOT TEMP SCALE.
C              SPREAD SCALE.
C
         ELSE
            CALL SCALX2(KFILDO,DATA,FD4,NX*NY,1.,0.,0,IER)
C              THIS JUST COPIES THE DATA FROM DATA( ) TO FD4( ).
         ENDIF
C
         NCHAR=32         
         XMISSP=0.
         XMISSS=0.
C           IT IS ASSUMED THERE ARE NO MISSING VALUES IN THE GRID.
         CALL PAWGTS(KFILDO,IP19,'IP19  ',KFILDO,NDATE,
     1               ID(1,N),ITAUH,ITAUM,MODNO,NSEQ,ISCALD(N),
     2               NPROJ,ALATL,ALONL,ORIENT,MESH,XLAT,NX,NY,
     3               FD4,IWORK,FD1,IPACK,ND5,MINPK,
     4               IS0,IS1,IS2,IS4,ND7,
     5               IPLAIN(1,1,N),PLAIN(N),NCHAR,
     6               XMISSP,XMISSS,LX,IOCTET,
     7               N19TBY,N19TRC,L3264B,L3264W,IER)
C           NOTE THAT GRIDPOINT DATA TO PACK ARE IN FD4( ).
C
         IF(IER.NE.0)THEN
            WRITE(KFILDO,2094)
 2094       FORMAT(/' ****ERROR IN PAWGTS IN PRED25 AT 2094.',
     1              '  GRID NOT WRITTEN TO IP19.  CONTINUING.')
C              ERROR WRITING TO THIS DIAGNOSTIC GRID IS NOT CONSIDERED
C              FATAL, BUT ISTOP(1) IS INCREMENTED.
            ISTOP(1)=ISTOP(1)+1
            GO TO 210
         ENDIF
C         
      ENDIF
C
C        WRITE THE GRIDDED DATA TO RANDOM ACCESS FILE 43, IF 
C        PROVIDED.
C
      DO 2096 JJ=1,6
C
      IF(KFILRA(JJ).EQ.43)THEN
         ISCALE=0
         RAFILG=RACESS(JJ)
C
C            NOTE THAT ARRAY DATA( ) CONTAINS THE PACKED DATA.
C
         CALL PACKGR(KFILDO,KFILRA(JJ),RACESS(JJ),ID(1,N),IDPARS(1,N),
     1               ISCALD(N),ISCALE,NGRIDC(1,NSLAB),
     2               IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3               FD2,DATA,ND2X3,NX,NY,IPACK,IWORK,ND5,MINPK,
     4               IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5               NWORDS,NTOTBG,NTOTRG,
     6               L3264B,L3264W,ISTOP,IER)
C
         IF(IER.NE.0)THEN
C              ISTOP( ) IS INCREMENTED IN PACKGR.
            WRITE(KFILDO,2095)(ID(MMM,N),MMM=1,4),KFILRA(JJ),IER
 2095       FORMAT('     ERROR WRITING DATA FOR',
     1             1X,I9.9,2I10.9,I11.3,
     2             ' ON RANDOM ACCESS FILE UNIT NO.',I4,' IER =',I4,
     3             '.  PROCEEDING.')
         ENDIF
C     
      ENDIF
C
 2096  CONTINUE
C
C        GRIDPRINT FIELD IF DESIRED.
C
 210  IF(IP14.EQ.0)GO TO 215
      IF(JP(2,N).EQ.0)GO TO 215
C
      CALL PREDX1(KFILDO,IDPARS(1,N),THRESH(N),
     1            SMULT(N),SADD(N),ORIGIN(N),CINT(N),
     2            PLAIN(N),UNITS(N),NDATE,-IDPARS(9,N),DATA,ND5,
     3            IS2,ND7,IP14,ISTOP(1),IER)
C        PREDX1 ALWAYS RETURNS IER = 0, EXCEPT FOR A PROBLEM
C        WITH GRIDPRINTING.  THIS DOES NOT CAUSE MISSING DATA.
C
C        PACK AND WRITE THE GRIDPOINT FIELD TO A SEQUENTIAL FILE
C        WHEN A UNIT NUMBER KFILGO NE 0 IS PROVIDED.  IT IS
C        POSSIBLE SOME GRIDS WILL HAVE PRIMARY MISSING VALUES
C        (E.G., CEILING HEIGHT FOR LAMP).  (PACKG IS USED IN
C        U202/PACK23)
C
 215  IF(KFILGO.NE.0)THEN
         XMISSP=9999.
         XMISSS=0.
         CALL PACKG(KFILDO,KFILGO,ID(1,N),IDPARS(1,N),
     1              ISCALD(N),0,NGRIDC(1,NSLAB),
     2              IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3              FD1,DATA,ND2X3,IS2(3),IS2(4),IPACK,IWORK,ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              NWORDS,LTOTBG,LTOTRG,
     6              L3264B,L3264W,ISTOP(1),IER)
C           NOTE THAT GRIDPOINT DATA TO PACK ARE IN DATA( ).
      ENDIF
C
C        INTERPOLATE TO STATIONS.
C
 220  NGOMIS=0
C        CONTROL HERE SHOULD MEAN NON-MISSING DATA.
CCC      WRITE(KFILDO,221)(ID(J,N),J=1,4),IER
CCC 221  FORMAT(/' AT 221 IN PRED25--(ID(J,N),J=1,4),IER',5I10)
C
CCC      WRITE(KFILDO,2211)NSIZE,NSLAB,(DATA(J),J=1,NSIZE,1000)
CCC 2211 FORMAT(/' AT 2211--NSIZE,NSLAB,(DATA(J),J=1,NSIZE)',2I8,/,
CCC     1      (10F10.3))
C
      IF(IDPARS(13,N).EQ.1)THEN
         CALL INTRPA(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPA IS BIQUADRATIC INTERPOLATION WHERE POSSIBLE,
C           BILINEAR OTHERWISE.
C
      ELSEIF(IDPARS(13,N).EQ.2)THEN
         CALL INTRPB(KFILDO,DATA,IS2(3),IS2(4),
     1               DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPB IS BILINEAR.
C
      ELSEIF(IDPARS(13,N).EQ.3)THEN
         CALL INTRP(KFILDO,DATA,IWORK,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRP IS INTERPOLATION FOR PRECIPITATION AMOUNT.  THE
C           PROCESS IS BILINEAR AFTER PREPARATION OF THE FIELD 
C           TO PUT THE ZERO LINE ABOUT HALFWAY BETWEEN POSITIVE 
C           AND ZERO GRIDPOINTS.
C           IWORK( ) IS USED AS FLOATING POINT IN INTRP.
C           THAT IS OK.  IWORK( ) AND DATA( ) ARE BOTH
C           DIMENSIONED ND5.
C
      ELSEIF(IDPARS(13,N).EQ.4)THEN
         CALL INTRPC(KFILDO,DATA,IS2(3),IS2(4),
     1              DIR(1,1,NSLAB),ND1,NSTA,SDATA)
C           INTRPC IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT.
C
      ELSEIF(IDPARS(13,N).EQ.5)THEN
         NX=IS2(3)
         NY=IS2(4)
         CALL INTRPD(KFILDO,KFIL10,IP12,
     1               ID(1,N),IDPARS(1,N),JD(1,N),NDATE,
     2               KFILRA,RACESS,NUMRA,
     3               CCALL,ICALLD,CCALLD,NAME,STALAT,STALON,NELEV,
     4               ISDATA,SDATA,DIR,ND1,NSTA,
     5               NGRIDC,NGRID,ND11,NSLAB,
     6               IPACK,IWORK,ND5,
     7               LSTORE,ND9,LITEMS,CORE,ND10,LASTL,
     8               NBLOCK,LASTD,NSTORE,NFETCH,
     9               ND7,
     A               DATA,FD1,FD2,FD3,FD4,ND2X3,NX,NY,
     B               L3264B,L3264W,ISTOP(1),IER)
C           INTRPC IS "INTERPOLATION" BY FINDING THE NEAREST
C           GRIDPOINT WITHIN THE 4-GRIDPOINT BOX WHERE THE STATION
C           IS LOCATED, BUT CONTINGENT ON A MASK INDICATING
C           A GRIDPOINT THAT CAN BE USED AND THE DIFFERENCE
C           BETWEEN THE ELEVATION OF THE GRIDPOINT AND THE
C           STATION BEING WITHIN BOUNDS (HARDWIRED IN INTRPD).
C
         IF(IER.NE.0)THEN
            ISTOP(1)=ISTOP(1)+1
C              IER NE 0 FROM INTRPD IS TREATED AS AN ERROR, BUT
C              PROCESSING PROCEEDS.  IF THE GENERIC IDS WERE USED,
C              THE DATA ARE GOOD, BUT ISTOP(1) HAS BEEN INCREMENTED
C              IN INTRPD AND IER CAN = 0; IN OTHER CASES, THE DATA ARE
C              MISSING.  THE TRANSFORMATIONS BELOW HANDLE MISSING
C              VALUES.
            ISTOP(2)=ISTOP(2)+1
C              ANY IER NE 0 WILL MEAN MISSING DATA.  NOTE THAT THIS
C              IS THE ONLY "INTERPOLATION" ROUTINE THAT CAN ITSELF
C              CREATE AN ERROR OR MISSING DATA.
            IER=0
         ENDIF
C
      ELSEIF(IDPARS(1,N).GE.400.AND.IDPARS(1,N).LE.499)THEN
C            FOR THIS GRIDDED DATA FIELD, AN INTERPOLATION VALUE
C            OF 1, 2, 3, 4, OR 5 IS REQUIRED.
         WRITE(KFILDO,228)(JD(K,N),K=1,4)
 228     FORMAT(/' ****GRIDDED CONSTANT ',3I10.9,I11.3,' DOES NOT HAVE',
     1           ' A VALID INTERPOLATION VALUE IN IDPARS(13).'/
     2           '     DATA ARE SAVED IN INTERNAL STORAGE AS MISSING.',
     3           '  COUNTED AS MISSING ONLY THIS ONCE.')
         ISTOP(1)=ISTOP(1)+1
         GO TO 300
      ELSE
         GO TO 300
C           WHEN THE INTERPOLATION VALUE IS NOT LEGITIMATE, CKIDS WILL
C           HAVE PRINTED A DIAGNOSTIC EXCEPT FOR THE CONSTANTS
C           TREATED IMMEDIATELY ABOVE.
      ENDIF
C
C        TRANSFORM VARIABLE WHEN DESIRED.  FROM HERE ON, DATA ARE 
C        VECTOR.
C
 230  IF(IDPARS(1,N).GE.200.AND.IDPARS(1,N).LE.299)GO TO 350
      IF(IDPARS(1,N).GE.300.AND.IDPARS(1,N).LE.399)GO TO 350
      IF(IDPARS(1,N).GE.500.AND.IDPARS(1,N).LE.599)GO TO 350
      IF(IDPARS(1,N).GE.600.AND.IDPARS(1,N).LE.699)GO TO 350
C        IT IS ASSUMED THAT IF CCC = 2XX (MOS FORECASTS), 
C        3XX (COMBINATION OF MODELS), 5XX (1-D TRANSFORMATIONS)
C        AND 6XX (2-D TRANSFORMATIONS) SHOULD NOT HAVE BINARY
C        PROCESSING DONE.
C
      IF(IDPARS(10,N).EQ.9)GO TO 350
C        WHEN IDPARS(10, ) = 9, THE THRESHOLD IS USED THROUGH OPTION
C        AND NO FURTHER PROCESSING IS DONE.
C
      IF(IDPARS(8,N).NE.0.AND.IDPARS(8,N).LT.7)
C            IDPARS(8, ) DOES NOT APPLY TO VECTOR DATA FOR 7, 8, AND 9.
     1    CALL TRANS(KFILDO,ID(1,N),IDPARS(8,N),SDATA,NSTA,FD1,ND2X3,
     2               IER)
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           WHEN IER NE O, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
         GO TO 312
      ENDIF
C
C         MAKE POINT BINARY VARIABLE WHEN DESIRED.
C
      IF(IDPARS(3,N).EQ.1)
     1    CALL BINARY(KFILDO,ID(1,N),IDPARS(3,N),THRESH(N),SDATA,NSTA,
     2                IER)
C
      IF(IER.NE.0)THEN
         ISTOP(1)=ISTOP(1)+1
C           WHEN IER NE O, ALL VALUES IN SDATA( ) HAVE BEEN SET TO 9999.
         GO TO 312
      ENDIF
C
C        CURRENTLY, THE ONLY LEGITIMATE VALUES OF IDPARS(3, ) ARE O, 1, 2,
C        AND 5 IN U720.  OTHER VALUES CAUSE VALUES TO BE SET TO MISSING.
C        THIS ACCOMMODATES THE CUMULATIVE FROM ABOVE POINT BINARIES THAT
C        CAN BE USED AS PREDICTORS AND GRID BINARIES, BUT NOT CUMULATIVE
C        FROM BELOW OR DISCRETE BINARIES THAT CAN BE USED AS PREDICTANDS.
C        HOWEVER, IT ALSO ACCOMMODATES B = 2 FOR RELATIVE FREQUENCIES
C        AND PERCENTS AS MIGHT COME FROM AN ENSEMBLE (E.G., THE SREF).
C        NORMALLY, BINARIES WILL NOT BE MADE BY U720 BECAUSE ALL USING
C        PROGRAMS OF U720 OUTPUT WILL HAVE BINARY CAPABILITY.
C
      IF(IDPARS(3,N).EQ.0.OR.
     1   IDPARS(3,N).EQ.1.OR.
     2   IDPARS(3,N).EQ.5)GO TO 350
C
C        THE DATA ARE MISSING OR HAVE A NON-LEGITIMATE BINARY
C        INDICATOR.  NOTE THAT CCC = 2XX, 3XX, 5XX, AND 6XX HAVE BEEN
C        EXEMPTED FROM BINARY PROCESSING.  SET ALL VALUES TO 9999
C        EXCEPT IDPARS(3,N) = 2 IS PERMITTED, THIS LATTER FOR 
C        RELATIVE FREQUENCIES FROM THE SREF MODEL.
C
      IF(IDPARS(3,N).EQ.2)THEN 
C
         IF(IFIRST.EQ.0)THEN
            WRITE(KFILDO,298)(ID(J,N),J=1,4)
 298        FORMAT(/' ****BINARY INDICATOR IDPARS(3, ) = 2 IN PRED25',
     1             ' MAY BE AN ERROR FOR VARIABLE ',3I10.9,I11.3,/,
     2              '     BINARY INDICATOR IGNORED.  THIS DIAGNOSTIC',
     3              ' WILL NOT PRINT AGAIN IN PRED25.') 
            ISTOP(1)=ISTOP(1)+1
            IFIRST=1
         ENDIF
C
         GO TO 350 
C         
      ENDIF
C  
      WRITE(KFILDO,299)(ID(J,N),J=1,4)
 299  FORMAT(/' ****BINARY INDICATOR IDPARS(3, ) NE 0, 1, 2,OR 5',
     1        ' IS AN ERROR FOR ',3I10.9,I11.3,
     2        '.  SET TO MISSING.') 
C
 300  DO 310 K=1,NSTA
      SDATA(K)=9999.
 310  CONTINUE
C
CCCD     WRITE(KFILDO,311)((MSTORE(I,J),I=1,7),J=1,MITEMS)
CCCD311  FORMAT(' MSTORE IN PRED25 AT 311'/(' ',7I12))
C
 312  ISTOP(2)=ISTOP(2)+1
C        AN ATTEMPT IS MADE TO COUNT ALL MISSING FIELDS IN ISTOP(2),
C        EVEN IF AN ERROR HAS BEEN COUNTED IN ISTOP(1).
      NGOMIS=1
C        SET NGOMIS = 1 TO KEEP FROM REUSING A GRID WITH 
C        MISSING VALUES.
      XMISSP=9999.
      XMISSS=0.
      GO TO 380
C        DON'T WRITE IDPARS(1, ) = 409 TO INTERNAL STORAGE IF
C        RECORD IS MISSING.  THIS WILL LET PRED22 COUNT MISSING 
C        RECORDS.  SINCE ALL VALUES = 9999., NO REASON TO ENTER
C        SETMIS.
C
C        SET XMISSP AND XMISSS.  NOTE THAT ANY VALUES OF 9997
C        IN VECTOR DATA HAVE BEEN SET TO PXMISS IN RDSTR2.
C        9997 IS NOT EXPECTED OR DEALT WITH IN GRIDPOINT DATA.
C        OPTION SHOULD NOT RETURN 9997 UNLESS IT IS DESIRED
C        TO LEAVE THOSE VALUES IN THE OUTPUT.
C
 350  CALL SETMIS(KFILDO,SDATA,NSTA,XMISSP,XMISSS)
C
C        FOR TERRAIN, SAVE VECTOR IN GSTORE.  THIS WILL BE THE
C        SAME FOR EACH DAY FOR DD = 0 (DD = 5 FOR LAMP FORECASTS).
C
 360  IF(IDPARS(1,N).EQ.409.AND.IDPARS(4,N).EQ.0)THEN
         NCOMBO=1
C           NCOMBO HAS NO MEANING FOR VECTOR DATA.
         NPACK=1
C           THE DATA ARE NOT PACKED.
         MSDATE=0
C           THE DATE TO STORE IS ZERO.
         CALL GSTORE(KFILDO,KFIL10,ID(1,N),NCOMBO,LSTORE,ND9,LITEMS,
     1               SDATA,NSTA,NPACK,NRRDAT,MSDATE,
     2               CORE,ND10,LASTL,NBLOCK,LASTD,
     3               NSTORE,L3264B,IER) 
      ENDIF
C
 380  CONTINUE
C
C        PACK AND WRITE THE VECTOR DATA TO SEQUENTIAL FILE
C        WHEN KFILVO.NE.0 AND JP(3,N).NE.0.
C
      IF(JP(3,N).NE.0)THEN
C        JP(3,N) CONTROLS WRITING OF VECTOR DATE TO BOTH
C        SEQUENTIAL AND EXTERNAL RANDOM ACCESS FILES. 
C        IN ADDITION, TO WRITE TO SEQUENTIAL, KFILVO HAS TO BE
C        NE 0 AND TO WRITE TO RA, 49 HAS TO BE ONE OF THE 
C        KFILRA( ) UNITS.
C
C***      WRITE(KFILDO,388)IS0,IS1,IS2
C*** 388  FORMAT(/' AT 388 IN PRED25--IS0,IS1,IS2'/(5(10I10/),4I10/))
C***      WRITE(KFILDO,389)ID(1,N),N,IP15,ISCALD(N),ND1,NSTA,
C***     1       ND5,ND7,L3264B,L3264W,NDATE,NTOTBV,NTOTRV,
C***     1      (SDATA(K),K=1,NSTA)
C*** 389  FORMAT(/' AT 389 IN PRED25--N,ID(1,N),IP15,ISCALD(N),ND1,NSTA,',
C***     1         'ND5,ND7,L3264B,L3264W,NDATE,NTOTBV,NTOTRV'/
C***     2         I10,12I8/
C***     3         (20F6.1))
C***D     WRITE(KFILDO,3890)(ID(J,N),J=1,4),NDATE,(SDATA(K),K=1,NSTA)
C***D3890 FORMAT(/' IN PRED25 AT 3890--(ID(J,N),J=1,4),NDATE,',
C***D    1        '(SDATA(K),K=1,NSTA)',5I12/(20F6.0))
C
C           SET XMISSS = 0 OR 9997, RESPECTIVELY, DEPENDING ON
C           WHETHER OR NOT A 9997 OCCURS IN THE DATA TO BE 
C           PACKED.  SET XMISSP = 0 OR 9999, RESPECTIVELY, DEPENDING ON
C           WHETHER A 9997 OR 9999 OCCURS IN THE DATA.
C
         CALL SETMIS(KFILDO,SDATA,NSTA,XMISSP,XMISSS)
         CALL PACKV(KFILDO,KFILVO,ID(1,N),IDPARS(1,N),
     1              JP(1,N),ISCALD(N),0,
     2              IPLAIN(1,1,N),PLAIN(N),NDATE,NYR,NMO,NDA,NHR,
     3              CCALL,ISDATA,SDATA,ND1,NSTA,IPACK,ND5,MINPK,
     4              IS0,IS1,IS2,IS4,ND7,XMISSP,XMISSS,
     5              IP15,NWORDS,LTOTBV,LTOTRV,
     6              L3264B,L3264W,ISTOP(1),IER)
C           PACK WILL ALWAYS PACK THE DATA, BUT WILL WRITE TO
C           SEQUENTIAL ONLY IF KFILVO NE 0. PACK WIL WRITE TO IP15
C           ONLY WHEN NON ZERO AND JP(3,N) IS NON ZERO.
         IF(IER.NE.0)GO TO 390
C           AN ERROR IN PACKV MAY MEAN THE DATA COULD NOT BE PACKED
C           CORRECTLY, SO DON'T WRITE TO RANDOM ACCESS.
C
C           WRITE TO EXTERNAL RA WHEN KFILRA( ) CONTAINS 49, THE
C           ONLY UNIT AVAILABLE FOR WRITING VECTOR DATA.
C
         DO 3895 J=1,NUMRA
C
         IF(KFILRA(J).EQ.49)THEN
            NREPLA=2
C              REPLACE RECORD IF FOUND OR WRITE NEW RECORD.
            NCHECK=0
            RAFILV=RACESS(J)
            CALL WRTDLR(KFILDO,KFILRA(J),RACESS(J),IS1(9),
     1                  ICALL,CCALL,ND1,NSTA,
     1                  ICALLD,CCALLD,ND5,IPACK,NWORDS,
     2                  NREPLA,NCHECK,L3264B,L3264W,IER) 
C              IS1(9) IS ESSENTIALLY ID(1,N).  FOR CCC = 400-499,
C              THE DD IS STRIPPED OFF IN PACKV.  THIS SHOULD NOT
C              MATTER HERE.
            IF(IER.NE.0)THEN
               ISTOP(1)=ISTOP(1)+1
C                 AN ERROR IN WRTDLR WILL PRINT A DIAGNOSTIC.
               GO TO 390
            ELSE
C                 THE CALCULATION OF BYTES IS THE SAME AS IN PACKV
C                 WHEN THE DATA ARE ACTUALLY WRITTEN.  THIS REPRESENTS
C                 THE BYTES OF DATA AND DOES NOT INCLUDE THE WORD
C                 (FOR L3264B = 32) WRITTEN PRECEEDING THE DATA.
C                 
               IF(L3264B.EQ.32)THEN
                  NTOTBV=NTOTBV+NWORDS*4
               ELSE
                  NTOTBV=NTOTBV+NWORDS*8
               ENDIF
C
               NTOTRV=NTOTRV+1
            ENDIF
C
            GO TO 390
         ENDIF
C
 3895    CONTINUE
C
      ENDIF
C
 390  CONTINUE
C
C***D     WRITE(KFILDO,391)N,(ID(J,N),J=1,4),
C***D    1                 ISTAV(N),ISTOP(1),ISTOP(2),IFIND(N),IER
C***D391  FORMAT(/' AT 391 IN PRED25--N,(ID(J,N),J=1,4),',
C***D    1                'ISTAV(N),ISTOP(1),ISTOP(2),IFIND(N),IER',
C***D    2                 /I6,I11.9,3I11,5I6)
C
 400  CONTINUE
C
D     IF(MITEMS.EQ.0)THEN
D        WRITE(KFILDO,404)
D404     FORMAT(' NO ITEMS IN MSTORE IN PRED25 AT 404')
D     ELSE
D        WRITE(KFILDO,405)((MSTORE(I,J),I=1,7),J=1,MITEMS)
D405     FORMAT(' MSTORE IN PRED25 AT 405'/(' ',7I12))
D     ENDIF
C
      RETURN
      END
      
